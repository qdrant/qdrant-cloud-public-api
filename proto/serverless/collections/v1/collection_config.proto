syntax = "proto3";

package serverless.collections.v1;

import "buf/validate/validate.proto";
import "google/protobuf/struct.proto";

// DenseVectorConfiguration defines the settings for dense vector fields
message DenseVectorConfiguration {
  // The dimensionality of the vector space
  int32 dimension = 1;
  // The distance metric used for vector similarity calculations
  string distance = 2 [(buf.validate.field).string = {
    in: [
      "cosine",
      "euclid",
      "dot",
      "manhattan"
    ]
  }];
  // Whether to use multi-vector storage for this configuration
  optional bool multivector = 3;
  // Whether to enable rescoring for search results
  optional bool rescoring = 4;
  // The storage performance tier to use (STORAGE, BALANCED, or PERFORMANCE)
  optional string storage_tier = 5 [(buf.validate.field).string = {
    in: [
      "storage",
      "balanced",
      "performance"
    ]
  }];
  // The precision level for vector operations (LOW, MEDIUM, or HIGH)
  optional string precision_tier = 6 [(buf.validate.field).string = {
    in: [
      "low",
      "medium",
      "high"
    ]
  }];
}

// SparseVectorConfiguration defines the settings for sparse vector fields
message SparseVectorConfiguration {
  // Precision tier for vector operations
  string precision_tier = 1 [(buf.validate.field).string = {
    in: [
      "low",
      "medium",
      "high"
    ]
  }];
  // Vector value modification approach
  string modifier = 2 [(buf.validate.field).string = {
    in: [
      "none",
      "idf"
    ]
  }];
}

// KeywordIndexParams defines parameters for keyword indexing
message KeywordIndexParams {
  // Whether this field is used as tenant identifier
  optional bool is_tenant = 1;
  // Whether to store index on disk vs memory
  optional bool on_disk = 2;
}

// IntegerIndexParams defines parameters for integer indexing
message IntegerIndexParams {
  // Enable lookup operations
  optional bool lookup = 1;
  // Enable range queries
  optional bool range = 2;
  // Whether this is a principal field
  optional bool is_principal = 3;
  // Whether to store index on disk vs memory
  optional bool on_disk = 4;
}

// FloatIndexParams defines parameters for float indexing
message FloatIndexParams {
  // Whether this is a principal field
  optional bool is_principal = 1;
  // Whether to store index on disk vs memory
  optional bool on_disk = 2;
}

// GeoIndexParams defines parameters for geographical indexing
message GeoIndexParams {
  // Whether to store index on disk vs memory
  optional bool on_disk = 1;
}

// TextIndexParams defines parameters for text indexing
message TextIndexParams {
  // Tokenization strategy
  optional string tokenizer = 1 [(buf.validate.field).string = {
    in: [
      "prefix",
      "whitespace",
      "word",
      "multilingual"
    ]
  }];
  // Minimum token length to index
  optional int32 min_token_len = 2;
  // Maximum token length to index
  optional int32 max_token_len = 3;
  // Whether to lowercase text before indexing
  optional bool lowercase = 4;
  // Whether to store index on disk vs memory
  optional bool on_disk = 5;
}

// BoolIndexParams defines parameters for boolean indexing
message BoolIndexParams {
  // Whether to store index on disk vs memory
  optional bool on_disk = 1;
}

// DatetimeIndexParams defines parameters for datetime indexing
message DatetimeIndexParams {
  // Whether this is a principal field
  optional bool is_principal = 1;
  // Whether to store index on disk vs memory
  optional bool on_disk = 2;
}

// UuidIndexParams defines parameters for UUID indexing
message UuidIndexParams {
  // Whether this field is used as tenant identifier
  optional bool is_tenant = 1;
  // Whether to store index on disk vs memory
  optional bool on_disk = 2;
}

// CollectionConfiguration defines the structure and settings for a collection
message CollectionConfiguration {
  // Field name used for tenant isolation
  optional string tenant_key = 1;
  // Map of dense vector configurations with field name as key
  map<string, DenseVectorConfiguration> dense_vectors = 2;
  // Map of sparse vector configurations with field name as key
  map<string, SparseVectorConfiguration> sparse_vectors = 3;
  // Schema definition for payload fields
  map<string, google.protobuf.Value> payload_schema = 4;
}
