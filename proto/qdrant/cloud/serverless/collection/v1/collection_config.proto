syntax = "proto3";

package qdrant.cloud.serverless.collection.v1;

import "buf/validate/validate.proto";

// CollectionConfiguration defines the structure and settings for a collection
message CollectionConfiguration {
  // Field name used for tenant isolation
  optional string tenant_key = 1 [(buf.validate.field).string.min_len = 1];
  // Map of dense vector configurations with field name as key
  map<string, DenseVectorConfiguration> dense_vectors = 2 [(buf.validate.field).map = {
    keys: {
      string: {pattern: "^[a-zA-Z0-9-_]+$"}
    }
  }];
  // Map of sparse vector configurations with field name as key
  map<string, SparseVectorConfiguration> sparse_vectors = 3 [(buf.validate.field).map = {
    keys: {
      string: {pattern: "^[a-zA-Z0-9-_]+$"}
    }
  }];
  // Schema definition for payload fields
  map<string, PayloadFieldSchema> payload_schema = 4 [(buf.validate.field).map = {
    keys: {
      string: {pattern: "^[a-zA-Z0-9-_]+$"}
    }
  }];
}

// DistanceMetric defines the possible distance metrics used in DenseVectorConfiguration.
enum DistanceMetric {
  // Unspecified distance metric.
  DISTANCE_METRIC_UNSPECIFIED = 0;
  // Cosine similarity.
  DISTANCE_METRIC_COSINE = 1;
  // Euclidean distance.
  DISTANCE_METRIC_EUCLID = 2;
  // Dot product.
  DISTANCE_METRIC_DOT = 3;
  // Manhattan distance.
  DISTANCE_METRIC_MANHATTAN = 4;
}

// StorageTier defines the possible storage performance tiers used in DenseVectorConfiguration.
enum StorageTier {
  // Unspecified storage tier.
  STORAGE_TIER_UNSPECIFIED = 0;
  // Storage tier.
  STORAGE_TIER_STORAGE = 1;
  // Balanced tier.
  STORAGE_TIER_BALANCED = 2;
  // Performance tier.
  STORAGE_TIER_PERFORMANCE = 3;
}

// PrecisionTier defines the level of precision for vector operations.
enum PrecisionTier {
  // Unspecified precision level.
  PRECISION_TIER_UNSPECIFIED = 0;
  // Low precision.
  PRECISION_TIER_LOW = 1;
  // Medium precision.
  PRECISION_TIER_MEDIUM = 2;
  // High precision.
  PRECISION_TIER_HIGH = 3;
}

// VectorModifier defines the transformations to apply to vectors.
enum VectorModifier {
  // Unspecified modifier.
  VECTOR_MODIFIER_UNSPECIFIED = 0;
  // No modifications.
  VECTOR_MODIFIER_NONE = 1;
  // Inverse Document Frequency (IDF).
  VECTOR_MODIFIER_IDF = 2;
}

// DenseVectorConfiguration defines the settings for dense vector fields
message DenseVectorConfiguration {
  // The dimensionality of the vector space
  int32 dimension = 1 [(buf.validate.field).int32.gt = 0];
  // The distance metric used for vector similarity calculations
  DistanceMetric distance = 2 [(buf.validate.field).enum = {
    defined_only: true
    not_in: [0]
  }];
  // Whether to use multi-vector storage for this configuration
  optional bool multivector = 3;
  // Whether to enable rescoring for search results
  optional bool rescoring = 4;
  // The storage performance tier to use.
  optional StorageTier storage_tier = 5 [(buf.validate.field).enum.defined_only = true];
  // The precision level for vector operations.
  optional PrecisionTier precision_tier = 6 [(buf.validate.field).enum.defined_only = true];
}

// SparseVectorConfiguration defines the settings for sparse vector fields
message SparseVectorConfiguration {
  // The precision level for vector operations.
  PrecisionTier precision_tier = 1 [(buf.validate.field).enum = {
    defined_only: true
    not_in: [0]
  }];
  // Vector value modification approach
  VectorModifier modifier = 2 [(buf.validate.field).enum = {
    defined_only: true
    not_in: [0]
  }];
}

// KeywordIndexParams defines parameters for keyword indexing
message KeywordIndexParams {
  // Whether this field is used as tenant identifier
  optional bool is_tenant = 1;
  // Whether to store index on disk vs memory
  optional bool on_disk = 2;
}

// IntegerIndexParams defines parameters for integer indexing
message IntegerIndexParams {
  // Enable lookup operations
  optional bool lookup = 1;
  // Enable range queries
  optional bool range = 2;
  // Whether this is a principal field
  optional bool is_principal = 3;
  // Whether to store index on disk vs memory
  optional bool on_disk = 4;
}

// FloatIndexParams defines parameters for float indexing
message FloatIndexParams {
  // Whether this is a principal field
  optional bool is_principal = 1;
  // Whether to store index on disk vs memory
  optional bool on_disk = 2;
}

// GeoIndexParams defines parameters for geographical indexing
message GeoIndexParams {
  // Whether to store index on disk vs memory
  optional bool on_disk = 1;
}

// Tokenizer defines the strategies for tokenizing text during indexing.
enum Tokenizer {
  // Unspecified tokenizer.
  TOKENIZER_UNSPECIFIED = 0;
  //Prefix tokenizer.
  TOKENIZER_PREFIX = 1;
  // Whitespace tokenizer.
  TOKENIZER_WHITESPACE = 2;
  // Word tokenizer.
  TOKENIZER_WORD = 3;
  // Multilingual tokenizer.
  TOKENIZER_MULTILINGUAL = 4;
}

// TextIndexParams defines parameters for text indexing
message TextIndexParams {
  // Tokenization strategy
  optional Tokenizer tokenizer = 1 [(buf.validate.field).enum.defined_only = true];
  // Minimum token length to index
  optional int32 min_token_len = 2 [(buf.validate.field).int32.gte = 0];
  // Maximum token length to index
  optional int32 max_token_len = 3 [(buf.validate.field).int32.gte = 0];
  option (buf.validate.message).cel = {
    id: "text_index_params.max_len_ge_min_len"
    message: "max_token_len must be greater than or equal to min_token_len"
    expression: "!has(this.min_token_len) || !has(this.max_token_len) || this.max_token_len >= this.min_token_len"
  };
  // Whether to lowercase text before indexing
  optional bool lowercase = 4;
  // Whether to store index on disk vs memory
  optional bool on_disk = 5;
}

// BoolIndexParams defines parameters for boolean indexing
message BoolIndexParams {
  // Whether to store index on disk vs memory
  optional bool on_disk = 1;
}

// DatetimeIndexParams defines parameters for datetime indexing
message DatetimeIndexParams {
  // Whether this is a principal field
  optional bool is_principal = 1;
  // Whether to store index on disk vs memory
  optional bool on_disk = 2;
}

// UuidIndexParams defines parameters for UUID indexing
message UuidIndexParams {
  // Whether this field is used as tenant identifier
  optional bool is_tenant = 1;
  // Whether to store index on disk vs memory
  optional bool on_disk = 2;
}

// Describes the schema for a payload field
message PayloadFieldSchema {
  // Oneof for index parameters
  oneof index_params {
    option (buf.validate.oneof).required = true;
    // Keyword index parameters
    KeywordIndexParams keyword = 1;
    // Integer index parameters
    IntegerIndexParams integer = 2;
    // Float index parameters
    FloatIndexParams float = 3;
    // Geo Index parameters
    GeoIndexParams geo = 4;
    // Text index parameters
    TextIndexParams text = 5;
    // Boolean index parameters
    BoolIndexParams bool = 6;
    // Datetime index parameters
    DatetimeIndexParams datetime = 7;
    // UUID index parameters
    UuidIndexParams uuid = 8;
  }
}
