syntax = "proto3";

package qdrant.cloud.common.v1;

import "buf/validate/validate.proto";
import "google/protobuf/descriptor.proto";

// The extension for adding permissions to the system
extend google.protobuf.MethodOptions {
  // A list of permissions which need to be met by the current user.
  // If `requires_all_permissions` is true (or missing): ALL of the permissions should be met (and)
  // If `requires_all_permissions` is false: ANY-OF the permissions should be met (or)
  repeated string permissions = 50001 [(buf.validate.field).repeated.items.string = {min_len: 1}];
}

// The extension for adding an expression where to find the account ID in a message
// If the extension is missing 'account_id' will be used.
extend google.protobuf.MethodOptions {
  // The expression to find the account ID field, which should be a string field.
  // It is allowed to nest fields with a point, like 'cluster.account_id' or 'account.id'
  // If the expression is set to an empty string, no account ID will be used.
  string account_id_expression = 50002 [(buf.validate.field).string = {pattern: "^(|[a-z_]+(\\.[a-z_]+)*)$"}];
}

// The extension for allowing a method to be be used without authentication.
// If the extension is missing the system requires authentication and return a 'permission denied' error if missing.
extend google.protobuf.MethodOptions {
  // Set to allow a method to be used without authentication.
  bool requires_authentication = 50003;
}

// The extension for allowing a method to be be used with specific actor types.
// If the extension is missing the system allows all actor types.
extend google.protobuf.MethodOptions {
  // If this option is set, only the specified actor types are allowed to call the method.
  // If empty or not set, all authenticated actor types (that pass other permission checks) are allowed.
  repeated ActorType supported_actor_types = 50004 [
    packed = true,
    (buf.validate.field).repeated.items.enum = {
      defined_only: true
      not_in: [0]
    }
  ];
}

// The extension for switching `permissions` from ALL to ANY-OF
// If the extension is missing 'true' will be used (defaulting to ALL).
extend google.protobuf.MethodOptions {
  // If set to true the provided permissions are ALL (and)
  // if set to false the provided permissions are ANY-OF (or).
  bool requires_all_permissions = 50005;
}

// The extension for adding an override of the default maximum message size (in MB).
extend google.protobuf.MethodOptions {
  // The override of the default maximum message size in MB (per message).
  int32 max_message_size = 50006 [(buf.validate.field).int32 = {
    gte: 1
    lte: 1024
  }];
}

// The extension for logging a specific set of fields.
extend google.protobuf.MethodOptions {
  // The fields to log.
  repeated LogField log_fields = 50007;
}

// ActorType specifies the type of actor that can call a method.
enum ActorType {
  // Default, unspecified actor type. Should generally not be used explicitly in options
  // unless to signify an error or uninitialized state.
  ACTOR_TYPE_UNSPECIFIED = 0;
  // Represents a human user, typically authenticated via an identity provider (Auth0).
  ACTOR_TYPE_USER = 1;
  // Represents a programmatic access key, also called management key,
  // that is not be tied to a specific user or service account identity, but rather an account.
  ACTOR_TYPE_MANAGEMENT_KEY = 2;
  // Represents a service account or machine user, often used for M2M communication.
  // This is for internal platform use only.
  ACTOR_TYPE_SERVICE_ACCOUNT = 3;
}

// LogField represents a field to log (in case of an error).
message LogField {
  // The name of the field to log (in the logger).
  // It will automatically prefixed with `request.`
  string name = 1 [(buf.validate.field).string = {
    min_len: 1
    max_len: 64
    pattern: "^[a-z][a-z_]*$"
  }];
  // The field expression to find the value of the field to log (in the request).
  // It is allowed to nest fields with a point, like 'cluster.account_id' or 'account.id'
  string field_expression = 2 [(buf.validate.field).string = {pattern: "^(|[a-z_]+(\\.[a-z_]+)*)$"}];
}

// Semantic version number.
message Version {
  // Major version (increasing may break APIs)
  uint32 major = 1;
  // Minor version (increased for new features)
  uint32 minor = 2;
  // Patch version (increased for fixes)
  uint32 patch = 3;
}

// SecretKeyRef is a reference to a Kubernetes secret name and the key inside the secret
message SecretKeyRef {
  // The name of the secret (in the same namespace as the QdrantCluster CRD instance)
  // This is a required field
  string name = 1 [(buf.validate.field).string = {
    min_len: 1
    max_len: 253 // Kubernetes secret names have a max length of 253
    pattern: "^[a-z0-9]([-a-z0-9]*[a-z0-9])?$" // Kubernetes secret name restrictions
  }];
  // The key inside the secret
  // This is a required field
  string key = 2 [(buf.validate.field).string = {
    min_len: 1
    max_len: 1024
  }];
}

// KeyValue is a key-value tuple (used in e.g. node selectors / annotations)
// The message represents an object for Kubernetes.
message KeyValue {
  // The key part of a key-value pair
  string key = 1 [(buf.validate.field).string = {
    max_len: 253
    pattern: "^([a-z0-9A-Z]([-a-z0-9A-Z]*[a-z0-9A-Z])?(\\.[a-z0-9A-Z]([-a-z0-9A-Z]*[a-z0-9A-Z])?)*\\/)?([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]$"
  }];
  // The value part of a key-value pair
  string value = 2 [(buf.validate.field).string = {max_len: 1024}];
}

// TopologySpreadConstraint specifies how to spread matching pods among the given topology.
message TopologySpreadConstraint {
  // max_skew describes the degree to which pods may be unevenly distributed.
  // When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
  // between the number of matching pods in the target topology and the global minimum.
  // For example, in a 3-zone cluster, max_skew is set to 1, and pods with the same
  // labelSelector spread as 1/1/0:
  // +-------+-------+-------+
  // | zone1 | zone2 | zone3 |
  // +-------+-------+-------+
  // |   P   |   P   |       |
  // +-------+-------+-------+
  // - if max_skew is 1, incoming pod can only be scheduled to zone3 to become 1/1/1;
  // scheduling it onto zone1(zone2) would make the ActualSkew(2-0) on zone1(zone2)
  // violate MaxSkew(1).
  // - if max_skew is 2, incoming pod can be scheduled onto any zone.
  // When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
  // to topologies that satisfy it.
  // Default value is 1 and 0 is not allowed.
  optional int32 max_skew = 1 [(buf.validate.field).int32.gt = 0];

  // topology_key is the key of node labels. Nodes that have a label with this key
  // and identical values are considered to be in the same topology.
  // We consider each <key, value> as a "bucket", and try to put balanced number
  // of pods into each bucket.
  // It's a required field.
  string topology_key = 2 [(buf.validate.field).string.min_len = 1];

  // when_unsatisfiable indicates how to deal with a pod if it doesn't satisfy
  // the spread constraint.
  // - DoNotSchedule (default) tells the scheduler not to schedule it.
  // - ScheduleAnyway tells the scheduler to schedule the pod in any location,
  //   but giving higher precedence to topologies that would help reduce the
  //   skew.
  // A constraint is considered "Unsatisfiable" for an incoming pod
  // if and only if every possible node assignment for that pod would violate
  // "max_skew" on some topology.
  // For example, in a 3-zone cluster, max_skew is set to 1, and pods with the same
  // labelSelector spread as 3/1/1:
  // +-------+-------+-------+
  // | zone1 | zone2 | zone3 |
  // +-------+-------+-------+
  // | P P P |   P   |   P   |
  // +-------+-------+-------+
  // If when_unsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
  // to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
  // max_skew(1). In other words, the cluster can still be imbalanced, but scheduler
  // won't make it *more* imbalanced.
  optional string when_unsatisfiable = 3 [(buf.validate.field).string = {
    in: [
      "DoNotSchedule",
      "ScheduleAnyway"
    ]
  }];
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
// This is a gRPC-native equivalent of the Kubernetes LabelSelectorRequirement.
message LabelSelectorRequirement {
  // key is the label key that the selector applies to.
  string key = 1 [(buf.validate.field).string = {min_len: 1}];
  // operator represents a key's relationship to a set of values.
  // Valid operators are In, NotIn, Exists and DoesNotExist.
  string operator = 2 [(buf.validate.field).string = {
    in: [
      "In",
      "NotIn",
      "Exists",
      "DoesNotExist"
    ]
  }];
  // values is an array of string values.
  // If the operator is In or NotIn, the values array must be non-empty.
  // If the operator is Exists or DoesNotExist, the values array must be empty.
  repeated string values = 3;
  option (buf.validate.message).cel = {
    id: "label_selector_requirement.values_for_in_not-in"
    message: "values must be non-empty when operator is In or NotIn"
    expression: "!(this.operator == 'In' || this.operator == 'NotIn') || this.values.size() > 0"
  };
  option (buf.validate.message).cel = {
    id: "label_selector_requirement.values_for_exists_not-exists"
    message: "values must be empty when operator is Exists or DoesNotExist"
    expression: "!(this.operator == 'Exists' || this.operator == 'DoesNotExist') || this.values.size() == 0"
  };
}

// A label selector is a label query over a set of resources. The result of match_labels and
// match_expressions are AND-ed. An empty label selector matches all objects.
// This is a gRPC-native equivalent of the Kubernetes LabelSelector.
message LabelSelector {
  // match_labels is a map of {key,value} pairs.
  // match_labels is a list of KeyValue objects.
  repeated KeyValue match_labels = 1 [(buf.validate.field).repeated = {max_items: 10}];
  // match_expressions is a list of label selector requirements. The requirements are AND-ed.
  repeated LabelSelectorRequirement match_expressions = 2 [(buf.validate.field).repeated = {max_items: 10}];
}

// IPBlock describes a particular CIDR (e.g. "192.168.1.1/24") that is allowed
// to the pods.
// This is a gRPC-native equivalent of the Kubernetes IPBlock.
message IPBlock {
  // CIDR is a string representing the IP Block.
  // Valid examples are "192.168.1.1/24" or "2001:db9::/64".
  string cidr = 1 [(buf.validate.field).string = {ip_prefix: true}];
  // Except is a slice of CIDRs that should not be included within an IP Block.
  // Except values will be rejected if they are outside the CIDR range.
  repeated string except = 2 [(buf.validate.field).repeated.items.string = {ip_prefix: true}];
}

// PeerSelector selects pods and/or namespaces.
message PeerSelector {
  // This is a label selector which selects Pods.
  // If NamespaceSelector is also set, then the NetworkPolicyPeer as a whole selects
  // the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
  // Otherwise it selects the Pods matching PodSelector in the policy's own Namespace.
  optional LabelSelector pod_selector = 1;
  // Selects Namespaces using cluster-scoped labels.
  // If PodSelector is also set, then the NetworkPolicyPeer as a whole selects
  // the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
  // Otherwise it selects all Pods in the Namespaces selected by NamespaceSelector.
  optional LabelSelector namespace_selector = 2;
}

// NetworkPolicyPeer describes a peer to allow traffic to/from.
// This is a gRPC-native equivalent of the Kubernetes NetworkPolicyPeer.
message NetworkPolicyPeer {
  // Specifies the type of peer. Only one of the following fields may be set.
  oneof peer_type {
    // Selects pods and/or namespaces.
    PeerSelector selector = 1;
    // Defines policy on a particular IPBlock.
    IPBlock ip_block = 2;
  }
}

// NetworkPolicyPort describes a port to allow traffic on.
// This is a gRPC-native equivalent of the Kubernetes NetworkPolicyPort.
message NetworkPolicyPort {
  // The protocol (TCP, UDP, or SCTP) which traffic must match. If not specified, this
  // field defaults to TCP.
  optional string protocol = 1 [(buf.validate.field).string = {
    in: [
      "TCP",
      "UDP",
      "SCTP"
    ]
  }];
  // The port on the given protocol. This can either be a numerical or named
  // port on a pod. If this field is not provided, this matches all port names and
  // numbers.
  oneof port_spec {
    // A numerical port number.
    int32 port_number = 2 [(buf.validate.field).int32 = {gt: 0}];
    // A named port on a pod.
    string port_name = 3 [(buf.validate.field).string = {min_len: 1}];
  }
  // If set, indicates that the range of ports from port to end_port, inclusive,
  // should be allowed by the policy. This field cannot be defined if the port field
  // is defined as a named (string) port.
  // The end_port must be equal to or greater than port.
  optional int32 end_port = 4 [(buf.validate.field).int32 = {gt: 0}];
  option (buf.validate.message).cel = {
    id: "network_policy_port.end_port_with_port_name"
    message: "end_port cannot be set when port_name is used"
    expression: "!has(this.port_name) || !has(this.end_port)"
  };
  option (buf.validate.message).cel = {
    id: "network_policy_port.end_port_ge_port_number"
    message: "end_port must be greater than or equal to port_number"
    expression: "!has(this.end_port) || !has(this.port_number) || this.end_port >= this.port_number"
  };
}

// NetworkPolicyIngressRule describes a particular set of traffic that is allowed to the pods
// matched by a NetworkPolicySpec's podSelector. The traffic must match both ports and from.
// This is a gRPC-native equivalent of the Kubernetes NetworkPolicyIngressRule.
message NetworkPolicyIngressRule {
  // List of ports which should be made accessible on the pods selected for this
  // rule. Each item in this list is combined using a logical OR. If this field is
  // empty or missing, this rule matches all ports (traffic not restricted by port).
  // If this field is present and contains at least one item, then this rule allows
  // traffic only if the traffic matches at least one port in the list.
  repeated NetworkPolicyPort ports = 1;
  // List of sources which should be able to access the pods selected for this rule.
  // Items in this list are combined using a logical OR operation. If this field is
  // empty or missing, this rule matches all sources (traffic not restricted by
  // source). If this field is present and contains at least one item, this rule
  // allows traffic only if the traffic matches at least one item in the from list.
  repeated NetworkPolicyPeer from = 2;
}

// NetworkPolicyEgressRule describes a particular set of traffic that is allowed out of pods
// matched by a NetworkPolicySpec's podSelector. The traffic must match both ports and to.
// This is a gRPC-native equivalent of the Kubernetes NetworkPolicyEgressRule.
message NetworkPolicyEgressRule {
  // List of destination ports for outgoing traffic.
  // Each item in this list is combined using a logical OR. If this field is
  // empty or missing, this rule matches all ports (traffic not restricted by port).
  // If this field is present and contains at least one item, then this rule allows
  // traffic only if the traffic matches at least one port in the list.
  repeated NetworkPolicyPort ports = 1;
  // List of destinations for outgoing traffic of pods selected for this rule.
  // Items in this list are combined using a logical OR operation. If this field is
  // empty or missing, this rule matches all destinations (traffic not restricted by
  // destination). If this field is present and contains at least one item, this rule
  // allows traffic only if the traffic matches at least one item in the to list.
  repeated NetworkPolicyPeer to = 2;
}

// StorageTierType defines type of storage performance tiers which maps to predefined IOPS and Throughput amount
enum StorageTierType {
  // No storage tier type is configured, same as COST_OPTIMIZED
  STORAGE_TIER_TYPE_UNSPECIFIED = 0;
  // Base pre-configured type
  STORAGE_TIER_TYPE_COST_OPTIMISED = 1;
  // Mid tier pre-configured type
  STORAGE_TIER_TYPE_BALANCED = 2;
  // Most performant pre-configured type
  STORAGE_TIER_TYPE_PERFORMANCE = 3;
}
