syntax = "proto3";

package qdrant.cloud.cluster.v1;

import "buf/validate/validate.proto";
import "google/api/annotations.proto";
import "google/protobuf/timestamp.proto";
import "qdrant/cloud/common/v1/common.proto";
import "qdrant/cloud/event/v1/events.proto";

// ClusterService is the API used to configure cluster objects.
service ClusterService {
  // Lists all clusters in the account identified by the given ID.
  // Required permissions:
  // - read:clusters
  rpc ListClusters(ListClustersRequest) returns (ListClustersResponse) {
    // permissions
    option (common.v1.permissions) = "read:clusters";
    // gRPC Gateway REST call
    option (google.api.http) = {get: "/api/cluster/v1/accounts/{account_id}/clusters"};
  }
  // Gets a cluster in the account identified by the given ID.
  // Required permissions:
  // - read:clusters
  rpc GetCluster(GetClusterRequest) returns (GetClusterResponse) {
    // permissions
    option (common.v1.permissions) = "read:clusters";
    // gRPC Gateway REST call
    option (google.api.http) = {get: "/api/cluster/v1/accounts/{account_id}/clusters/{cluster_id}"};
    // log fields
    option (common.v1.log_fields) = {
      name: "cluster_id"
      field_expression: "cluster_id"
    };
  }
  // Creates a cluster in the account identified by the given ID.
  // Required permissions:
  // - write:clusters
  rpc CreateCluster(CreateClusterRequest) returns (CreateClusterResponse) {
    // permissions
    option (common.v1.permissions) = "write:clusters";
    // custom account-id expression
    option (qdrant.cloud.common.v1.account_id_expression) = "cluster.account_id";
    // gRPC Gateway REST call
    option (google.api.http) = {
      post: "/api/cluster/v1/accounts/{cluster.account_id}/clusters"
      body: "*"
    };
    // events
    option (qdrant.cloud.event.v1.event_options) = {
      event_type: EVENT_TYPE_CREATED
      resource_type: "cluster"
      resource_id_field: "resp.cluster.id"
      resource_url_template: "/accounts/{req.cluster.account_id}/clusters/{resp.cluster.id}"
    };
    // log fields
    option (common.v1.log_fields) = {
      name: "cluster_name"
      field_expression: "cluster.name"
    };
  }
  // Create a new cluster from an existing backup
  // Required permissions (both):
  // - restore:backups
  // - write:clusters
  rpc CreateClusterFromBackup(CreateClusterFromBackupRequest) returns (CreateClusterFromBackupResponse) {
    // permissions
    option (common.v1.requires_all_permissions) = true;
    option (common.v1.permissions) = "restore:backups";
    option (common.v1.permissions) = "write:clusters";
    // gRPC Gateway REST call
    option (google.api.http) = {post: "/api/cluster/v1/accounts/{account_id}/backups/{backup_id}/clusters"};
    // events
    option (qdrant.cloud.event.v1.event_options) = {
      event_type: EVENT_TYPE_CREATED
      resource_type: "cluster"
      resource_id_field: "resp.cluster.id"
      resource_url_template: "/accounts/{req.account_id}/clusters/{resp.cluster.id}"
      additional_context_fields: {
        key: "from_backup_id"
        value: "req.backup_id"
      }
    };
    // log fields
    option (common.v1.log_fields) = {
      name: "backup_id"
      field_expression: "backup_id"
    };
    option (common.v1.log_fields) = {
      name: "cluster_name"
      field_expression: "cluster_name"
    };
  }

  // Updates a cluster in the account identified by the given ID.
  // Required permissions:
  // - write:clusters
  rpc UpdateCluster(UpdateClusterRequest) returns (UpdateClusterResponse) {
    // permissions
    option (common.v1.permissions) = "write:clusters";
    // custom account-id expression
    option (qdrant.cloud.common.v1.account_id_expression) = "cluster.account_id";
    // gRPC Gateway REST call
    option (google.api.http) = {
      put: "/api/cluster/v1/accounts/{cluster.account_id}/clusters/{cluster.id}"
      body: "*"
    };
    // events
    option (qdrant.cloud.event.v1.event_options) = {
      event_type: EVENT_TYPE_UPDATED
      resource_type: "cluster"
      resource_id_field: "req.cluster.id"
      resource_url_template: "/accounts/{req.cluster.account_id}/clusters/{req.cluster.id}"
    };
    // log fields
    option (common.v1.log_fields) = {
      name: "cluster_id"
      field_expression: "cluster.id"
    };
  }
  // Deletes a cluster in the account identified by the given ID.
  // Required permissions:
  // - delete:clusters
  rpc DeleteCluster(DeleteClusterRequest) returns (DeleteClusterResponse) {
    // permissions
    option (common.v1.permissions) = "delete:clusters";
    // gRPC Gateway REST call
    option (google.api.http) = {delete: "/api/cluster/v1/accounts/{account_id}/clusters/{cluster_id}"};
    // events
    option (qdrant.cloud.event.v1.event_options) = {
      event_type: EVENT_TYPE_DELETED
      resource_type: "cluster"
      resource_id_field: "req.cluster_id"
      resource_url_template: "/accounts/{req.account_id}/clusters/{req.cluster_id}"
    };
    // log fields
    option (common.v1.log_fields) = {
      name: "cluster_id"
      field_expression: "cluster_id"
    };
  }
  // Restarts a cluster in the account identified by the given ID.
  // Required permissions:
  // - write:clusters
  rpc RestartCluster(RestartClusterRequest) returns (RestartClusterResponse) {
    // permissions
    option (common.v1.permissions) = "write:clusters";
    // gRPC Gateway REST call
    option (google.api.http) = {post: "/api/cluster/v1/accounts/{account_id}/clusters/{cluster_id}/restart"};
    // events
    option (qdrant.cloud.event.v1.event_options) = {
      event_type: EVENT_TYPE_ACTION
      action_type: "restart"
      resource_type: "cluster"
      resource_id_field: "req.cluster_id"
      resource_url_template: "/accounts/{req.account_id}/clusters/{req.cluster_id}"
    };
    // log fields
    option (common.v1.log_fields) = {
      name: "cluster_id"
      field_expression: "cluster_id"
    };
  }
  // Suspends a cluster in the account identified by the given ID.
  // Required permissions:
  // - write:clusters
  rpc SuspendCluster(SuspendClusterRequest) returns (SuspendClusterResponse) {
    // permissions
    option (common.v1.permissions) = "write:clusters";
    // gRPC Gateway REST call
    option (google.api.http) = {post: "/api/cluster/v1/accounts/{account_id}/clusters/{cluster_id}/suspend"};
    // events
    option (qdrant.cloud.event.v1.event_options) = {
      event_type: EVENT_TYPE_ACTION
      action_type: "suspend"
      resource_type: "cluster"
      resource_id_field: "req.cluster_id"
      resource_url_template: "/accounts/{req.account_id}/clusters/{req.cluster_id}"
    };
    // log fields
    option (common.v1.log_fields) = {
      name: "cluster_id"
      field_expression: "cluster_id"
    };
  }
  // Unsuspends a cluster in the account identified by the given ID.
  // Required permissions:
  // - write:clusters
  rpc UnsuspendCluster(UnsuspendClusterRequest) returns (UnsuspendClusterResponse) {
    // permissions
    option (common.v1.permissions) = "write:clusters";
    // gRPC Gateway REST call
    option (google.api.http) = {post: "/api/cluster/v1/accounts/{account_id}/clusters/{cluster_id}/unsuspend"};
    // events
    option (qdrant.cloud.event.v1.event_options) = {
      event_type: EVENT_TYPE_ACTION
      action_type: "unsuspend"
      resource_type: "cluster"
      resource_id_field: "req.cluster_id"
      resource_url_template: "/accounts/{req.account_id}/clusters/{req.cluster_id}"
    };
    // log fields
    option (common.v1.log_fields) = {
      name: "cluster_id"
      field_expression: "cluster_id"
    };
  }
  // Enables JWT Role Based Access Control (RBAC) for a cluster (version 1.9+ is required) in the managed cloud environments
  // in the account identified by the given ID.
  // This can be executed once and cannot be undone, see Cluster.State.jwt_rbac for the actual value.
  // If enabled, you can generate JWT tokens with fine-grained rules for access control.
  // Required permissions:
  // - write:clusters
  rpc EnableClusterJwtRbac(EnableClusterJwtRbacRequest) returns (EnableClusterJwtRbacResponse) {
    // permissions
    option (common.v1.permissions) = "write:clusters";
    // gRPC Gateway REST call
    option (google.api.http) = {post: "/api/cluster/v1/accounts/{account_id}/clusters/{cluster_id}/enable-jwt"};
    // events
    option (qdrant.cloud.event.v1.event_options) = {
      event_type: EVENT_TYPE_ACTION
      action_type: "enabled-jwt-rbac"
      resource_type: "cluster"
      resource_id_field: "req.cluster_id"
      resource_url_template: "/accounts/{req.account_id}/clusters/{req.cluster_id}"
    };
    // log fields
    option (common.v1.log_fields) = {
      name: "cluster_id"
      field_expression: "cluster_id"
    };
  }
  // Suggests a unique and human-friendly name for a new cluster in the specified account.
  // This can be used by clients to pre-fill the name field when creating a new cluster.
  // Required permissions:
  // - None (authenticated only)
  rpc SuggestClusterName(SuggestClusterNameRequest) returns (SuggestClusterNameResponse) {
    // permissions
    option (common.v1.permissions) = "";
    // gRPC Gateway REST call
    option (google.api.http) = {get: "/api/cluster/v1/accounts/{account_id}/clusters/suggest-name"};
  }
  // Lists all Qdrant releases in the account identified by the given ID.
  // Optionally a cluster ID can be provided, the list will return the update options for that cluster only.
  // Required permissions:
  // - read:clusters
  rpc ListQdrantReleases(ListQdrantReleasesRequest) returns (ListQdrantReleasesResponse) {
    // permissions
    option (common.v1.permissions) = "read:clusters";
    // gRPC Gateway REST call
    option (google.api.http) = {get: "/api/cluster/v1/accounts/{account_id}/releases"};
    // log fields
    option (common.v1.log_fields) = {
      name: "cluster_id"
      field_expression: "cluster_id"
    };
  }
  // Gets a Qdrant release by version in the account identified by the given ID.
  // Required permissions:
  // - read:clusters
  rpc GetQdrantRelease(GetQdrantReleaseRequest) returns (GetQdrantReleaseResponse) {
    // permissions
    option (common.v1.permissions) = "read:clusters";
    // gRPC Gateway REST call
    option (google.api.http) = {get: "/api/cluster/v1/accounts/{account_id}/releases/{version}"};
    // log fields
    option (common.v1.log_fields) = {
      name: "version"
      field_expression: "version"
    };
  }
}

// ListClustersRequest is the request for the ListClusters function
message ListClustersRequest {
  // The identifier of the account (in GUID format).
  // This is a required field.
  string account_id = 1 [(buf.validate.field).string = {uuid: true}];
  // Optional filter specifying the cloud provider where the cluster is hosted.
  // Must match one of the provider IDs returned by the `qdrant.cloud.platform.v1.PlatformService.ListCloudProviders` method.
  // If omitted, all clusters for the specified account are returned, including those hosted in hybrid cloud environments.
  optional string cloud_provider_id = 10 [(buf.validate.field).string = {min_len: 3}];
  option (buf.validate.message).cel = {
    id: "list_clusters.cloud_provider_id_present"
    message: "cloud_provider_id is required when cloud_provider_region_id is set"
    expression: "!has(this.cloud_provider_region_id) || has(this.cloud_provider_id)"
  };
  // Optional filter specifying the cloud provider region where the cluster is hosted.
  // Must match one of the region IDs returned by the `qdrant.cloud.platform.v1.PlatformService.ListCloudProviderRegions` method.
  // If this field is set, the `cloud_provider_id` is required to set as well (and it should match).
  // For hybrid this should be the hybrid cloud environment ID.
  optional string cloud_provider_region_id = 11 [(buf.validate.field).string.min_len = 1];
  // Validation for `cloud_provider_region_id`, which needs to have access to the value of cloud_provider_id as well, so this can't be a simple field validator.
  option (buf.validate.message).cel = {
    id: "cluster.cloud_provider_region_id"
    message: "cloud_provider_region_id must be a UUID if cloud_provider_id is 'hybrid'"
    expression: "this.cloud_provider_region_id.matches(\'^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\') || this.cloud_provider_id!= 'hybrid'"
  };
}

// ListClustersResponse is the response from the ListClusters function
message ListClustersResponse {
  // The actual clusters in this list
  repeated Cluster items = 1;
}

// GetClusterRequest is the request for the GetCluster function
message GetClusterRequest {
  // The identifier of the account (in GUID format).
  // This is a required field.
  string account_id = 1 [(buf.validate.field).string = {uuid: true}];
  // The identifier for the cluster (in GUID format).
  // This cluster should be part of the provided account.
  // This is a required field.
  string cluster_id = 2 [(buf.validate.field).string = {uuid: true}];
}

// GetClusterResponse is the response from the GetCluster function
message GetClusterResponse {
  // The actual cluster
  Cluster cluster = 1 [(buf.validate.field).required = true];
}

// CreateClusterRequest is the request for the CreateCluster function
message CreateClusterRequest {
  // The actual cluster
  Cluster cluster = 1 [(buf.validate.field).required = true];
  option (buf.validate.message).cel = {
    id: "create_cluster.no_read_only_fields"
    message: "read-only fields (id, created_at, deleted_at, state) must not be set on create"
    expression: "this.cluster.id == '' && !has(this.cluster.created_at) && !has(this.cluster.deleted_at) && !has(this.cluster.state)"
  };
}

// CreateClusterResponse is the response from the CreateCluster function
message CreateClusterResponse {
  // The actual cluster
  Cluster cluster = 1 [(buf.validate.field).required = true];
  option (buf.validate.message).cel = {
    id: "create_cluster.state_present"
    message: "state is required for an existing cluster"
    expression: "has(this.cluster.state)"
  };
}

// UpdateClusterRequest is the request for the UpdateCluster function
message UpdateClusterRequest {
  // The actual cluster
  Cluster cluster = 1 [(buf.validate.field).required = true];
  option (buf.validate.message).cel = {
    id: "update_cluster.id_present"
    message: "cluster.id is required for an update"
    expression: "this.cluster.id != ''"
  };
}

// UpdateClusterResponse is the response from the UpdateCluster function
message UpdateClusterResponse {
  // The actual cluster
  Cluster cluster = 1 [(buf.validate.field).required = true];
  option (buf.validate.message).cel = {
    id: "update_cluster.state_present"
    message: "state is required for an existing cluster"
    expression: "has(this.cluster.state)"
  };
}

// DeleteClusterRequest is the request for the DeleteCluster function
message DeleteClusterRequest {
  // The identifier of the account (in GUID format).
  // This is a required field.
  string account_id = 1 [(buf.validate.field).string = {uuid: true}];
  // The identifier for the cluster (in GUID format).
  // This cluster should be part of the provided account.
  // This is a required field.
  string cluster_id = 2 [(buf.validate.field).string = {uuid: true}];
  // If set, the backups of this cluster will be deleted as well.
  optional bool delete_backups = 3;
}

// DeleteClusterResponse is the response from the DeleteCluster function
message DeleteClusterResponse {
  // Empty
}

// RestartClusterRequest is the request for the RestartCluster function
message RestartClusterRequest {
  // The identifier of the account (in GUID format).
  // This is a required field.
  string account_id = 1 [(buf.validate.field).string = {uuid: true}];
  // The identifier for the cluster (in GUID format).
  // This cluster should be part of the provided account.
  // This is a required field.
  string cluster_id = 2 [(buf.validate.field).string = {uuid: true}];
}

// RestartClusterResponse is the response from the RestartCluster function
message RestartClusterResponse {
  // Empty
}

// SuspendClusterRequest is the request for the SuspendCluster function
message SuspendClusterRequest {
  // The identifier of the account (in GUID format).
  // This is a required field.
  string account_id = 1 [(buf.validate.field).string = {uuid: true}];
  // The identifier for the cluster (in GUID format).
  // This cluster should be part of the provided account.
  // This is a required field.
  string cluster_id = 2 [(buf.validate.field).string = {uuid: true}];
}

// SuspendClusterResponse is the response from the SuspendCluster function
message SuspendClusterResponse {
  // Empty
}

// UnsuspendClusterRequest is the request for the UnsuspendCluster function
message UnsuspendClusterRequest {
  // The identifier of the account (in GUID format).
  // This is a required field.
  string account_id = 1 [(buf.validate.field).string = {uuid: true}];
  // The identifier for the cluster (in GUID format).
  // This cluster should be part of the provided account.
  // This is a required field.
  string cluster_id = 2 [(buf.validate.field).string = {uuid: true}];
}

// UnsuspendClusterResponse is the response from the UnsuspendCluster function
message UnsuspendClusterResponse {
  // Empty
}

// EnableClusterJwtRbacRequest is the request for the EnableClusterJwtRbac function
message EnableClusterJwtRbacRequest {
  // The identifier of the account (in GUID format).
  // This is a required field.
  string account_id = 1 [(buf.validate.field).string = {uuid: true}];
  // The identifier for the cluster (in GUID format).
  // This cluster should be part of the provided account.
  // This is a required field.
  string cluster_id = 2 [(buf.validate.field).string = {uuid: true}];
}

// EnableClusterJwtRbacResponse is the response from the EnableClusterJwtRbac function
message EnableClusterJwtRbacResponse {
  // Empty
}

// SuggestClusterNameRequest is the request for the SuggestClusterName function
message SuggestClusterNameRequest {
  // The identifier of the account (in GUID format).
  // This is a required field.
  string account_id = 1 [(buf.validate.field).string = {uuid: true}];
}

// SuggestClusterNameResponse is the response from the SuggestClusterName function
message SuggestClusterNameResponse {
  // The suggested name for a new cluster.
  string name = 1 [(buf.validate.field).string.min_len = 1];
}

// ListQdrantReleasesRequest is the request for the ListQdrantReleases function
message ListQdrantReleasesRequest {
  // The identifier of the account (in GUID format).
  // This is a required field.
  string account_id = 1 [(buf.validate.field).string = {uuid: true}];
  // The identifier for the cluster (in GUID format).
  // This cluster should be part of the provided account.
  // This is an optional field.
  optional string cluster_id = 2 [(buf.validate.field).string = {uuid: true}];
}

// ListQdrantReleasesResponse is the response from the ListQdrantReleases function
message ListQdrantReleasesResponse {
  // The actual Qdrant releases in this list, ordered by the version field in ascending semantic version order.
  // For example: v1.12.6, v1.13.6, v1.14.1, v1.15.4
  repeated QdrantRelease items = 1;
}

// GetQdrantReleaseRequest is the request for the GetQdrantRelease function
message GetQdrantReleaseRequest {
  // The identifier of the account (in GUID format).
  // This is a required field.
  string account_id = 1 [(buf.validate.field).string = {uuid: true}];
  // The version of the Qdrant release.
  // This is a required field.
  string version = 2 [(buf.validate.field).string = {min_len: 1}];
}

// GetQdrantReleaseResponse is the response from the GetQdrantRelease function
message GetQdrantReleaseResponse {
  // The actual Qdrant release
  QdrantRelease release = 1 [(buf.validate.field).required = true];
}

// A Cluster represents one cluster of a Qdrant database.
message Cluster {
  // Unique identifier for the cluster (in GUID format).
  // This is a read-only field and will be available after a cluster is created.
  string id = 1;
  option (buf.validate.message).cel = {
    id: "cluster.id"
    message: "value must be a valid UUID"
    expression: "this.id.matches(\'^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\') || !has(this.created_at)"
  };
  // Timestamp when the cluster was created.
  // This is a read-only field and will be available after a cluster is created.
  google.protobuf.Timestamp created_at = 2;
  // Identifier of the account associated with the cluster (in GUID format).
  // This is a required field.
  string account_id = 3 [(buf.validate.field).string = {uuid: true}];
  // Name of the cluster.
  // This is a required field.
  // Name can only contain letters, numbers, underscores and dashes
  string name = 4 [(buf.validate.field).string = {
    max_len: 64
    min_len: 2
    pattern: "^[a-zA-Z0-9-_]+$"
  }];
  // Timestamp when the cluster was deleted (or is started to be deleting).
  // This is a read-only field and will be set after DeleteCluster is called.
  google.protobuf.Timestamp deleted_at = 5;
  // Cloud provider where the cluster is hosted.
  // Must match one of the provider IDs returned by the `qdrant.cloud.platform.v1.PlatformService.ListCloudProviders` method.
  // After creation, this field cannot be changed.
  string cloud_provider_id = 10 [(buf.validate.field).string = {min_len: 3}];
  // Cloud provider region where the cluster is hosted.
  // Must match one of the region IDs returned by the `qdrant.cloud.platform.v1.PlatformService.ListCloudProviderRegions` method.
  // For hybrid this should be the hybrid cloud environment ID.
  // This is a required field.
  // After creation, this field cannot be changed.
  string cloud_provider_region_id = 11 [(buf.validate.field).string.min_len = 1];
  // Validation for `cloud_provider_region_id`, which needs to have access to the value of cloud_provider_id as well, so this can't be a simple field validator.
  option (buf.validate.message).cel = {
    id: "cluster.cloud_provider_region_id"
    message: "cloud_provider_region_id must be a UUID if cloud_provider_id is 'hybrid'"
    expression: "this.cloud_provider_region_id.matches(\'^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\') || this.cloud_provider_id!= 'hybrid'"
  };
  // List of labels for a cluster. These labels are used in the cloud ui and billing reports.
  // This is an optional field
  repeated common.v1.KeyValue labels = 12 [(buf.validate.field).repeated = {max_items: 10}];
  // Current configuration details of the cluster.
  ClusterConfiguration configuration = 20 [(buf.validate.field).required = true];
  // Current state of the cluster (available after the cluster has been created).
  // All fields inside `state` are read-only.
  ClusterState state = 100;
}

// ClusterServiceType defines the type of service to use for the cluster.
// See: https://kubernetes.io/docs/reference/kubernetes-api/service-resources/service-v1/#ServiceSpec
enum ClusterServiceType {
  // Service type is unspecified.
  CLUSTER_SERVICE_TYPE_UNSPECIFIED = 0;
  // Use a service configured with type ClusterIP.
  CLUSTER_SERVICE_TYPE_CLUSTER_IP = 1;
  // Use a service configured with type NodePort.
  CLUSTER_SERVICE_TYPE_NODE_PORT = 2;
  // Use a service configured with type LoadBalancer.
  CLUSTER_SERVICE_TYPE_LOAD_BALANCER = 3;
}

// ClusterConfigurationGpuType defines GPU types available for clusters.
enum ClusterConfigurationGpuType {
  // No GPU is configured.
  CLUSTER_CONFIGURATION_GPU_TYPE_UNSPECIFIED = 0;
  // Use an NVIDIA GPU.
  CLUSTER_CONFIGURATION_GPU_TYPE_NVIDIA = 1;
  // Use an AMD GPU.
  CLUSTER_CONFIGURATION_GPU_TYPE_AMD = 2;
}

// ClusterConfigurationRestartPolicy defines restart strategies for the cluster's database.
enum ClusterConfigurationRestartPolicy {
  // Restart policy is unspecified.
  CLUSTER_CONFIGURATION_RESTART_POLICY_UNSPECIFIED = 0;
  // Rolling restart policy (one by one).
  CLUSTER_CONFIGURATION_RESTART_POLICY_ROLLING = 1;
  // Parallel restart policy (restart all at once).
  CLUSTER_CONFIGURATION_RESTART_POLICY_PARALLEL = 2;
  // Automatic restart policy.
  CLUSTER_CONFIGURATION_RESTART_POLICY_AUTOMATIC = 3;
}

// ClusterConfigurationRebalanceStrategy defines shard rebalancing strategies.
enum ClusterConfigurationRebalanceStrategy {
  // No rebalancing strategy is configured.
  CLUSTER_CONFIGURATION_REBALANCE_STRATEGY_UNSPECIFIED = 0;
  // Rebalance shards by count.
  CLUSTER_CONFIGURATION_REBALANCE_STRATEGY_BY_COUNT = 1;
  // Rebalance shards by size.
  CLUSTER_CONFIGURATION_REBALANCE_STRATEGY_BY_SIZE = 2;
  // Rebalance shards by both count and size.
  CLUSTER_CONFIGURATION_REBALANCE_STRATEGY_BY_COUNT_AND_SIZE = 3;
}

// A ClusterConfiguration represents the configuration of a cluster.
message ClusterConfiguration {
  // Timestamp when the cluster configuration was last updated.
  // This is a read-only field and will be available after a cluster is created.
  google.protobuf.Timestamp last_modified_at = 1;
  // The number of nodes in a cluster.
  // This should be a number 1...20 [both included].
  // This is a required field.
  uint32 number_of_nodes = 2 [(buf.validate.field).uint32 = {
    gte: 1
    lte: 20
  }];
  // Version of the cluster software.
  // If omitted the latest version will be used and filled out during create.
  // Use ListReleases() to determine which versions are allowed to be used.
  // See upgrade guidelines for more info.
  optional string version = 3 [(buf.validate.field).string = {pattern: "^(v(\\d+)\\.(\\d+)\\.(\\d+)|latest)$"}];
  // The package identifier used to configure the resources of the cluster. Use `qdrant.cloud.booking.v1.BookingService.ListPackages` to select one.
  // This is a required field.
  string package_id = 4 [(buf.validate.field).string = {uuid: true}];
  // The additional resources on top of the selected package.
  // This is an optional field, if not specified all additional resources are 0.
  optional AdditionalResources additional_resources = 5;
  // Configuration to setup a qdrant database.
  // This is an optional field.
  optional DatabaseConfiguration database_configuration = 7;
  // The node selector for this cluster in a hybrid cloud environment.
  // It is ignored for managed cloud clusters. This is an optional field
  repeated common.v1.KeyValue node_selector = 8 [(buf.validate.field).repeated = {max_items: 10}];
  // List of tolerations for this cluster in a hybrid cloud environment.
  // It is ignored for managed cloud clusters. This is an optional field
  repeated Toleration tolerations = 9 [(buf.validate.field).repeated = {max_items: 10}];
  // List of annotations for this cluster in a hybrid cloud environment.
  // It is ignored for managed cloud clusters. This is an optional field
  repeated common.v1.KeyValue annotations = 10 [(buf.validate.field).repeated = {max_items: 10}];
  // List of allowed IP source ranges for this cluster.
  // Field is used for both managed cloud and hybrid cloud and clusters. This is an optional field
  // The CIDRs supports IPv4 only.
  repeated string allowed_ip_source_ranges = 11 [(buf.validate.field).repeated = {
    max_items: 20
    items: {
      string: {ipv4_prefix: true}
    }
  }];
  // The type of service to use for this cluster in a hybrid cloud environment.
  // It is ignored for managed cloud clusters. This is an optional field, default is Cluster IP.
  optional ClusterServiceType service_type = 12 [(buf.validate.field).enum = {
    defined_only: true
    not_in: [0]
  }];
  // List of annotations applied to the service of this cluster in a hybrid cloud environment.
  // It is ignored for managed cloud clusters. This is an optional field
  repeated common.v1.KeyValue service_annotations = 13 [(buf.validate.field).repeated = {max_items: 10}];
  // List of labels applied to the pods of this cluster in a hybrid cloud environment.
  // It is ignored for managed cloud clusters. This is an optional field
  repeated common.v1.KeyValue pod_labels = 14 [(buf.validate.field).repeated = {max_items: 10}];
  // The percentage of CPU resources reserved for system components
  // This is an optional field, default is 20%.
  // Number between 1..80 (both included)
  optional uint32 reserved_cpu_percentage = 20 [(buf.validate.field).uint32 = {
    gte: 1
    lte: 80
  }];
  // The percentage of RAM resources reserved for system components
  // This is an optional field, default is 20%.
  // Number between 1..80 (both included)
  optional uint32 reserved_memory_percentage = 21 [(buf.validate.field).uint32 = {
    gte: 1
    lte: 80
  }];
  // The gpu type that should be used for the database
  // This is an optional field, default is No configured GPU
  optional ClusterConfigurationGpuType gpu_type = 22 [(buf.validate.field).enum = {
    defined_only: true
    not_in: [0]
  }];
  // The restart policy for the database
  // This is an optional field, default is Automatic
  optional ClusterConfigurationRestartPolicy restart_policy = 23 [(buf.validate.field).enum = {
    defined_only: true
    not_in: [0]
  }];
  // The automatic shard rebalancing strategy for the database
  // This is an optional field, default is none
  optional ClusterConfigurationRebalanceStrategy rebalance_strategy = 24 [(buf.validate.field).enum = {
    defined_only: true
    not_in: [0]
  }];
  // List of topologySpreadConstraints for this cluster in a hybrid cloud environment.
  // It is ignored for managed cloud clusters. This is an optional field
  repeated common.v1.TopologySpreadConstraint topology_spread_constraints = 25 [(buf.validate.field).repeated = {max_items: 10}];
  // Storage IOPS and Throughput configuration, defaults to COST_OPTIMISED storage configuration
  optional ClusterStorageConfiguration cluster_storage_configuration = 26;
}

// DatabaseConfigurationLogLevel defines the supported logging levels for the
// Qdrant database. See: https://docs.rs/log/latest/log/enum.LevelFilter.html
enum DatabaseConfigurationLogLevel {
  // Unspecified log level.
  DATABASE_CONFIGURATION_LOG_LEVEL_UNSPECIFIED = 0;
  // Trace log level.
  DATABASE_CONFIGURATION_LOG_LEVEL_TRACE = 1;
  // Debug log level.
  DATABASE_CONFIGURATION_LOG_LEVEL_DEBUG = 2;
  // Info log level.
  DATABASE_CONFIGURATION_LOG_LEVEL_INFO = 3;
  // Warn log level.
  DATABASE_CONFIGURATION_LOG_LEVEL_WARN = 4;
  // Error log level.
  DATABASE_CONFIGURATION_LOG_LEVEL_ERROR = 5;
  // Off log level.
  DATABASE_CONFIGURATION_LOG_LEVEL_OFF = 6;
}

// Configuration to setup a Qdrant database.
// The settings apply to managed and/or hybrid cloud, see documentation on each message for more details.
message DatabaseConfiguration {
  // The default Qdrant database collection configuration.
  // This setting is for both managed and hybrid cloud clusters, see sub-messages for more details.
  // This is an optional field.
  optional DatabaseConfigurationCollection collection = 1;
  // The default Qdrant database storage configuration.
  // This setting is for both managed and hybrid cloud clusters.
  // This is an optional field.
  optional DatabaseConfigurationStorage storage = 2;
  // The Qdrant database service configuration
  // This setting is for both managed and hybrid cloud clusters, see sub-messages for more details.
  // This is an optional field
  optional DatabaseConfigurationService service = 3;
  // The log level for the database.
  // Qdrant is written in Rust and is using: https://docs.rs/log/latest/log/enum.LevelFilter.html
  // This setting is for hybrid cloud clusters only, it is ignored for managed cloud clusters.
  // This is an optional field, default is Info.
  optional DatabaseConfigurationLogLevel log_level = 4 [(buf.validate.field).enum = {
    defined_only: true
    not_in: [0]
  }];
  // The Qdrant database TLS configuration.
  // This setting is for hybrid cloud clusters only, it is ignored for managed cloud clusters.
  // This is an optional field, if not set an unsecure connection is provided.
  optional DatabaseConfigurationTls tls = 5;
  // The Qdrant database inference configuration.
  // This setting is for managed cloud clusters only, it is ignored for hybrid cloud clusters.
  // This is an optional field, if unset, the database is not configured for cloud inferencing
  optional DatabaseConfigurationInference inference = 6;
}

// The default Qdrant database collection configuration
message DatabaseConfigurationCollection {
  // Number of replicas of each shard that network tries to maintain
  // This is an optional, the default is 1
  optional uint32 replication_factor = 1 [(buf.validate.field).uint32.gte = 1];
  // How many replicas should apply the operation for us to consider it successful
  // This is an optional, the default is 1
  optional int32 write_consistency_factor = 2 [(buf.validate.field).int32.gte = 1];
  // The default parameters for vectors.
  // This is an optional field, see DatabaseConfigurationCollectionVectors for defaults.
  optional DatabaseConfigurationCollectionVectors vectors = 3;
}

// The default Qdrant database collection vectors configuration
message DatabaseConfigurationCollectionVectors {
  // If set, this will create a collection with all vectors immediately stored in memmap storage.
  // This is the recommended way, in case your Qdrant instance operates with fast disks and you are working with large collections.
  // For more info see: https://qdrant.tech/documentation/concepts/storage/#configuring-memmap-storage
  // This is an optional field, the default value will be true.
  optional bool on_disk = 1;
}

// The Qdrant storage configuration
message DatabaseConfigurationStorage {
  // The performance related Qdrant database storage configuration
  // This is an optional field, see DatabaseConfigurationStoragePerformance for defaults.
  optional DatabaseConfigurationStoragePerformance performance = 1;
}

// The performance related Qdrant database storage configuration
message DatabaseConfigurationStoragePerformance {
  // CPU budget, how many CPUs (threads) to allocate for an optimization job.
  // If not set or set to 0 - auto selection, keep 1 or more CPUs unallocated depending on CPU size
  // If negative - subtract this number of CPUs from the available CPUs.
  // If positive - use this exact number of CPUs.
  optional int32 optimizer_cpu_budget = 1;
  // Enable async scorer which uses io_uring when rescoring.
  // Only supported on Linux, must be enabled in your kernel.
  // See: https://qdrant.tech/articles/io_uring/#and-what-about-qdrant
  optional bool async_scorer = 2;
}

// The Qdrant database service configuration
message DatabaseConfigurationService {
  // Set an api-key.
  // This setting is for hybrid cloud clusters only, for managed cloud please use qdrant.cloud.cluster.auth.[v1|v2].DatabaseApiKeyService to configure keys.
  // If set, all requests must include a header with the api-key.
  // example header: `api-key: <API-KEY>`
  optional common.v1.SecretKeyRef api_key = 1;
  // Set an api-key for read-only operations.
  // This setting is for hybrid cloud clusters only, for managed cloud please use qdrant.cloud.cluster.auth.[v1|v2].DatabaseApiKeyService to configure keys.
  // If set, all requests must include a header with the api-key.
  // example header: `api-key: <API-KEY>`
  optional common.v1.SecretKeyRef read_only_api_key = 2;
  // Previously: optional bool jwt_rbac.
  reserved 3;
  // Enable HTTPS for the REST and gRPC API
  // This setting is for hybrid cloud clusters only, for managed cloud clusters the platform controls it (and clients need to use a secure connection).
  optional bool enable_tls = 4;
}

// DatabaseConfigurationTls contains the information to setup a TLS connection to the database endpoint
message DatabaseConfigurationTls {
  // Secret to use for the certificate
  common.v1.SecretKeyRef cert = 1 [(buf.validate.field).required = true];
  // Secret to use for the private key
  common.v1.SecretKeyRef key = 2 [(buf.validate.field).required = true];
}

// DatabaseConfigurationInference contains cloud inferencing configuration
message DatabaseConfigurationInference {
  // If true, the database is configured to use cloud inferencing
  bool enabled = 1;
}

// AdditionalResources contains the information about additional resources
message AdditionalResources {
  // Additional Disk (expressed in Gib)
  uint32 disk = 3;
}

// TolerationOperator defines the valid operators for tolerations.
// See: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
enum TolerationOperator {
  // Unspecified operator.
  TOLERATION_OPERATOR_UNSPECIFIED = 0;
  // The operator means the key exists.
  TOLERATION_OPERATOR_EXISTS = 1;
  // The operator means the key equals the given value.
  TOLERATION_OPERATOR_EQUAL = 2;
}

// TolerationEffect represents the effects a taint has on pod scheduling and eviction.
// See: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
enum TolerationEffect {
  // Unspecified effect.
  TOLERATION_EFFECT_UNSPECIFIED = 0;
  // NoSchedule taint effect.
  TOLERATION_EFFECT_NO_SCHEDULE = 1;
  // PreferNoSchedule taint effect.
  TOLERATION_EFFECT_PREFER_NO_SCHEDULE = 2;
  // NoExecute taint effect.
  TOLERATION_EFFECT_NO_EXECUTE = 3;
}

// The Toleration message represents a toleration object for Kubernetes.
message Toleration {
  // The key of the taint that the toleration applies to.
  // If key is not set (or empty) together with operator `Exists` matches all keys, values and effects.
  // The key must be a valid Kubernetes qualified name.
  optional string key = 1 [(buf.validate.field).string = {
    // A key can be up to 317 characters long (253 for prefix, 1 for '/', 63 for name).
    max_len: 317
  }];
  // The operator represents a key's relationship to the value.
  // The default is TOLERATION_OPERATOR_EQUAL.
  optional TolerationOperator operator = 2 [(buf.validate.field).enum = {
    defined_only: true
    not_in: [0]
  }];
  // The value is the taint value the toleration matches to.
  // If the operator is `Exists`, the value should not be set.
  // If the operator is `Equal` (the default), the value is required.
  // 'value' must be a valid identifier (alphanumeric start/end, allows -_. in between)
  optional string value = 3 [(buf.validate.field).string = {pattern: "(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?"}];
  option (buf.validate.message).cel = {
    id: "toleration.value_for_exists"
    message: "value must not be set when operator is Exists"
    // If operator is Exists (1), value must not be present.
    expression: "this.operator != 1 || !has(this.value)"
  };
  option (buf.validate.message).cel = {
    id: "toleration.value_for_equal"
    message: "value must be set when operator is Equal (or is not set, which defaults to Equal)"
    // If operator is Equal (2) or not set (defaults to Equal), value must be present.
    expression: "(has(this.operator) && this.operator != 2) || has(this.value)"
  };
  option (buf.validate.message).cel = {
    id: "toleration.key_format_when_present"
    message: "key must be a valid Kubernetes qualified name when set and non-empty"
    expression: "!has(this.key) || this.key == '' || this.key.matches('^([A-Za-z0-9]([-A-Za-z0-9]*[A-Za-z0-9])?(\\\\.[A-Za-z0-9]([-A-Za-z0-9]*[A-Za-z0-9])?)*\\\\/)?([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]$')"
  };
  option (buf.validate.message).cel = {
    id: "toleration.key_empty_requires_exists"
    message: "operator must be 'Exists' if key is empty"
    // If key is not set or empty, operator must be Exists (1).
    expression: "(has(this.key) && this.key != '') || this.operator == 1"
  };
  // The effect indicates the taint effect to match.
  // If not set, matches all taint effects.
  optional TolerationEffect effect = 4 [(buf.validate.field).enum = {
    defined_only: true
    not_in: [0]
  }];
  // The toleration seconds indicates the duration to tolerate the taint.
  optional uint64 toleration_seconds = 5 [(buf.validate.field).uint64 = {
    gte: 0 // Ensure the value is non-negative (technically redundant for uint64)
  }];
  option (buf.validate.message).cel = {
    id: "toleration.seconds_only_for_noexecute"
    message: "tolerationSeconds is only valid when effect is NoExecute"
    expression: "!has(this.toleration_seconds) || this.effect == 3"
  };
}

// ClusterStorageConfiguration defines Storage IOPS and Throughput configuration
message ClusterStorageConfiguration {
  // Type of storage tier
  qdrant.cloud.common.v1.StorageTierType storage_tier_type = 1;
  // We might allow custom IOPS and Throughput values configuration in the future,
  // that's why ClusterStorageConfiguration is a separate message and not just a field
}

// Defines the operational or transitional state of the Qdrant cluster.
enum ClusterPhase {
  // The phase is unknown or not specified. Should not normally be used.
  CLUSTER_PHASE_UNSPECIFIED = 0;
  // The cluster is currently being created.
  CLUSTER_PHASE_CREATING = 1;
  // The cluster creation process failed.
  CLUSTER_PHASE_FAILED_TO_CREATE = 2;
  // The cluster configuration is being updated.
  CLUSTER_PHASE_UPDATING = 3;
  // The cluster update process failed.
  CLUSTER_PHASE_FAILED_TO_UPDATE = 4;
  // The cluster is undergoing scaling (up or down).
  CLUSTER_PHASE_SCALING = 5;
  // The Qdrant version in the cluster is being upgraded.
  CLUSTER_PHASE_UPGRADING = 6;
  // The cluster is in the process of being suspended.
  CLUSTER_PHASE_SUSPENDING = 7;
  // The cluster is currently suspended (inactive).
  CLUSTER_PHASE_SUSPENDED = 8;
  // The cluster suspension process failed.
  CLUSTER_PHASE_FAILED_TO_SUSPEND = 9;
  // The cluster is resuming from a suspended state.
  CLUSTER_PHASE_RESUMING = 10;
  // The cluster resumption process failed.
  CLUSTER_PHASE_FAILED_TO_RESUME = 11;
  // The cluster is operational and healthy.
  CLUSTER_PHASE_HEALTHY = 12;
  // The cluster is operational but not all components are ready or healthy.
  CLUSTER_PHASE_NOT_READY = 13;
  // The cluster is in recovery mode, potentially after a failure.
  CLUSTER_PHASE_RECOVERY_MODE = 14;
  // The cluster is under manual maintenance.
  CLUSTER_PHASE_MANUAL_MAINTENANCE = 15;
  // There was an error syncing the cluster in the cloud provider region.
  CLUSTER_PHASE_FAILED_TO_SYNC = 16;
  // The cluster was expected but not found in the cloud provider region.
  CLUSTER_PHASE_NOT_FOUND = 17;
  // The cluster is being deleted.
  CLUSTER_PHASE_DELETING = 18;
}

// ClusterState represents the current state of a cluster
// All fields in this message are read-only.
message ClusterState {
  // Version of the cluster software.
  string version = 1 [(buf.validate.field).string.min_len = 1];
  // Number of cluster nodes that are up and running.
  uint32 nodes_up = 2;
  // The date and time when the cluster was restarted.
  google.protobuf.Timestamp restarted_at = 3;
  // Current phase of the cluster.
  ClusterPhase phase = 4 [(buf.validate.field).enum.defined_only = true];
  // Reason for the current phase of the cluster.
  string reason = 5;
  // Endpoint information to access the qdrant cluster (aka database).
  ClusterEndpoint endpoint = 6 [(buf.validate.field).required = true];
  // The resources used by the cluster per node.
  // For the complete cluster you have to multiply by cluster.configuration.number_of_nodes
  ClusterNodeResourcesSummary resources = 7 [(buf.validate.field).required = true];
  // Whether the cluster can be scaled up or down.
  ClusterScalabilityInfo scalability_info = 8 [(buf.validate.field).required = true];
  // List of nodes in the cluster.
  repeated ClusterNodeInfo nodes = 9;
  // Whether or not JWT Role Based Access Control (RBAC) is enabled.
  // On hybrid-cloud this is inferred from the fact a database secret is provided.
  // On managed-cloud this depends on the version of the cluster and whether or not this feature is enabled after an upgrade.
  //                  When this setting is false (and version 1.9+ is used) you can use EnableClusterJwtRbac to update.
  // If enabled, you can generate JWT tokens with fine-grained rules for access control.
  bool jwt_rbac = 10;
}

// ClusterNodeInfo represents a node in a cluster.
// All fields in this message are read-only.
message ClusterNodeInfo {
  // Name specifies the name of the node.
  string name = 1 [(buf.validate.field).string.min_len = 1];
  // StartedAt specifies the time when the node started.
  google.protobuf.Timestamp started_at = 2;
  // Version specifies the version of Qdrant running on the node.
  string version = 3;
  // Endpoint specific to this node.
  ClusterEndpoint endpoint = 4;
  // State of the node.
  ClusterNodeState state = 10 [(buf.validate.field).enum.defined_only = true];
}

// ClusterNodeState represents the state of a cluster node.
enum ClusterNodeState {
  // The state is unspecified.
  CLUSTER_NODE_STATE_UNSPECIFIED = 0;
  // The node is starting.
  CLUSTER_NODE_STATE_STARTING = 1;
  // The node is healthy.
  CLUSTER_NODE_STATE_HEALTHY = 2;
  // The node is unhealthy.
  CLUSTER_NODE_STATE_UNHEALTHY = 3;
  // The node is suspended.
  CLUSTER_NODE_STATE_SUSPENDED = 4;
  // The node is started but still needs to do some operations to recover.
  CLUSTER_NODE_STATE_RECOVERING = 5;
}

// Endpoint information to access the qdrant cluster (aka database) or a specific node in the cluster.
// All fields in this message are a read-only field.
message ClusterEndpoint {
  // URL to access the qdrant cluster (aka database) without port
  string url = 1 [(buf.validate.field).string = {uri: true}];
  // The port to use for HTTP REST calls (6333)
  int32 rest_port = 2 [(buf.validate.field).int32.gt = 0];
  // The port to use for gRPC calls (6334)
  int32 grpc_port = 3 [(buf.validate.field).int32.gt = 0];
}

// ClusterNodeResourcesSummary represents the resources used in this cluster per node.
message ClusterNodeResourcesSummary {
  // Disk resources
  ClusterNodeResources disk = 1 [(buf.validate.field).required = true];
  // Memory resources
  ClusterNodeResources ram = 2 [(buf.validate.field).required = true];
  // CPU resources
  ClusterNodeResources cpu = 3 [(buf.validate.field).required = true];
}

// ClusterNodeResources represents the allocation of various resources for a cluster per node.
message ClusterNodeResources {
  // Base resources that are part of the standard allocation for the cluster per node.
  // This includes default CPU, memory, storage, etc.
  double base = 1 [(buf.validate.field).double.gte = 0];
  // Complimentary resources provided to the cluster at no additional cost.
  // This might include complimentary network bandwidth, credits, etc.
  double complimentary = 2 [(buf.validate.field).double.gte = 0];
  // Additional resources allocated to the cluster.
  // This could include additional storage, compute power, etc.
  double additional = 3 [(buf.validate.field).double.gte = 0];
  // The reserved is the amount used by the system, which cannot be used by the database itself.
  double reserved = 4 [(buf.validate.field).double.gte = 0];
  // The available is the total (base+complimentary+additional) - reserved
  double available = 5 [(buf.validate.field).double.gte = 0];
}

// ClusterScalabilityStatus defines the scalability states of a cluster.
enum ClusterScalabilityStatus {
  // Scalability status is unspecified.
  CLUSTER_SCALABILITY_STATUS_UNSPECIFIED = 0;
  // The cluster is not scalable.
  CLUSTER_SCALABILITY_STATUS_NOT_SCALABLE = 1;
  // The cluster supports scaling operations.
  CLUSTER_SCALABILITY_STATUS_SCALABLE = 2;
}

// ClusterScalabilityInfo provides information about the
message ClusterScalabilityInfo {
  // The current scalability status of the cluster.
  ClusterScalabilityStatus status = 1 [(buf.validate.field).enum = {
    defined_only: true
    not_in: [0]
  }];
  // Optional human-readable reason providing more context about the scalability status.
  // When a cluster is not scalable, this field explains why.
  optional string reason = 2 [(buf.validate.field).string.min_len = 1];
}

// buf:lint:ignore QDRANT_CLOUD_REQUIRED_ENTITY_FIELDS
// QdrantRelease represent a single Qdrant release
message QdrantRelease {
  // Version of the Qdrant release
  string version = 1 [(buf.validate.field).string.min_len = 1];
  // Flag to indicate if this is the default release
  // There can be at most a single item in the list that have this property set.
  bool default = 2;
  // URL to the release notes
  optional string release_notes_url = 3 [(buf.validate.field).string.uri = true];
  // Additional message regarding this release that might be useful to the client"
  optional string remarks = 4 [(buf.validate.field).string.min_len = 1];
  // True, if the release version is end of life and not supported anymore
  bool end_of_life = 5;
  // True, if the release is not available for the cluster creation or updates
  bool unavailable = 6;
}

// CreateClusterFromBackupRequest is the request for the CreateCluster function.
message CreateClusterFromBackupRequest {
  // The identifier of the account (in GUID format).
  // This is a required field.
  string account_id = 1 [(buf.validate.field).string = {uuid: true}];
  // The identifier of the backup (in GUID format).
  // This is a required field.
  string backup_id = 2 [(buf.validate.field).string = {uuid: true}];
  // Name of the new cluster
  string cluster_name = 3 [(buf.validate.field).string = {
    max_len: 64
    min_len: 4
    pattern: "^[a-zA-Z0-9-_]+$"
  }];
}

// CreateClusterFromBackupResponse is the response for the CreateCluster function.
message CreateClusterFromBackupResponse {
  // Cluster created from the backup
  Cluster cluster = 1 [(buf.validate.field).required = true];
}
