syntax = "proto3";

package qdrant.cloud.cluster.v2;

import "buf/validate/validate.proto";
import "google/api/annotations.proto";
import "google/protobuf/timestamp.proto";
import "qdrant/cloud/common/v1/common.proto";

// ClusterService is the API used to configure cluster objects.
service ClusterService {
  // Get the current API version of this service.
  // Required permissions:
  // - None (authenticated only)
  rpc GetAPIVersion(GetAPIVersionRequest) returns (GetAPIVersionResponse) {
    // permissions
    option (common.v1.permissions) = "";
    // custom account-id expression
    option (qdrant.cloud.common.v1.account_id_expression) = "";
    // gRPC Gateway REST call
    option (google.api.http) = {get: "/api/cluster/v2/api-version"};
  }

  // Fetch all clusters in the account identified by the given ID.
  // Required permissions:
  // - read:clusters
  rpc ListClusters(ListClustersRequest) returns (ListClustersResponse) {
    // permissions
    option (common.v1.permissions) = "read:clusters";
    // gRPC Gateway REST call
    option (google.api.http) = {get: "/api/cluster/v2/accounts/{account_id}/clusters"};
  }

  // Fetch a cluster in the account identified by the given IDs.
  // Required permissions:
  // - read:clusters
  rpc GetCluster(GetClusterRequest) returns (GetClusterResponse) {
    // permissions
    option (common.v1.permissions) = "read:clusters";
    // gRPC Gateway REST call
    option (google.api.http) = {get: "/api/cluster/v2/accounts/{account_id}/clusters/{cluster_id}"};
  }

  // Creates a cluster in the account identified by the given ID.
  // Required permissions:
  // - write:clusters
  rpc CreateCluster(CreateClusterRequest) returns (CreateClusterResponse) {
    // permissions
    option (common.v1.permissions) = "write:clusters";
    // custom account-id expression
    option (qdrant.cloud.common.v1.account_id_expression) = "cluster.account_id";
    // gRPC Gateway REST call
    option (google.api.http) = {
      post: "/api/cluster/v2/accounts/{cluster.account_id}/clusters"
      body: "*"
    };
  }

  // Update a cluster in the account identified by the given ID.
  // Required permissions:
  // - write:clusters
  rpc UpdateCluster(UpdateClusterRequest) returns (UpdateClusterResponse) {
    // permissions
    option (common.v1.permissions) = "write:clusters";
    // custom account-id expression
    option (qdrant.cloud.common.v1.account_id_expression) = "cluster.account_id";
    // gRPC Gateway REST call
    option (google.api.http) = {
      patch: "/api/cluster/v2/accounts/{cluster.account_id}/clusters/{cluster.id}"
      body: "*"
    };
  }

  // Deletes a cluster in the account identified by the given ID.
  // Required permissions:
  // - delete:clusters
  rpc DeleteCluster(DeleteClusterRequest) returns (DeleteClusterResponse) {
    // permissions
    option (common.v1.permissions) = "delete:clusters";
    // gRPC Gateway REST call
    option (google.api.http) = {delete: "/api/cluster/v2/accounts/{account_id}/clusters/{cluster_id}"};
  }

  // TODO: RestartCluster

  // Fetch all qdrant releases in the account identified by the given ID.
  // Optional a cluster ID can be provided, the list will return the options to update to only.
  // Required permissions:
  // - read:clusters
  rpc ListQdrantReleases(ListQdrantReleasesRequest) returns (ListQdrantReleasesResponse) {
    // permissions
    option (common.v1.permissions) = "read:clusters";
    // gRPC Gateway REST call
    option (google.api.http) = {get: "/api/cluster/v2/accounts/{account_id}/releases"};
  }
}

// GetAPIVersionRequest is the request for the GetAPIVersion function
message GetAPIVersionRequest {
  // Empty
}

// GetAPIVersionResponse is the response from the GetAPIVersion function
message GetAPIVersionResponse {
  // The actual version
  common.v1.Version version = 1;
}

// ListClustersRequest is the request for the ListClusters function
message ListClustersRequest {
  // The identifier of the account (in Guid format).
  // This is a required field.
  string account_id = 1 [(buf.validate.field).string = {uuid: true}];
  // The optional identifier for hybrid cloud (in Guid format).
  // If ommited all clusters, including the hybrid cloud ones, which belongs to the provided account are returned.
  optional string hybrid_cloud_id = 2 [(buf.validate.field).string = {uuid: true}];
  // TODO: ListOptions
}

// ListClustersResponse is the response from the ListClusters function
message ListClustersResponse {
  // The actual clusters in this list
  repeated Cluster items = 1;
  // TODO: Add an operation timestamp the ListClusters is started, to support the `since` in ListOptions
}

// GetClusterRequest is the request for the GetCluster function
message GetClusterRequest {
  // The identifier of the account (in Guid format).
  // This is a required field.
  string account_id = 1 [(buf.validate.field).string = {uuid: true}];
  // The identifier for the cluster (in Guid format).
  // This cluster should be part of the provided account.
  // This is a required field.
  string cluster_id = 2 [(buf.validate.field).string = {uuid: true}];
}

// GetClusterResponse is the response from the GetCluster function
message GetClusterResponse {
  // The actual cluster
  Cluster cluster = 1;
}

// CreateClusterRequest is the request for the CreateCluster function
message CreateClusterRequest {
  // The actual cluster
  Cluster cluster = 1;
}

// CreateClusterResponse is the response from the CreateCluster function
message CreateClusterResponse {
  // The actual cluster
  Cluster cluster = 1;
}

// UpdateClusterRequest is the request for the UpdateCluster function
message UpdateClusterRequest {
  // The actual cluster
  Cluster cluster = 1;
}

// UpdateClusterResponse is the response from the UpdateCluster function
message UpdateClusterResponse {
  // The actual cluster
  Cluster cluster = 1;
}

// DeleteClusterRequest is the request for the DeleteCluster function
message DeleteClusterRequest {
  // The identifier of the account (in Guid format).
  // This is a required field.
  string account_id = 1 [(buf.validate.field).string = {uuid: true}];
  // The identifier for the cluster (in Guid format).
  // This cluster should be part of the provided account.
  // This is a required field.
  string cluster_id = 2 [(buf.validate.field).string = {uuid: true}];
  // If set, the backups of this cluster will be deleted as well.
  optional bool delete_backups = 3;
}

// DeleteClusterResponse is the response from the DeleteCluster function
message DeleteClusterResponse {
  // Empty
}

// ListQdrantReleasesRequest is the request for the ListQdrantReleases function
message ListQdrantReleasesRequest {
  // The identifier of the account (in Guid format).
  // This is a required field.
  string account_id = 1 [(buf.validate.field).string = {uuid: true}];

  // The identifier for the cluster (in Guid format).
  // This cluster should be part of the provided account.
  // This is an optional field.
  optional string cluster_id = 2 [(buf.validate.field).string = {uuid: true}];
}

// ListQdrantReleasesResponse is the response from the ListQdrantReleases function
message ListQdrantReleasesResponse {
  // The actual Qdrant releases in this list
  repeated QdrantRelease items = 1;
}

// A Cluster represents one cluster of a Qdrant database.
message Cluster {
  // Unique identifier for the cluster (in Guid format).
  // This is a read-only field and will be available after a cluster is created.
  string id = 1 [(buf.validate.field).string = {uuid: true}];
  // Timestamp when the cluster was created.
  // This is a read-only field and will be available after a cluster is created.
  google.protobuf.Timestamp created_at = 2;
  // Identifier of the account associated with the cluster (in Guid format).
  // This is a required field.
  string account_id = 3 [(buf.validate.field).string = {uuid: true}];
  // Name of the cluster.
  // This is a required field.
  // Name can only contain letters, numbers, underscores and dashes
  string name = 4 [(buf.validate.field).string = {
    max_len: 64
    min_len: 4
    pattern: "^[a-zA-Z0-9-_]+$"
  }];

  // Timestamp when the cluster was deleted (or is started to be deleting).
  // This is a read-only field and will be set after DeleteCluster is called.
  google.protobuf.Timestamp deleted_at = 5;

  // TODO2: id, created_at, created_by, last_modified_at, last_modified_by, account_id (deferred discussion)

  // Cloud provider where the cluster is hosted.
  // This is a required field (one of the following: aws, gcp, azure, hybrid).
  // After creation, this field cannot be changed.
  string cloud_provider = 10 [(buf.validate.field).string = {
    in: [
      "aws",
      "gcp",
      "azure",
      "hybrid"
    ]
  }];
  // Cloud region where the cluster is located.
  // For hybrid this should be the hybrid cloud ID.
  // This is a required field.
  // After creation, this field cannot be changed.
  string cloud_region = 11;
  // Validation for cloud_region, which needs to have access to the value of cloud_provider as well, so this can't be a simple field validator.
  option (buf.validate.message).cel = {
    id: "cluster.cloud_region"
    message: "cloud_region must be a UUID if cloud_provider is 'hybrid'"
    expression: "this.cloud_region.matches('^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{3}-[089ab][0-9a-f]{3}-[0-9a-f]{12}$') || this.cloud_provider!= 'hybrid'"
  };

  // Current configuration details of the cluster.
  ClusterConfiguration configuration = 20;

  // Current state of the cluster.
  // All fields inside `state` are read-only.
  ClusterState state = 100;
}

// A ClusterConfiguration represents the configuration of a cluster.
message ClusterConfiguration {
  // Timestamp when the cluster configuration was last updated.
  // This is a read-only field and will be available after a cluster is created.
  google.protobuf.Timestamp last_modified_at = 1;
  // The number of nodes in a cluster.
  // This should be a number 1...20 [both included].
  uint32 number_of_nodes = 2 [(buf.validate.field).uint32 = {
    gte: 1
    lte: 20
  }];

  // Version of the cluster software.
  // If ommited the latest version will be used and filled out during create.
  // Use ListReleases() to determine which versions are allowed to be used.
  // See upgrade guidelines for more info.
  string version = 3 [(buf.validate.field).string = {pattern: "^(v(\\d+)\\.(\\d+)\\.(\\d+)|latest)$"}];

  // The package identifier used to configure the resources of the cluster. Use ListPackages() to select one.
  string package_id = 4 [(buf.validate.field).string = {uuid: true}];
  // The additional resources on top of the selected package.
  // This is an optional field, if not specified all additional resources are 0.
  optional AdditionalResources additional_resources = 5;

  // Configuration to setup a qdrant database in a hybrid cloud.
  // It is ignored for Managed Cloud clusters. This is an optional field
  optional DatabaseConfiguration database_configuration = 7;

  // The node selector for this cluster in a hybrid cloud.
  // It is ignored for Managed Cloud clusters. This is an optional field
  repeated common.v1.KeyValue node_selector = 8 [(buf.validate.field).repeated = {max_items: 10}];
  // List of tolerations for this cluster in a hybrid cloud.
  // It is ignored for Managed Cloud clusters. This is an optional field
  repeated Toleration tolerations = 9 [(buf.validate.field).repeated = {max_items: 10}];
  // List of annotations for this cluster in a hybrid cloud.
  // It is ignored for Managed Cloud clusters. This is an optional field
  repeated common.v1.KeyValue annotations = 10 [(buf.validate.field).repeated = {max_items: 10}];
  // List of allowed IP source ranges for this cluster. Field is used for both
  // hybrid cloud and Managed Cloud clusters. This is an optional field
  // TODO: Are both IPv4 and IPv6 supported? --> IPv4 only for now?
  // TODO: Do we want to create a reg-ex for validation?
  repeated string allowed_ip_source_ranges = 11 [(buf.validate.field).repeated = {
    max_items: 20
    items: {
      string: {max_len: 43}
    }
  }];

  // TODO: Ask Bastian if 80 is OK (or it should be 99/100)?
  // The percentage of CPU resources reserved for system components
  // This is an optional field, default is 0.
  // Number between 0..80
  uint32 reserved_cpu_percentage = 20 [(buf.validate.field).uint32 = {
    gte: 0
    lte: 80
  }];
  // The percentage of RAM resources reserved for system components
  // This is an optional field, default is 0.
  // Number between 0..80
  uint32 reserved_memory_percentage = 21 [(buf.validate.field).uint32 = {
    gte: 0
    lte: 80
  }];
}

// Configuration to setup a Qdrant database in a hybrid cloud.
message DatabaseConfiguration {
  // The default Qdrant database collection configuration
  // This is an optional field
  optional DatabaseConfigurationCollection collection = 1;
  // The default Qdrant database storage configuration
  // This is an optional field
  optional DatabaseConfigurationStorage storage = 2;
  // The Qdrant database service configuration
  // This is an optional field
  optional DatabaseConfigurationService service = 3;
  // The log level for the database
  // This is an optional field, default is Info
  // The allowed values are: Trace, Debug, Info, Warn, Error, Off
  // Qdrant is written in Rust and is using: https://docs.rs/log/latest/log/enum.LevelFilter.html
  optional string log_level = 4 [(buf.validate.field).string = {
    in: [
      "Trace",
      "Debug",
      "Info",
      "Warn",
      "Error"
      "Off"
    ]
  }];
  // The Qdrant database TLS configuration
  // This is an optional field, if not set an unsecure connection is provided
  optional DatabaseConfigurationTls tls = 5;
}

// The default Qdrant database collection configuration
message DatabaseConfigurationCollection {
  // Number of replicas of each shard that network tries to maintain
  // This is an optional, the default is 1
  optional uint32 replication_factor = 1;
  // How many replicas should apply the operation for us to consider it successful
  // This is an optional, the default is 1
  int32 write_consistency_factor = 2;
  // The default parameters for vectors.
  DatabaseConfigurationCollectionVectors vectors = 3;
}

// The default Qdrant database collection vectors configuration
message DatabaseConfigurationCollectionVectors {
  // If set, this will create a collection with all vectors immediately stored in memmap storage.
  // This is the recommended way, in case your Qdrant instance operates with fast disks and you are working with large collections.
  // For more info see: https://qdrant.tech/documentation/concepts/storage/#configuring-memmap-storage
  // This is an optional field, TODO:? default will be true.
  optional bool on_disk = 1;
}

// The Qdrant storage configuration
message DatabaseConfigurationStorage {
  // The performance related Qdrant database storage configuration
  DatabaseConfigurationStoragePerformance performance = 1;
}

// The performance related Qdrant database storage configuration
message DatabaseConfigurationStoragePerformance {
  // CPU budget, how many CPUs (threads) to allocate for an optimization job.
  // If 0 - auto selection, keep 1 or more CPUs unallocated depending on CPU size
  // If negative - subtract this number of CPUs from the available CPUs.
  // If positive - use this exact number of CPUs.
  int32 optimizer_cpu_budget = 1;
  // Enable async scorer which uses io_uring when rescoring.
  // Only supported on Linux, must be enabled in your kernel.
  // See: https://qdrant.tech/articles/io_uring/#and-what-about-qdrant
  bool async_scorer = 2;
}

// The Qdrant database service configuration
message DatabaseConfigurationService {
  // Set an api-key.
  // If set, all requests must include a header with the api-key.
  // example header: `api-key: <API-KEY>`
  optional common.v1.SecretKeyRef api_key = 1;
  // Set an api-key for read-only operations.
  // If set, all requests must include a header with the api-key.
  // example header: `api-key: <API-KEY>`
  optional common.v1.SecretKeyRef read_only_api_key = 2;
  // Enable JWT Role Based Access Control (RBAC).
  // If enabled, you can generate JWT tokens with fine-grained rules for access control.
  // Use generated token instead of API key.
  bool jwt_rbac = 3;
  // Enable HTTPS for the REST and gRPC API
  bool enable_tls = 4;
}

// DatabaseConfigurationTls contains the information to setup a TLS connection to the database endpoint
message DatabaseConfigurationTls {
  // Secret to use for the certificate
  common.v1.SecretKeyRef cert = 1;
  // Secret to use for the private key
  common.v1.SecretKeyRef key = 2;
}

// AdditionalResources contans the information about additional resources
message AdditionalResources {
  // Currently not supported, but will be added in the near future:
  // Additional CPU (expressed in milli vCPU)
  // int cpu = 1;
  // Additional Memory (expressed in Gib)
  // int ram = 2;

  // Additional Disk (expressed in Gib)
  uint32 disk = 3;
}

// The Toleration message represents a toleration object for Kubernetes.
message Toleration {
  // The key to match against the key of a node label.
  string key = 1 [(buf.validate.field).string = {
    // Must be 63 characters or less (excluding the prefix).
    max_len: 63
    // Must be a valid DNS label as per RFC 1123.
    pattern: "^([a-zA-Z0-9]([-a-zA-Z0-9_.]*[a-zA-Z0-9])?)?$"
  }];

  // The operator represents a key's relationship to the value.
  // Valid operators are "Exists" and "Equal".
  // The default is Exists
  optional string operator = 2 [(buf.validate.field).string = {
    in: [
      "Exists",
      "Equal"
    ]
  }];

  // The value to match against the value of a node label.
  string value = 3;

  // The effect indicates the taint effect to match.
  // Valid effects are "NoSchedule", "PreferNoSchedule", and "NoExecute".
  // The default is NoSchedule
  optional string effect = 4 [(buf.validate.field).string = {
    in: [
      "NoSchedule",
      "PreferNoSchedule",
      "NoExecute"
    ]
  }];

  // The toleration seconds indicates the duration to tolerate the taint.
  optional uint64 toleration_seconds = 5 [(buf.validate.field).uint64 = {
    gte: 0 // Ensure the value is non-negative (technically redundant for uint64)
  }];
}

// ClusterState represents the current state of a cluster
// All fields in this message are read-only.
message ClusterState {
  // Version of the cluster software
  string version = 1;
  // Number of cluster nodes that are up and running
  uint32 nodes_up = 2;
  // The date and time when the cluster was restarted
  google.protobuf.Timestamp restarted_at = 3;
  // Current phase of the cluster
  // One of the following: Creating, ...
  string phase = 4;
  // Reason for the current phase of the cluster.
  string reason = 5;
  // Endpoint information to access the qdrant cluster (aka database).
  ClusterEndpoint endpoint = 6;
  // Summary of the resources used by the cluster per node.
  ClusterNodeResourcesSummary resources = 7;
}

// Endpoint information to access the qdrant cluster (aka database).
// All fields in this message are a read-only field.
message ClusterEndpoint {
  // URL to access the qdrant cluster (aka database) without port
  string url = 1 [(buf.validate.field).string = {address: true}];
  // The port to use for HTTP REST calls (6333)
  int32 rest_port = 2;
  // The port to use for gRPC calls (6334)
  int32 grpc_port = 3;
}

// ClusterResourcesSummary represents the summary of the resources used in this cluster per node.
message ClusterNodeResourcesSummary {
  // Disk resources
  ClusterNodeResources disk = 1;
  // Memory resources
  ClusterNodeResources ram = 2;
  // CPU resouces
  ClusterNodeResources cpu = 3;
}

// ClusterNodeResources represents the allocation of various resources for a cluster per node.
message ClusterNodeResources {
  // Base resources that are part of the standard allocation for the cluster per node.
  // This includes default CPU, memory, storage, etc.
  double base = 1;
  // Complimentary resources provided to the cluster at no additional cost.
  // This might include complimentary network bandwidth, credits, etc.
  double complimentary = 2;
  // Additional resources allocated to the cluster.
  // This could include additional storage, compute power, etc.
  double additional = 3;
  // The reserved is the amount used by the system, which cannot be used by the database itself.
  double reserved = 4;
  // The available is the total (base+complimentary+additional) - reserved
  double available = 5;
}

// QdrantRelease represent a single Qdrant release
message QdrantRelease {
  // Version of the Qdrant release
  string version = 1;
  // Flag to indicate if this is the default release
  // There can be at most a single item in the list that have this property set.
  bool default = 2;
  // URL to the release notes
  optional string release_notes_url = 3;
  // Additional message regarding this release that might be useful to the client"
  optional string remarks = 4;
}
