// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        (unknown)
// source: qdrant/cloud/common/v1/common.proto

package commonv1

import (
	_ "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	descriptorpb "google.golang.org/protobuf/types/descriptorpb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// ActorType specifies the type of actor that can call a method.
type ActorType int32

const (
	// Default, unspecified actor type. Should generally not be used explicitly in options
	// unless to signify an error or uninitialized state.
	ActorType_ACTOR_TYPE_UNSPECIFIED ActorType = 0
	// Represents a human user, typically authenticated via an identity provider (Auth0).
	ActorType_ACTOR_TYPE_USER ActorType = 1
	// Represents a programmatic access key, also called management key,
	// that is not be tied to a specific user or service account identity, but rather an account.
	ActorType_ACTOR_TYPE_MANAGEMENT_KEY ActorType = 2
	// Represents a service account or machine user, often used for M2M communication.
	// This is for internal platform use only.
	ActorType_ACTOR_TYPE_SERVICE_ACCOUNT ActorType = 3
)

// Enum value maps for ActorType.
var (
	ActorType_name = map[int32]string{
		0: "ACTOR_TYPE_UNSPECIFIED",
		1: "ACTOR_TYPE_USER",
		2: "ACTOR_TYPE_MANAGEMENT_KEY",
		3: "ACTOR_TYPE_SERVICE_ACCOUNT",
	}
	ActorType_value = map[string]int32{
		"ACTOR_TYPE_UNSPECIFIED":     0,
		"ACTOR_TYPE_USER":            1,
		"ACTOR_TYPE_MANAGEMENT_KEY":  2,
		"ACTOR_TYPE_SERVICE_ACCOUNT": 3,
	}
)

func (x ActorType) Enum() *ActorType {
	p := new(ActorType)
	*p = x
	return p
}

func (x ActorType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ActorType) Descriptor() protoreflect.EnumDescriptor {
	return file_qdrant_cloud_common_v1_common_proto_enumTypes[0].Descriptor()
}

func (ActorType) Type() protoreflect.EnumType {
	return &file_qdrant_cloud_common_v1_common_proto_enumTypes[0]
}

func (x ActorType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ActorType.Descriptor instead.
func (ActorType) EnumDescriptor() ([]byte, []int) {
	return file_qdrant_cloud_common_v1_common_proto_rawDescGZIP(), []int{0}
}

// LogField represents a field to log (in case of an error).
type LogField struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The name of the field to log (in the logger).
	// It will automatically prefixed with `request.`
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The field expression to find the value of the field to log (in the request).
	// It is allowed to nest fields with a point, like 'cluster.account_id' or 'account.id'
	FieldExpression string `protobuf:"bytes,2,opt,name=field_expression,json=fieldExpression,proto3" json:"field_expression,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *LogField) Reset() {
	*x = LogField{}
	mi := &file_qdrant_cloud_common_v1_common_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LogField) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogField) ProtoMessage() {}

func (x *LogField) ProtoReflect() protoreflect.Message {
	mi := &file_qdrant_cloud_common_v1_common_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogField.ProtoReflect.Descriptor instead.
func (*LogField) Descriptor() ([]byte, []int) {
	return file_qdrant_cloud_common_v1_common_proto_rawDescGZIP(), []int{0}
}

func (x *LogField) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *LogField) GetFieldExpression() string {
	if x != nil {
		return x.FieldExpression
	}
	return ""
}

// Semantic version number.
type Version struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Major version (increasing may break APIs)
	Major uint32 `protobuf:"varint,1,opt,name=major,proto3" json:"major,omitempty"`
	// Minor version (increased for new features)
	Minor uint32 `protobuf:"varint,2,opt,name=minor,proto3" json:"minor,omitempty"`
	// Patch version (increased for fixes)
	Patch         uint32 `protobuf:"varint,3,opt,name=patch,proto3" json:"patch,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Version) Reset() {
	*x = Version{}
	mi := &file_qdrant_cloud_common_v1_common_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Version) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Version) ProtoMessage() {}

func (x *Version) ProtoReflect() protoreflect.Message {
	mi := &file_qdrant_cloud_common_v1_common_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Version.ProtoReflect.Descriptor instead.
func (*Version) Descriptor() ([]byte, []int) {
	return file_qdrant_cloud_common_v1_common_proto_rawDescGZIP(), []int{1}
}

func (x *Version) GetMajor() uint32 {
	if x != nil {
		return x.Major
	}
	return 0
}

func (x *Version) GetMinor() uint32 {
	if x != nil {
		return x.Minor
	}
	return 0
}

func (x *Version) GetPatch() uint32 {
	if x != nil {
		return x.Patch
	}
	return 0
}

// SecretKeyRef is a reference to a Kubernetes secret name and the key inside the secret
type SecretKeyRef struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The name of the secret (in the same namespace as the QdrantCluster CRD instance)
	// This is a required field
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The key inside the secret
	// This is a required field
	Key           string `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SecretKeyRef) Reset() {
	*x = SecretKeyRef{}
	mi := &file_qdrant_cloud_common_v1_common_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SecretKeyRef) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SecretKeyRef) ProtoMessage() {}

func (x *SecretKeyRef) ProtoReflect() protoreflect.Message {
	mi := &file_qdrant_cloud_common_v1_common_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SecretKeyRef.ProtoReflect.Descriptor instead.
func (*SecretKeyRef) Descriptor() ([]byte, []int) {
	return file_qdrant_cloud_common_v1_common_proto_rawDescGZIP(), []int{2}
}

func (x *SecretKeyRef) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *SecretKeyRef) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

// KeyValue is a key-value tuple (used in e.g. node selectors / annotations)
// The message represents an object for Kubernetes.
type KeyValue struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The key part of a key-value pair
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// The value part of a key-value pair
	Value         string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KeyValue) Reset() {
	*x = KeyValue{}
	mi := &file_qdrant_cloud_common_v1_common_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KeyValue) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KeyValue) ProtoMessage() {}

func (x *KeyValue) ProtoReflect() protoreflect.Message {
	mi := &file_qdrant_cloud_common_v1_common_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KeyValue.ProtoReflect.Descriptor instead.
func (*KeyValue) Descriptor() ([]byte, []int) {
	return file_qdrant_cloud_common_v1_common_proto_rawDescGZIP(), []int{3}
}

func (x *KeyValue) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *KeyValue) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

// TopologySpreadConstraint specifies how to spread matching pods among the given topology.
type TopologySpreadConstraint struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// max_skew describes the degree to which pods may be unevenly distributed.
	// When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
	// between the number of matching pods in the target topology and the global minimum.
	// For example, in a 3-zone cluster, max_skew is set to 1, and pods with the same
	// labelSelector spread as 1/1/0:
	// +-------+-------+-------+
	// | zone1 | zone2 | zone3 |
	// +-------+-------+-------+
	// |   P   |   P   |       |
	// +-------+-------+-------+
	// - if max_skew is 1, incoming pod can only be scheduled to zone3 to become 1/1/1;
	// scheduling it onto zone1(zone2) would make the ActualSkew(2-0) on zone1(zone2)
	// violate MaxSkew(1).
	// - if max_skew is 2, incoming pod can be scheduled onto any zone.
	// When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
	// to topologies that satisfy it.
	// Default value is 1 and 0 is not allowed.
	MaxSkew *int32 `protobuf:"varint,1,opt,name=max_skew,json=maxSkew,proto3,oneof" json:"max_skew,omitempty"`
	// topology_key is the key of node labels. Nodes that have a label with this key
	// and identical values are considered to be in the same topology.
	// We consider each <key, value> as a "bucket", and try to put balanced number
	// of pods into each bucket.
	// It's a required field.
	TopologyKey string `protobuf:"bytes,2,opt,name=topology_key,json=topologyKey,proto3" json:"topology_key,omitempty"`
	// when_unsatisfiable indicates how to deal with a pod if it doesn't satisfy
	// the spread constraint.
	//   - DoNotSchedule (default) tells the scheduler not to schedule it.
	//   - ScheduleAnyway tells the scheduler to schedule the pod in any location,
	//     but giving higher precedence to topologies that would help reduce the
	//     skew.
	//
	// A constraint is considered "Unsatisfiable" for an incoming pod
	// if and only if every possible node assignment for that pod would violate
	// "max_skew" on some topology.
	// For example, in a 3-zone cluster, max_skew is set to 1, and pods with the same
	// labelSelector spread as 3/1/1:
	// +-------+-------+-------+
	// | zone1 | zone2 | zone3 |
	// +-------+-------+-------+
	// | P P P |   P   |   P   |
	// +-------+-------+-------+
	// If when_unsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
	// to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
	// max_skew(1). In other words, the cluster can still be imbalanced, but scheduler
	// won't make it *more* imbalanced.
	WhenUnsatisfiable *string `protobuf:"bytes,3,opt,name=when_unsatisfiable,json=whenUnsatisfiable,proto3,oneof" json:"when_unsatisfiable,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *TopologySpreadConstraint) Reset() {
	*x = TopologySpreadConstraint{}
	mi := &file_qdrant_cloud_common_v1_common_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TopologySpreadConstraint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TopologySpreadConstraint) ProtoMessage() {}

func (x *TopologySpreadConstraint) ProtoReflect() protoreflect.Message {
	mi := &file_qdrant_cloud_common_v1_common_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TopologySpreadConstraint.ProtoReflect.Descriptor instead.
func (*TopologySpreadConstraint) Descriptor() ([]byte, []int) {
	return file_qdrant_cloud_common_v1_common_proto_rawDescGZIP(), []int{4}
}

func (x *TopologySpreadConstraint) GetMaxSkew() int32 {
	if x != nil && x.MaxSkew != nil {
		return *x.MaxSkew
	}
	return 0
}

func (x *TopologySpreadConstraint) GetTopologyKey() string {
	if x != nil {
		return x.TopologyKey
	}
	return ""
}

func (x *TopologySpreadConstraint) GetWhenUnsatisfiable() string {
	if x != nil && x.WhenUnsatisfiable != nil {
		return *x.WhenUnsatisfiable
	}
	return ""
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
// This is a gRPC-native equivalent of the Kubernetes LabelSelectorRequirement.
type LabelSelectorRequirement struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// key is the label key that the selector applies to.
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
	// values is an array of string values.
	// If the operator is In or NotIn, the values array must be non-empty.
	// If the operator is Exists or DoesNotExist, the values array must be empty.
	Values        []string `protobuf:"bytes,3,rep,name=values,proto3" json:"values,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LabelSelectorRequirement) Reset() {
	*x = LabelSelectorRequirement{}
	mi := &file_qdrant_cloud_common_v1_common_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LabelSelectorRequirement) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LabelSelectorRequirement) ProtoMessage() {}

func (x *LabelSelectorRequirement) ProtoReflect() protoreflect.Message {
	mi := &file_qdrant_cloud_common_v1_common_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LabelSelectorRequirement.ProtoReflect.Descriptor instead.
func (*LabelSelectorRequirement) Descriptor() ([]byte, []int) {
	return file_qdrant_cloud_common_v1_common_proto_rawDescGZIP(), []int{5}
}

func (x *LabelSelectorRequirement) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *LabelSelectorRequirement) GetOperator() string {
	if x != nil {
		return x.Operator
	}
	return ""
}

func (x *LabelSelectorRequirement) GetValues() []string {
	if x != nil {
		return x.Values
	}
	return nil
}

// A label selector is a label query over a set of resources. The result of match_labels and
// match_expressions are AND-ed. An empty label selector matches all objects.
// This is a gRPC-native equivalent of the Kubernetes LabelSelector.
type LabelSelector struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// match_labels is a map of {key,value} pairs.
	MatchLabels []*KeyValue `protobuf:"bytes,1,rep,name=match_labels,json=matchLabels,proto3" json:"match_labels,omitempty"`
	// match_expressions is a list of label selector requirements. The requirements are AND-ed.
	MatchExpressions []*LabelSelectorRequirement `protobuf:"bytes,2,rep,name=match_expressions,json=matchExpressions,proto3" json:"match_expressions,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *LabelSelector) Reset() {
	*x = LabelSelector{}
	mi := &file_qdrant_cloud_common_v1_common_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LabelSelector) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LabelSelector) ProtoMessage() {}

func (x *LabelSelector) ProtoReflect() protoreflect.Message {
	mi := &file_qdrant_cloud_common_v1_common_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LabelSelector.ProtoReflect.Descriptor instead.
func (*LabelSelector) Descriptor() ([]byte, []int) {
	return file_qdrant_cloud_common_v1_common_proto_rawDescGZIP(), []int{6}
}

func (x *LabelSelector) GetMatchLabels() []*KeyValue {
	if x != nil {
		return x.MatchLabels
	}
	return nil
}

func (x *LabelSelector) GetMatchExpressions() []*LabelSelectorRequirement {
	if x != nil {
		return x.MatchExpressions
	}
	return nil
}

// IPBlock describes a particular CIDR (e.g. "192.168.1.1/24") that is allowed
// to the pods.
// This is a gRPC-native equivalent of the Kubernetes IPBlock.
type IPBlock struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// CIDR is a string representing the IP Block.
	// Valid examples are "192.168.1.1/24" or "2001:db9::/64".
	Cidr string `protobuf:"bytes,1,opt,name=cidr,proto3" json:"cidr,omitempty"`
	// Except is a slice of CIDRs that should not be included within an IP Block.
	// Except values will be rejected if they are outside the CIDR range.
	Except        []string `protobuf:"bytes,2,rep,name=except,proto3" json:"except,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IPBlock) Reset() {
	*x = IPBlock{}
	mi := &file_qdrant_cloud_common_v1_common_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IPBlock) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IPBlock) ProtoMessage() {}

func (x *IPBlock) ProtoReflect() protoreflect.Message {
	mi := &file_qdrant_cloud_common_v1_common_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IPBlock.ProtoReflect.Descriptor instead.
func (*IPBlock) Descriptor() ([]byte, []int) {
	return file_qdrant_cloud_common_v1_common_proto_rawDescGZIP(), []int{7}
}

func (x *IPBlock) GetCidr() string {
	if x != nil {
		return x.Cidr
	}
	return ""
}

func (x *IPBlock) GetExcept() []string {
	if x != nil {
		return x.Except
	}
	return nil
}

// PeerSelector selects pods and/or namespaces.
type PeerSelector struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// This is a label selector which selects Pods.
	// If NamespaceSelector is also set, then the NetworkPolicyPeer as a whole selects
	// the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
	// Otherwise it selects the Pods matching PodSelector in the policy's own Namespace.
	PodSelector *LabelSelector `protobuf:"bytes,1,opt,name=pod_selector,json=podSelector,proto3,oneof" json:"pod_selector,omitempty"`
	// Selects Namespaces using cluster-scoped labels.
	// If PodSelector is also set, then the NetworkPolicyPeer as a whole selects
	// the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
	// Otherwise it selects all Pods in the Namespaces selected by NamespaceSelector.
	NamespaceSelector *LabelSelector `protobuf:"bytes,2,opt,name=namespace_selector,json=namespaceSelector,proto3,oneof" json:"namespace_selector,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *PeerSelector) Reset() {
	*x = PeerSelector{}
	mi := &file_qdrant_cloud_common_v1_common_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PeerSelector) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PeerSelector) ProtoMessage() {}

func (x *PeerSelector) ProtoReflect() protoreflect.Message {
	mi := &file_qdrant_cloud_common_v1_common_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PeerSelector.ProtoReflect.Descriptor instead.
func (*PeerSelector) Descriptor() ([]byte, []int) {
	return file_qdrant_cloud_common_v1_common_proto_rawDescGZIP(), []int{8}
}

func (x *PeerSelector) GetPodSelector() *LabelSelector {
	if x != nil {
		return x.PodSelector
	}
	return nil
}

func (x *PeerSelector) GetNamespaceSelector() *LabelSelector {
	if x != nil {
		return x.NamespaceSelector
	}
	return nil
}

// NetworkPolicyPeer describes a peer to allow traffic to/from.
// This is a gRPC-native equivalent of the Kubernetes NetworkPolicyPeer.
type NetworkPolicyPeer struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Specifies the type of peer. Only one of the following fields may be set.
	//
	// Types that are valid to be assigned to PeerType:
	//
	//	*NetworkPolicyPeer_Selector
	//	*NetworkPolicyPeer_IpBlock
	PeerType      isNetworkPolicyPeer_PeerType `protobuf_oneof:"peer_type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NetworkPolicyPeer) Reset() {
	*x = NetworkPolicyPeer{}
	mi := &file_qdrant_cloud_common_v1_common_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NetworkPolicyPeer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkPolicyPeer) ProtoMessage() {}

func (x *NetworkPolicyPeer) ProtoReflect() protoreflect.Message {
	mi := &file_qdrant_cloud_common_v1_common_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkPolicyPeer.ProtoReflect.Descriptor instead.
func (*NetworkPolicyPeer) Descriptor() ([]byte, []int) {
	return file_qdrant_cloud_common_v1_common_proto_rawDescGZIP(), []int{9}
}

func (x *NetworkPolicyPeer) GetPeerType() isNetworkPolicyPeer_PeerType {
	if x != nil {
		return x.PeerType
	}
	return nil
}

func (x *NetworkPolicyPeer) GetSelector() *PeerSelector {
	if x != nil {
		if x, ok := x.PeerType.(*NetworkPolicyPeer_Selector); ok {
			return x.Selector
		}
	}
	return nil
}

func (x *NetworkPolicyPeer) GetIpBlock() *IPBlock {
	if x != nil {
		if x, ok := x.PeerType.(*NetworkPolicyPeer_IpBlock); ok {
			return x.IpBlock
		}
	}
	return nil
}

type isNetworkPolicyPeer_PeerType interface {
	isNetworkPolicyPeer_PeerType()
}

type NetworkPolicyPeer_Selector struct {
	// Selects pods and/or namespaces.
	Selector *PeerSelector `protobuf:"bytes,1,opt,name=selector,proto3,oneof"`
}

type NetworkPolicyPeer_IpBlock struct {
	// Defines policy on a particular IPBlock.
	IpBlock *IPBlock `protobuf:"bytes,2,opt,name=ip_block,json=ipBlock,proto3,oneof"`
}

func (*NetworkPolicyPeer_Selector) isNetworkPolicyPeer_PeerType() {}

func (*NetworkPolicyPeer_IpBlock) isNetworkPolicyPeer_PeerType() {}

// NetworkPolicyPort describes a port to allow traffic on.
// This is a gRPC-native equivalent of the Kubernetes NetworkPolicyPort.
type NetworkPolicyPort struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The protocol (TCP, UDP, or SCTP) which traffic must match. If not specified, this
	// field defaults to TCP.
	Protocol *string `protobuf:"bytes,1,opt,name=protocol,proto3,oneof" json:"protocol,omitempty"`
	// The port on the given protocol. This can either be a numerical or named
	// port on a pod. If this field is not provided, this matches all port names and
	// numbers.
	//
	// Types that are valid to be assigned to PortSpec:
	//
	//	*NetworkPolicyPort_PortNumber
	//	*NetworkPolicyPort_PortName
	PortSpec isNetworkPolicyPort_PortSpec `protobuf_oneof:"port_spec"`
	// If set, indicates that the range of ports from port to end_port, inclusive,
	// should be allowed by the policy. This field cannot be defined if the port field
	// is defined as a named (string) port.
	// The end_port must be equal to or greater than port.
	EndPort       *int32 `protobuf:"varint,4,opt,name=end_port,json=endPort,proto3,oneof" json:"end_port,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NetworkPolicyPort) Reset() {
	*x = NetworkPolicyPort{}
	mi := &file_qdrant_cloud_common_v1_common_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NetworkPolicyPort) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkPolicyPort) ProtoMessage() {}

func (x *NetworkPolicyPort) ProtoReflect() protoreflect.Message {
	mi := &file_qdrant_cloud_common_v1_common_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkPolicyPort.ProtoReflect.Descriptor instead.
func (*NetworkPolicyPort) Descriptor() ([]byte, []int) {
	return file_qdrant_cloud_common_v1_common_proto_rawDescGZIP(), []int{10}
}

func (x *NetworkPolicyPort) GetProtocol() string {
	if x != nil && x.Protocol != nil {
		return *x.Protocol
	}
	return ""
}

func (x *NetworkPolicyPort) GetPortSpec() isNetworkPolicyPort_PortSpec {
	if x != nil {
		return x.PortSpec
	}
	return nil
}

func (x *NetworkPolicyPort) GetPortNumber() int32 {
	if x != nil {
		if x, ok := x.PortSpec.(*NetworkPolicyPort_PortNumber); ok {
			return x.PortNumber
		}
	}
	return 0
}

func (x *NetworkPolicyPort) GetPortName() string {
	if x != nil {
		if x, ok := x.PortSpec.(*NetworkPolicyPort_PortName); ok {
			return x.PortName
		}
	}
	return ""
}

func (x *NetworkPolicyPort) GetEndPort() int32 {
	if x != nil && x.EndPort != nil {
		return *x.EndPort
	}
	return 0
}

type isNetworkPolicyPort_PortSpec interface {
	isNetworkPolicyPort_PortSpec()
}

type NetworkPolicyPort_PortNumber struct {
	// A numerical port number.
	PortNumber int32 `protobuf:"varint,2,opt,name=port_number,json=portNumber,proto3,oneof"`
}

type NetworkPolicyPort_PortName struct {
	// A named port on a pod.
	PortName string `protobuf:"bytes,3,opt,name=port_name,json=portName,proto3,oneof"`
}

func (*NetworkPolicyPort_PortNumber) isNetworkPolicyPort_PortSpec() {}

func (*NetworkPolicyPort_PortName) isNetworkPolicyPort_PortSpec() {}

// NetworkPolicyIngressRule describes a particular set of traffic that is allowed to the pods
// matched by a NetworkPolicySpec's podSelector. The traffic must match both ports and from.
// This is a gRPC-native equivalent of the Kubernetes NetworkPolicyIngressRule.
type NetworkPolicyIngressRule struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of ports which should be made accessible on the pods selected for this
	// rule. Each item in this list is combined using a logical OR. If this field is
	// empty or missing, this rule matches all ports (traffic not restricted by port).
	// If this field is present and contains at least one item, then this rule allows
	// traffic only if the traffic matches at least one port in the list.
	Ports []*NetworkPolicyPort `protobuf:"bytes,1,rep,name=ports,proto3" json:"ports,omitempty"`
	// List of sources which should be able to access the pods selected for this rule.
	// Items in this list are combined using a logical OR operation. If this field is
	// empty or missing, this rule matches all sources (traffic not restricted by
	// source). If this field is present and contains at least one item, this rule
	// allows traffic only if the traffic matches at least one item in the from list.
	From          []*NetworkPolicyPeer `protobuf:"bytes,2,rep,name=from,proto3" json:"from,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NetworkPolicyIngressRule) Reset() {
	*x = NetworkPolicyIngressRule{}
	mi := &file_qdrant_cloud_common_v1_common_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NetworkPolicyIngressRule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkPolicyIngressRule) ProtoMessage() {}

func (x *NetworkPolicyIngressRule) ProtoReflect() protoreflect.Message {
	mi := &file_qdrant_cloud_common_v1_common_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkPolicyIngressRule.ProtoReflect.Descriptor instead.
func (*NetworkPolicyIngressRule) Descriptor() ([]byte, []int) {
	return file_qdrant_cloud_common_v1_common_proto_rawDescGZIP(), []int{11}
}

func (x *NetworkPolicyIngressRule) GetPorts() []*NetworkPolicyPort {
	if x != nil {
		return x.Ports
	}
	return nil
}

func (x *NetworkPolicyIngressRule) GetFrom() []*NetworkPolicyPeer {
	if x != nil {
		return x.From
	}
	return nil
}

// NetworkPolicyEgressRule describes a particular set of traffic that is allowed out of pods
// matched by a NetworkPolicySpec's podSelector. The traffic must match both ports and to.
// This is a gRPC-native equivalent of the Kubernetes NetworkPolicyEgressRule.
type NetworkPolicyEgressRule struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of destination ports for outgoing traffic.
	// Each item in this list is combined using a logical OR. If this field is
	// empty or missing, this rule matches all ports (traffic not restricted by port).
	// If this field is present and contains at least one item, then this rule allows
	// traffic only if the traffic matches at least one port in the list.
	Ports []*NetworkPolicyPort `protobuf:"bytes,1,rep,name=ports,proto3" json:"ports,omitempty"`
	// List of destinations for outgoing traffic of pods selected for this rule.
	// Items in this list are combined using a logical OR operation. If this field is
	// empty or missing, this rule matches all destinations (traffic not restricted by
	// destination). If this field is present and contains at least one item, this rule
	// allows traffic only if the traffic matches at least one item in the to list.
	To            []*NetworkPolicyPeer `protobuf:"bytes,2,rep,name=to,proto3" json:"to,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NetworkPolicyEgressRule) Reset() {
	*x = NetworkPolicyEgressRule{}
	mi := &file_qdrant_cloud_common_v1_common_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NetworkPolicyEgressRule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkPolicyEgressRule) ProtoMessage() {}

func (x *NetworkPolicyEgressRule) ProtoReflect() protoreflect.Message {
	mi := &file_qdrant_cloud_common_v1_common_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkPolicyEgressRule.ProtoReflect.Descriptor instead.
func (*NetworkPolicyEgressRule) Descriptor() ([]byte, []int) {
	return file_qdrant_cloud_common_v1_common_proto_rawDescGZIP(), []int{12}
}

func (x *NetworkPolicyEgressRule) GetPorts() []*NetworkPolicyPort {
	if x != nil {
		return x.Ports
	}
	return nil
}

func (x *NetworkPolicyEgressRule) GetTo() []*NetworkPolicyPeer {
	if x != nil {
		return x.To
	}
	return nil
}

var file_qdrant_cloud_common_v1_common_proto_extTypes = []protoimpl.ExtensionInfo{
	{
		ExtendedType:  (*descriptorpb.MethodOptions)(nil),
		ExtensionType: ([]string)(nil),
		Field:         50001,
		Name:          "qdrant.cloud.common.v1.permissions",
		Tag:           "bytes,50001,rep,name=permissions",
		Filename:      "qdrant/cloud/common/v1/common.proto",
	},
	{
		ExtendedType:  (*descriptorpb.MethodOptions)(nil),
		ExtensionType: (*string)(nil),
		Field:         50002,
		Name:          "qdrant.cloud.common.v1.account_id_expression",
		Tag:           "bytes,50002,opt,name=account_id_expression",
		Filename:      "qdrant/cloud/common/v1/common.proto",
	},
	{
		ExtendedType:  (*descriptorpb.MethodOptions)(nil),
		ExtensionType: (*bool)(nil),
		Field:         50003,
		Name:          "qdrant.cloud.common.v1.requires_authentication",
		Tag:           "varint,50003,opt,name=requires_authentication",
		Filename:      "qdrant/cloud/common/v1/common.proto",
	},
	{
		ExtendedType:  (*descriptorpb.MethodOptions)(nil),
		ExtensionType: ([]ActorType)(nil),
		Field:         50004,
		Name:          "qdrant.cloud.common.v1.supported_actor_types",
		Tag:           "varint,50004,rep,packed,name=supported_actor_types,enum=qdrant.cloud.common.v1.ActorType",
		Filename:      "qdrant/cloud/common/v1/common.proto",
	},
	{
		ExtendedType:  (*descriptorpb.MethodOptions)(nil),
		ExtensionType: (*bool)(nil),
		Field:         50005,
		Name:          "qdrant.cloud.common.v1.requires_all_permissions",
		Tag:           "varint,50005,opt,name=requires_all_permissions",
		Filename:      "qdrant/cloud/common/v1/common.proto",
	},
	{
		ExtendedType:  (*descriptorpb.MethodOptions)(nil),
		ExtensionType: (*int32)(nil),
		Field:         50006,
		Name:          "qdrant.cloud.common.v1.max_message_size",
		Tag:           "varint,50006,opt,name=max_message_size",
		Filename:      "qdrant/cloud/common/v1/common.proto",
	},
	{
		ExtendedType:  (*descriptorpb.MethodOptions)(nil),
		ExtensionType: ([]*LogField)(nil),
		Field:         50007,
		Name:          "qdrant.cloud.common.v1.log_fields",
		Tag:           "bytes,50007,rep,name=log_fields",
		Filename:      "qdrant/cloud/common/v1/common.proto",
	},
}

// Extension fields to descriptorpb.MethodOptions.
var (
	// A list of permissions which need to be met by the current user.
	// If `requires_all_permissions` is true (or missing): ALL of the permissions should be met (and)
	// If `requires_all_permissions` is false: ANY-OF the permissions should be met (or)
	//
	// repeated string permissions = 50001;
	E_Permissions = &file_qdrant_cloud_common_v1_common_proto_extTypes[0]
	// The expression to find the account ID field, which should be a string field.
	// It is allowed to nest fields with a point, like 'cluster.account_id' or 'account.id'
	// If the expression is set to an empty string, no account ID will be used.
	//
	// optional string account_id_expression = 50002;
	E_AccountIdExpression = &file_qdrant_cloud_common_v1_common_proto_extTypes[1]
	// Set to allow a method to be used without authentication.
	//
	// optional bool requires_authentication = 50003;
	E_RequiresAuthentication = &file_qdrant_cloud_common_v1_common_proto_extTypes[2]
	// If this option is set, only the specified actor types are allowed to call the method.
	// If empty or not set, all authenticated actor types (that pass other permission checks) are allowed.
	//
	// repeated qdrant.cloud.common.v1.ActorType supported_actor_types = 50004;
	E_SupportedActorTypes = &file_qdrant_cloud_common_v1_common_proto_extTypes[3]
	// If set to true the provided permissions are ALL (and)
	// if set to false the provided permissions are ANY-OF (or).
	//
	// optional bool requires_all_permissions = 50005;
	E_RequiresAllPermissions = &file_qdrant_cloud_common_v1_common_proto_extTypes[4]
	// The override of the default maximum message size in MB (per message).
	//
	// optional int32 max_message_size = 50006;
	E_MaxMessageSize = &file_qdrant_cloud_common_v1_common_proto_extTypes[5]
	// The fields to log.
	//
	// repeated qdrant.cloud.common.v1.LogField log_fields = 50007;
	E_LogFields = &file_qdrant_cloud_common_v1_common_proto_extTypes[6]
)

var File_qdrant_cloud_common_v1_common_proto protoreflect.FileDescriptor

const file_qdrant_cloud_common_v1_common_proto_rawDesc = "" +
	"\n" +
	"#qdrant/cloud/common/v1/common.proto\x12\x16qdrant.cloud.common.v1\x1a\x1bbuf/validate/validate.proto\x1a google/protobuf/descriptor.proto\"\x85\x01\n" +
	"\bLogField\x12-\n" +
	"\x04name\x18\x01 \x01(\tB\x19\xbaH\x16r\x14\x10\x01\x18@2\x0e^[a-z][a-z_]*$R\x04name\x12J\n" +
	"\x10field_expression\x18\x02 \x01(\tB\x1f\xbaH\x1cr\x1a2\x18^(|[a-z_]+(\\.[a-z_]+)*)$R\x0ffieldExpression\"K\n" +
	"\aVersion\x12\x14\n" +
	"\x05major\x18\x01 \x01(\rR\x05major\x12\x14\n" +
	"\x05minor\x18\x02 \x01(\rR\x05minor\x12\x14\n" +
	"\x05patch\x18\x03 \x01(\rR\x05patch\"m\n" +
	"\fSecretKeyRef\x12?\n" +
	"\x04name\x18\x01 \x01(\tB+\xbaH(r&\x10\x01\x18\xfd\x012\x1f^[a-z0-9]([-a-z0-9]*[a-z0-9])?$R\x04name\x12\x1c\n" +
	"\x03key\x18\x02 \x01(\tB\n" +
	"\xbaH\ar\x05\x10\x01\x18\x80\bR\x03key\"\xcd\x01\n" +
	"\bKeyValue\x12\xa0\x01\n" +
	"\x03key\x18\x01 \x01(\tB\x8d\x01\xbaH\x89\x01r\x86\x01\x18\xfd\x012\x80\x01^([a-z0-9A-Z]([-a-z0-9A-Z]*[a-z0-9A-Z])?(\\.[a-z0-9A-Z]([-a-z0-9A-Z]*[a-z0-9A-Z])?)*\\/)?([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]$R\x03key\x12\x1e\n" +
	"\x05value\x18\x02 \x01(\tB\b\xbaH\x05r\x03\x18\x80\bR\x05value\"\xed\x01\n" +
	"\x18TopologySpreadConstraint\x12'\n" +
	"\bmax_skew\x18\x01 \x01(\x05B\a\xbaH\x04\x1a\x02 \x00H\x00R\amaxSkew\x88\x01\x01\x12*\n" +
	"\ftopology_key\x18\x02 \x01(\tB\a\xbaH\x04r\x02\x10\x01R\vtopologyKey\x12X\n" +
	"\x12when_unsatisfiable\x18\x03 \x01(\tB$\xbaH!r\x1fR\rDoNotScheduleR\x0eScheduleAnywayH\x01R\x11whenUnsatisfiable\x88\x01\x01B\v\n" +
	"\t_max_skewB\x15\n" +
	"\x13_when_unsatisfiable\"\xa9\x04\n" +
	"\x18LabelSelectorRequirement\x12\x19\n" +
	"\x03key\x18\x01 \x01(\tB\a\xbaH\x04r\x02\x10\x01R\x03key\x12B\n" +
	"\boperator\x18\x02 \x01(\tB&\xbaH#r!R\x02InR\x05NotInR\x06ExistsR\fDoesNotExistR\boperator\x12\x16\n" +
	"\x06values\x18\x03 \x03(\tR\x06values:\x95\x03\xbaH\x91\x03\x1a\xb8\x01\n" +
	"/label_selector_requirement.values_for_in_not-in\x125values must be non-empty when operator is In or NotIn\x1aN!(this.operator == 'In' || this.operator == 'NotIn') || this.values.size() > 0\x1a\xd3\x01\n" +
	"7label_selector_requirement.values_for_exists_not-exists\x12<values must be empty when operator is Exists or DoesNotExist\x1aZ!(this.operator == 'Exists' || this.operator == 'DoesNotExist') || this.values.size() == 0\"\xc7\x01\n" +
	"\rLabelSelector\x12M\n" +
	"\fmatch_labels\x18\x01 \x03(\v2 .qdrant.cloud.common.v1.KeyValueB\b\xbaH\x05\x92\x01\x02\x10\n" +
	"R\vmatchLabels\x12g\n" +
	"\x11match_expressions\x18\x02 \x03(\v20.qdrant.cloud.common.v1.LabelSelectorRequirementB\b\xbaH\x05\x92\x01\x02\x10\n" +
	"R\x10matchExpressions\"N\n" +
	"\aIPBlock\x12\x1c\n" +
	"\x04cidr\x18\x01 \x01(\tB\b\xbaH\x05r\x03\xe8\x01\x01R\x04cidr\x12%\n" +
	"\x06except\x18\x02 \x03(\tB\r\xbaH\n" +
	"\x92\x01\a\"\x05r\x03\xe8\x01\x01R\x06except\"\xe0\x01\n" +
	"\fPeerSelector\x12M\n" +
	"\fpod_selector\x18\x01 \x01(\v2%.qdrant.cloud.common.v1.LabelSelectorH\x00R\vpodSelector\x88\x01\x01\x12Y\n" +
	"\x12namespace_selector\x18\x02 \x01(\v2%.qdrant.cloud.common.v1.LabelSelectorH\x01R\x11namespaceSelector\x88\x01\x01B\x0f\n" +
	"\r_pod_selectorB\x15\n" +
	"\x13_namespace_selector\"\xa2\x01\n" +
	"\x11NetworkPolicyPeer\x12B\n" +
	"\bselector\x18\x01 \x01(\v2$.qdrant.cloud.common.v1.PeerSelectorH\x00R\bselector\x12<\n" +
	"\bip_block\x18\x02 \x01(\v2\x1f.qdrant.cloud.common.v1.IPBlockH\x00R\aipBlockB\v\n" +
	"\tpeer_type\"\xbd\x04\n" +
	"\x11NetworkPolicyPort\x126\n" +
	"\bprotocol\x18\x01 \x01(\tB\x15\xbaH\x12r\x10R\x03TCPR\x03UDPR\x04SCTPH\x01R\bprotocol\x88\x01\x01\x12*\n" +
	"\vport_number\x18\x02 \x01(\x05B\a\xbaH\x04\x1a\x02 \x00H\x00R\n" +
	"portNumber\x12&\n" +
	"\tport_name\x18\x03 \x01(\tB\a\xbaH\x04r\x02\x10\x01H\x00R\bportName\x12'\n" +
	"\bend_port\x18\x04 \x01(\x05B\a\xbaH\x04\x1a\x02 \x00H\x02R\aendPort\x88\x01\x01:\xcb\x02\xbaH\xc7\x02\x1a\x89\x01\n" +
	"+network_policy_port.end_port_with_port_name\x12-end_port cannot be set when port_name is used\x1a+!has(this.port_name) || !has(this.end_port)\x1a\xb8\x01\n" +
	"+network_policy_port.end_port_ge_port_number\x125end_port must be greater than or equal to port_number\x1aR!has(this.end_port) || !has(this.port_number) || this.end_port >= this.port_numberB\v\n" +
	"\tport_specB\v\n" +
	"\t_protocolB\v\n" +
	"\t_end_port\"\x9a\x01\n" +
	"\x18NetworkPolicyIngressRule\x12?\n" +
	"\x05ports\x18\x01 \x03(\v2).qdrant.cloud.common.v1.NetworkPolicyPortR\x05ports\x12=\n" +
	"\x04from\x18\x02 \x03(\v2).qdrant.cloud.common.v1.NetworkPolicyPeerR\x04from\"\x95\x01\n" +
	"\x17NetworkPolicyEgressRule\x12?\n" +
	"\x05ports\x18\x01 \x03(\v2).qdrant.cloud.common.v1.NetworkPolicyPortR\x05ports\x129\n" +
	"\x02to\x18\x02 \x03(\v2).qdrant.cloud.common.v1.NetworkPolicyPeerR\x02to*{\n" +
	"\tActorType\x12\x1a\n" +
	"\x16ACTOR_TYPE_UNSPECIFIED\x10\x00\x12\x13\n" +
	"\x0fACTOR_TYPE_USER\x10\x01\x12\x1d\n" +
	"\x19ACTOR_TYPE_MANAGEMENT_KEY\x10\x02\x12\x1e\n" +
	"\x1aACTOR_TYPE_SERVICE_ACCOUNT\x10\x03:P\n" +
	"\vpermissions\x12\x1e.google.protobuf.MethodOptions\x18ц\x03 \x03(\tB\f\xbaH\t\x92\x01\x06\"\x04r\x02\x10\x01R\vpermissions:u\n" +
	"\x15account_id_expression\x12\x1e.google.protobuf.MethodOptions\x18҆\x03 \x01(\tB\x1f\xbaH\x1cr\x1a2\x18^(|[a-z_]+(\\.[a-z_]+)*)$R\x13accountIdExpression:Y\n" +
	"\x17requires_authentication\x12\x1e.google.protobuf.MethodOptions\x18ӆ\x03 \x01(\bR\x16requiresAuthentication:\x8a\x01\n" +
	"\x15supported_actor_types\x12\x1e.google.protobuf.MethodOptions\x18Ԇ\x03 \x03(\x0e2!.qdrant.cloud.common.v1.ActorTypeB\x11\xbaH\f\x92\x01\t\"\a\x82\x01\x04\x10\x01 \x00\x10\x01R\x13supportedActorTypes:Z\n" +
	"\x18requires_all_permissions\x12\x1e.google.protobuf.MethodOptions\x18Ն\x03 \x01(\bR\x16requiresAllPermissions:V\n" +
	"\x10max_message_size\x12\x1e.google.protobuf.MethodOptions\x18ֆ\x03 \x01(\x05B\n" +
	"\xbaH\a\x1a\x05\x18\x80\b(\x01R\x0emaxMessageSize:a\n" +
	"\n" +
	"log_fields\x12\x1e.google.protobuf.MethodOptions\x18׆\x03 \x03(\v2 .qdrant.cloud.common.v1.LogFieldR\tlogFieldsB\xf6\x01\n" +
	"\x1acom.qdrant.cloud.common.v1B\vCommonProtoP\x01ZPgithub.com/qdrant/qdrant-cloud-public-api/gen/go/qdrant/cloud/common/v1;commonv1\xa2\x02\x03QCC\xaa\x02\x16Qdrant.Cloud.Common.V1\xca\x02\x16Qdrant\\Cloud\\Common\\V1\xe2\x02\"Qdrant\\Cloud\\Common\\V1\\GPBMetadata\xea\x02\x19Qdrant::Cloud::Common::V1b\x06proto3"

var (
	file_qdrant_cloud_common_v1_common_proto_rawDescOnce sync.Once
	file_qdrant_cloud_common_v1_common_proto_rawDescData []byte
)

func file_qdrant_cloud_common_v1_common_proto_rawDescGZIP() []byte {
	file_qdrant_cloud_common_v1_common_proto_rawDescOnce.Do(func() {
		file_qdrant_cloud_common_v1_common_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_qdrant_cloud_common_v1_common_proto_rawDesc), len(file_qdrant_cloud_common_v1_common_proto_rawDesc)))
	})
	return file_qdrant_cloud_common_v1_common_proto_rawDescData
}

var file_qdrant_cloud_common_v1_common_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_qdrant_cloud_common_v1_common_proto_msgTypes = make([]protoimpl.MessageInfo, 13)
var file_qdrant_cloud_common_v1_common_proto_goTypes = []any{
	(ActorType)(0),                     // 0: qdrant.cloud.common.v1.ActorType
	(*LogField)(nil),                   // 1: qdrant.cloud.common.v1.LogField
	(*Version)(nil),                    // 2: qdrant.cloud.common.v1.Version
	(*SecretKeyRef)(nil),               // 3: qdrant.cloud.common.v1.SecretKeyRef
	(*KeyValue)(nil),                   // 4: qdrant.cloud.common.v1.KeyValue
	(*TopologySpreadConstraint)(nil),   // 5: qdrant.cloud.common.v1.TopologySpreadConstraint
	(*LabelSelectorRequirement)(nil),   // 6: qdrant.cloud.common.v1.LabelSelectorRequirement
	(*LabelSelector)(nil),              // 7: qdrant.cloud.common.v1.LabelSelector
	(*IPBlock)(nil),                    // 8: qdrant.cloud.common.v1.IPBlock
	(*PeerSelector)(nil),               // 9: qdrant.cloud.common.v1.PeerSelector
	(*NetworkPolicyPeer)(nil),          // 10: qdrant.cloud.common.v1.NetworkPolicyPeer
	(*NetworkPolicyPort)(nil),          // 11: qdrant.cloud.common.v1.NetworkPolicyPort
	(*NetworkPolicyIngressRule)(nil),   // 12: qdrant.cloud.common.v1.NetworkPolicyIngressRule
	(*NetworkPolicyEgressRule)(nil),    // 13: qdrant.cloud.common.v1.NetworkPolicyEgressRule
	(*descriptorpb.MethodOptions)(nil), // 14: google.protobuf.MethodOptions
}
var file_qdrant_cloud_common_v1_common_proto_depIdxs = []int32{
	4,  // 0: qdrant.cloud.common.v1.LabelSelector.match_labels:type_name -> qdrant.cloud.common.v1.KeyValue
	6,  // 1: qdrant.cloud.common.v1.LabelSelector.match_expressions:type_name -> qdrant.cloud.common.v1.LabelSelectorRequirement
	7,  // 2: qdrant.cloud.common.v1.PeerSelector.pod_selector:type_name -> qdrant.cloud.common.v1.LabelSelector
	7,  // 3: qdrant.cloud.common.v1.PeerSelector.namespace_selector:type_name -> qdrant.cloud.common.v1.LabelSelector
	9,  // 4: qdrant.cloud.common.v1.NetworkPolicyPeer.selector:type_name -> qdrant.cloud.common.v1.PeerSelector
	8,  // 5: qdrant.cloud.common.v1.NetworkPolicyPeer.ip_block:type_name -> qdrant.cloud.common.v1.IPBlock
	11, // 6: qdrant.cloud.common.v1.NetworkPolicyIngressRule.ports:type_name -> qdrant.cloud.common.v1.NetworkPolicyPort
	10, // 7: qdrant.cloud.common.v1.NetworkPolicyIngressRule.from:type_name -> qdrant.cloud.common.v1.NetworkPolicyPeer
	11, // 8: qdrant.cloud.common.v1.NetworkPolicyEgressRule.ports:type_name -> qdrant.cloud.common.v1.NetworkPolicyPort
	10, // 9: qdrant.cloud.common.v1.NetworkPolicyEgressRule.to:type_name -> qdrant.cloud.common.v1.NetworkPolicyPeer
	14, // 10: qdrant.cloud.common.v1.permissions:extendee -> google.protobuf.MethodOptions
	14, // 11: qdrant.cloud.common.v1.account_id_expression:extendee -> google.protobuf.MethodOptions
	14, // 12: qdrant.cloud.common.v1.requires_authentication:extendee -> google.protobuf.MethodOptions
	14, // 13: qdrant.cloud.common.v1.supported_actor_types:extendee -> google.protobuf.MethodOptions
	14, // 14: qdrant.cloud.common.v1.requires_all_permissions:extendee -> google.protobuf.MethodOptions
	14, // 15: qdrant.cloud.common.v1.max_message_size:extendee -> google.protobuf.MethodOptions
	14, // 16: qdrant.cloud.common.v1.log_fields:extendee -> google.protobuf.MethodOptions
	0,  // 17: qdrant.cloud.common.v1.supported_actor_types:type_name -> qdrant.cloud.common.v1.ActorType
	1,  // 18: qdrant.cloud.common.v1.log_fields:type_name -> qdrant.cloud.common.v1.LogField
	19, // [19:19] is the sub-list for method output_type
	19, // [19:19] is the sub-list for method input_type
	17, // [17:19] is the sub-list for extension type_name
	10, // [10:17] is the sub-list for extension extendee
	0,  // [0:10] is the sub-list for field type_name
}

func init() { file_qdrant_cloud_common_v1_common_proto_init() }
func file_qdrant_cloud_common_v1_common_proto_init() {
	if File_qdrant_cloud_common_v1_common_proto != nil {
		return
	}
	file_qdrant_cloud_common_v1_common_proto_msgTypes[4].OneofWrappers = []any{}
	file_qdrant_cloud_common_v1_common_proto_msgTypes[8].OneofWrappers = []any{}
	file_qdrant_cloud_common_v1_common_proto_msgTypes[9].OneofWrappers = []any{
		(*NetworkPolicyPeer_Selector)(nil),
		(*NetworkPolicyPeer_IpBlock)(nil),
	}
	file_qdrant_cloud_common_v1_common_proto_msgTypes[10].OneofWrappers = []any{
		(*NetworkPolicyPort_PortNumber)(nil),
		(*NetworkPolicyPort_PortName)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_qdrant_cloud_common_v1_common_proto_rawDesc), len(file_qdrant_cloud_common_v1_common_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   13,
			NumExtensions: 7,
			NumServices:   0,
		},
		GoTypes:           file_qdrant_cloud_common_v1_common_proto_goTypes,
		DependencyIndexes: file_qdrant_cloud_common_v1_common_proto_depIdxs,
		EnumInfos:         file_qdrant_cloud_common_v1_common_proto_enumTypes,
		MessageInfos:      file_qdrant_cloud_common_v1_common_proto_msgTypes,
		ExtensionInfos:    file_qdrant_cloud_common_v1_common_proto_extTypes,
	}.Build()
	File_qdrant_cloud_common_v1_common_proto = out.File
	file_qdrant_cloud_common_v1_common_proto_goTypes = nil
	file_qdrant_cloud_common_v1_common_proto_depIdxs = nil
}
