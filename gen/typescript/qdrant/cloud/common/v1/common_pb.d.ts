// @generated by protoc-gen-es v2.10.1 with parameter "target=js+dts,import_extension=js,valid_types=protovalidate_required"
// @generated from file qdrant/cloud/common/v1/common.proto (package qdrant.cloud.common.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenExtension, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { MethodOptions, ServiceOptions } from "@bufbuild/protobuf/wkt";

/**
 * Describes the file qdrant/cloud/common/v1/common.proto.
 */
export declare const file_qdrant_cloud_common_v1_common: GenFile;

/**
 * LogField represents a field to log (in case of an error).
 *
 * @generated from message qdrant.cloud.common.v1.LogField
 */
export declare type LogField = Message<"qdrant.cloud.common.v1.LogField"> & {
  /**
   * The name of the field to log (in the logger).
   * It will automatically prefixed with `request.`
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The field expression to find the value of the field to log (in the request).
   * It is allowed to nest fields with a point, like 'cluster.account_id' or 'account.id'
   *
   * @generated from field: string field_expression = 2;
   */
  fieldExpression: string;
};

export declare type LogFieldValid = LogField;

/**
 * Describes the message qdrant.cloud.common.v1.LogField.
 * Use `create(LogFieldSchema)` to create a new message.
 */
export declare const LogFieldSchema: GenMessage<LogField, {validType: LogFieldValid}>;

/**
 * Semantic version number.
 *
 * @generated from message qdrant.cloud.common.v1.Version
 */
export declare type Version = Message<"qdrant.cloud.common.v1.Version"> & {
  /**
   * Major version (increasing may break APIs)
   *
   * @generated from field: uint32 major = 1;
   */
  major: number;

  /**
   * Minor version (increased for new features)
   *
   * @generated from field: uint32 minor = 2;
   */
  minor: number;

  /**
   * Patch version (increased for fixes)
   *
   * @generated from field: uint32 patch = 3;
   */
  patch: number;
};

export declare type VersionValid = Version;

/**
 * Describes the message qdrant.cloud.common.v1.Version.
 * Use `create(VersionSchema)` to create a new message.
 */
export declare const VersionSchema: GenMessage<Version, {validType: VersionValid}>;

/**
 * SecretKeyRef is a reference to a Kubernetes secret name and the key inside the secret
 *
 * @generated from message qdrant.cloud.common.v1.SecretKeyRef
 */
export declare type SecretKeyRef = Message<"qdrant.cloud.common.v1.SecretKeyRef"> & {
  /**
   * The name of the secret (in the same namespace as the QdrantCluster CRD instance)
   * This is a required field
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The key inside the secret
   * This is a required field
   *
   * @generated from field: string key = 2;
   */
  key: string;
};

export declare type SecretKeyRefValid = SecretKeyRef;

/**
 * Describes the message qdrant.cloud.common.v1.SecretKeyRef.
 * Use `create(SecretKeyRefSchema)` to create a new message.
 */
export declare const SecretKeyRefSchema: GenMessage<SecretKeyRef, {validType: SecretKeyRefValid}>;

/**
 * KeyValue is a key-value tuple (used in e.g. node selectors / annotations)
 * The message represents an object for Kubernetes.
 *
 * @generated from message qdrant.cloud.common.v1.KeyValue
 */
export declare type KeyValue = Message<"qdrant.cloud.common.v1.KeyValue"> & {
  /**
   * The key part of a key-value pair
   *
   * @generated from field: string key = 1;
   */
  key: string;

  /**
   * The value part of a key-value pair
   *
   * @generated from field: string value = 2;
   */
  value: string;
};

export declare type KeyValueValid = KeyValue;

/**
 * Describes the message qdrant.cloud.common.v1.KeyValue.
 * Use `create(KeyValueSchema)` to create a new message.
 */
export declare const KeyValueSchema: GenMessage<KeyValue, {validType: KeyValueValid}>;

/**
 * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
 *
 * @generated from message qdrant.cloud.common.v1.TopologySpreadConstraint
 */
export declare type TopologySpreadConstraint = Message<"qdrant.cloud.common.v1.TopologySpreadConstraint"> & {
  /**
   * max_skew describes the degree to which pods may be unevenly distributed.
   * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
   * between the number of matching pods in the target topology and the global minimum.
   * For example, in a 3-zone cluster, max_skew is set to 1, and pods with the same
   * labelSelector spread as 1/1/0:
   * +-------+-------+-------+
   * | zone1 | zone2 | zone3 |
   * +-------+-------+-------+
   * |   P   |   P   |       |
   * +-------+-------+-------+
   * - if max_skew is 1, incoming pod can only be scheduled to zone3 to become 1/1/1;
   * scheduling it onto zone1(zone2) would make the ActualSkew(2-0) on zone1(zone2)
   * violate MaxSkew(1).
   * - if max_skew is 2, incoming pod can be scheduled onto any zone.
   * When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
   * to topologies that satisfy it.
   * Default value is 1 and 0 is not allowed.
   *
   * @generated from field: optional int32 max_skew = 1;
   */
  maxSkew?: number;

  /**
   * topology_key is the key of node labels. Nodes that have a label with this key
   * and identical values are considered to be in the same topology.
   * We consider each <key, value> as a "bucket", and try to put balanced number
   * of pods into each bucket.
   * It's a required field.
   *
   * @generated from field: string topology_key = 2;
   */
  topologyKey: string;

  /**
   * when_unsatisfiable indicates how to deal with a pod if it doesn't satisfy
   * the spread constraint.
   * - DoNotSchedule (default) tells the scheduler not to schedule it.
   * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
   *   but giving higher precedence to topologies that would help reduce the
   *   skew.
   * A constraint is considered "Unsatisfiable" for an incoming pod
   * if and only if every possible node assignment for that pod would violate
   * "max_skew" on some topology.
   * For example, in a 3-zone cluster, max_skew is set to 1, and pods with the same
   * labelSelector spread as 3/1/1:
   * +-------+-------+-------+
   * | zone1 | zone2 | zone3 |
   * +-------+-------+-------+
   * | P P P |   P   |   P   |
   * +-------+-------+-------+
   * If when_unsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
   * to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
   * max_skew(1). In other words, the cluster can still be imbalanced, but scheduler
   * won't make it *more* imbalanced.
   *
   * @generated from field: optional qdrant.cloud.common.v1.TopologySpreadConstraintWhenUnsatisfiable when_unsatisfiable = 3;
   */
  whenUnsatisfiable?: TopologySpreadConstraintWhenUnsatisfiable;
};

export declare type TopologySpreadConstraintValid = TopologySpreadConstraint;

/**
 * Describes the message qdrant.cloud.common.v1.TopologySpreadConstraint.
 * Use `create(TopologySpreadConstraintSchema)` to create a new message.
 */
export declare const TopologySpreadConstraintSchema: GenMessage<TopologySpreadConstraint, {validType: TopologySpreadConstraintValid}>;

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 * This is a gRPC-native equivalent of the Kubernetes LabelSelectorRequirement.
 *
 * @generated from message qdrant.cloud.common.v1.LabelSelectorRequirement
 */
export declare type LabelSelectorRequirement = Message<"qdrant.cloud.common.v1.LabelSelectorRequirement"> & {
  /**
   * key is the label key that the selector applies to.
   *
   * @generated from field: string key = 1;
   */
  key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @generated from field: string operator = 2;
   */
  operator: string;

  /**
   * values is an array of string values.
   * If the operator is In or NotIn, the values array must be non-empty.
   * If the operator is Exists or DoesNotExist, the values array must be empty.
   *
   * @generated from field: repeated string values = 3;
   */
  values: string[];
};

export declare type LabelSelectorRequirementValid = LabelSelectorRequirement;

/**
 * Describes the message qdrant.cloud.common.v1.LabelSelectorRequirement.
 * Use `create(LabelSelectorRequirementSchema)` to create a new message.
 */
export declare const LabelSelectorRequirementSchema: GenMessage<LabelSelectorRequirement, {validType: LabelSelectorRequirementValid}>;

/**
 * A label selector is a label query over a set of resources. The result of match_labels and
 * match_expressions are AND-ed. An empty label selector matches all objects.
 * This is a gRPC-native equivalent of the Kubernetes LabelSelector.
 *
 * @generated from message qdrant.cloud.common.v1.LabelSelector
 */
export declare type LabelSelector = Message<"qdrant.cloud.common.v1.LabelSelector"> & {
  /**
   * match_labels is a map of {key,value} pairs.
   * match_labels is a list of KeyValue objects.
   *
   * @generated from field: repeated qdrant.cloud.common.v1.KeyValue match_labels = 1;
   */
  matchLabels: KeyValue[];

  /**
   * match_expressions is a list of label selector requirements. The requirements are AND-ed.
   *
   * @generated from field: repeated qdrant.cloud.common.v1.LabelSelectorRequirement match_expressions = 2;
   */
  matchExpressions: LabelSelectorRequirement[];
};

export declare type LabelSelectorValid = LabelSelector;

/**
 * Describes the message qdrant.cloud.common.v1.LabelSelector.
 * Use `create(LabelSelectorSchema)` to create a new message.
 */
export declare const LabelSelectorSchema: GenMessage<LabelSelector, {validType: LabelSelectorValid}>;

/**
 * IPBlock describes a particular CIDR (e.g. "192.168.1.1/24") that is allowed
 * to the pods.
 * This is a gRPC-native equivalent of the Kubernetes IPBlock.
 *
 * @generated from message qdrant.cloud.common.v1.IPBlock
 */
export declare type IPBlock = Message<"qdrant.cloud.common.v1.IPBlock"> & {
  /**
   * CIDR is a string representing the IP Block.
   * Valid examples are "192.168.1.1/24" or "2001:db9::/64".
   *
   * @generated from field: string cidr = 1;
   */
  cidr: string;

  /**
   * Except is a slice of CIDRs that should not be included within an IP Block.
   * Except values will be rejected if they are outside the CIDR range.
   *
   * @generated from field: repeated string except = 2;
   */
  except: string[];
};

export declare type IPBlockValid = IPBlock;

/**
 * Describes the message qdrant.cloud.common.v1.IPBlock.
 * Use `create(IPBlockSchema)` to create a new message.
 */
export declare const IPBlockSchema: GenMessage<IPBlock, {validType: IPBlockValid}>;

/**
 * PeerSelector selects pods and/or namespaces.
 *
 * @generated from message qdrant.cloud.common.v1.PeerSelector
 */
export declare type PeerSelector = Message<"qdrant.cloud.common.v1.PeerSelector"> & {
  /**
   * This is a label selector which selects Pods.
   * If NamespaceSelector is also set, then the NetworkPolicyPeer as a whole selects
   * the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
   * Otherwise it selects the Pods matching PodSelector in the policy's own Namespace.
   *
   * @generated from field: optional qdrant.cloud.common.v1.LabelSelector pod_selector = 1;
   */
  podSelector?: LabelSelector;

  /**
   * Selects Namespaces using cluster-scoped labels.
   * If PodSelector is also set, then the NetworkPolicyPeer as a whole selects
   * the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
   * Otherwise it selects all Pods in the Namespaces selected by NamespaceSelector.
   *
   * @generated from field: optional qdrant.cloud.common.v1.LabelSelector namespace_selector = 2;
   */
  namespaceSelector?: LabelSelector;
};

export declare type PeerSelectorValid = PeerSelector;

/**
 * Describes the message qdrant.cloud.common.v1.PeerSelector.
 * Use `create(PeerSelectorSchema)` to create a new message.
 */
export declare const PeerSelectorSchema: GenMessage<PeerSelector, {validType: PeerSelectorValid}>;

/**
 * NetworkPolicyPeer describes a peer to allow traffic to/from.
 * This is a gRPC-native equivalent of the Kubernetes NetworkPolicyPeer.
 *
 * @generated from message qdrant.cloud.common.v1.NetworkPolicyPeer
 */
export declare type NetworkPolicyPeer = Message<"qdrant.cloud.common.v1.NetworkPolicyPeer"> & {
  /**
   * Specifies the type of peer. Only one of the following fields may be set.
   *
   * @generated from oneof qdrant.cloud.common.v1.NetworkPolicyPeer.peer_type
   */
  peerType: {
    /**
     * Selects pods and/or namespaces.
     *
     * @generated from field: qdrant.cloud.common.v1.PeerSelector selector = 1;
     */
    value: PeerSelector;
    case: "selector";
  } | {
    /**
     * Defines policy on a particular IPBlock.
     *
     * @generated from field: qdrant.cloud.common.v1.IPBlock ip_block = 2;
     */
    value: IPBlock;
    case: "ipBlock";
  } | { case: undefined; value?: undefined };
};

export declare type NetworkPolicyPeerValid = NetworkPolicyPeer;

/**
 * Describes the message qdrant.cloud.common.v1.NetworkPolicyPeer.
 * Use `create(NetworkPolicyPeerSchema)` to create a new message.
 */
export declare const NetworkPolicyPeerSchema: GenMessage<NetworkPolicyPeer, {validType: NetworkPolicyPeerValid}>;

/**
 * NetworkPolicyPort describes a port to allow traffic on.
 * This is a gRPC-native equivalent of the Kubernetes NetworkPolicyPort.
 *
 * @generated from message qdrant.cloud.common.v1.NetworkPolicyPort
 */
export declare type NetworkPolicyPort = Message<"qdrant.cloud.common.v1.NetworkPolicyPort"> & {
  /**
   * The protocol (TCP, UDP, or SCTP) which traffic must match. If not specified, this
   * field defaults to TCP.
   *
   * @generated from field: optional string protocol = 1;
   */
  protocol?: string;

  /**
   * The port on the given protocol. This can either be a numerical or named
   * port on a pod. If this field is not provided, this matches all port names and
   * numbers.
   *
   * @generated from oneof qdrant.cloud.common.v1.NetworkPolicyPort.port_spec
   */
  portSpec: {
    /**
     * A numerical port number.
     *
     * @generated from field: int32 port_number = 2;
     */
    value: number;
    case: "portNumber";
  } | {
    /**
     * A named port on a pod.
     *
     * @generated from field: string port_name = 3;
     */
    value: string;
    case: "portName";
  } | { case: undefined; value?: undefined };

  /**
   * If set, indicates that the range of ports from port to end_port, inclusive,
   * should be allowed by the policy. This field cannot be defined if the port field
   * is defined as a named (string) port.
   * The end_port must be equal to or greater than port.
   *
   * @generated from field: optional int32 end_port = 4;
   */
  endPort?: number;
};

export declare type NetworkPolicyPortValid = NetworkPolicyPort;

/**
 * Describes the message qdrant.cloud.common.v1.NetworkPolicyPort.
 * Use `create(NetworkPolicyPortSchema)` to create a new message.
 */
export declare const NetworkPolicyPortSchema: GenMessage<NetworkPolicyPort, {validType: NetworkPolicyPortValid}>;

/**
 * NetworkPolicyIngressRule describes a particular set of traffic that is allowed to the pods
 * matched by a NetworkPolicySpec's podSelector. The traffic must match both ports and from.
 * This is a gRPC-native equivalent of the Kubernetes NetworkPolicyIngressRule.
 *
 * @generated from message qdrant.cloud.common.v1.NetworkPolicyIngressRule
 */
export declare type NetworkPolicyIngressRule = Message<"qdrant.cloud.common.v1.NetworkPolicyIngressRule"> & {
  /**
   * List of ports which should be made accessible on the pods selected for this
   * rule. Each item in this list is combined using a logical OR. If this field is
   * empty or missing, this rule matches all ports (traffic not restricted by port).
   * If this field is present and contains at least one item, then this rule allows
   * traffic only if the traffic matches at least one port in the list.
   *
   * @generated from field: repeated qdrant.cloud.common.v1.NetworkPolicyPort ports = 1;
   */
  ports: NetworkPolicyPort[];

  /**
   * List of sources which should be able to access the pods selected for this rule.
   * Items in this list are combined using a logical OR operation. If this field is
   * empty or missing, this rule matches all sources (traffic not restricted by
   * source). If this field is present and contains at least one item, this rule
   * allows traffic only if the traffic matches at least one item in the from list.
   *
   * @generated from field: repeated qdrant.cloud.common.v1.NetworkPolicyPeer from = 2;
   */
  from: NetworkPolicyPeer[];
};

export declare type NetworkPolicyIngressRuleValid = NetworkPolicyIngressRule;

/**
 * Describes the message qdrant.cloud.common.v1.NetworkPolicyIngressRule.
 * Use `create(NetworkPolicyIngressRuleSchema)` to create a new message.
 */
export declare const NetworkPolicyIngressRuleSchema: GenMessage<NetworkPolicyIngressRule, {validType: NetworkPolicyIngressRuleValid}>;

/**
 * NetworkPolicyEgressRule describes a particular set of traffic that is allowed out of pods
 * matched by a NetworkPolicySpec's podSelector. The traffic must match both ports and to.
 * This is a gRPC-native equivalent of the Kubernetes NetworkPolicyEgressRule.
 *
 * @generated from message qdrant.cloud.common.v1.NetworkPolicyEgressRule
 */
export declare type NetworkPolicyEgressRule = Message<"qdrant.cloud.common.v1.NetworkPolicyEgressRule"> & {
  /**
   * List of destination ports for outgoing traffic.
   * Each item in this list is combined using a logical OR. If this field is
   * empty or missing, this rule matches all ports (traffic not restricted by port).
   * If this field is present and contains at least one item, then this rule allows
   * traffic only if the traffic matches at least one port in the list.
   *
   * @generated from field: repeated qdrant.cloud.common.v1.NetworkPolicyPort ports = 1;
   */
  ports: NetworkPolicyPort[];

  /**
   * List of destinations for outgoing traffic of pods selected for this rule.
   * Items in this list are combined using a logical OR operation. If this field is
   * empty or missing, this rule matches all destinations (traffic not restricted by
   * destination). If this field is present and contains at least one item, this rule
   * allows traffic only if the traffic matches at least one item in the to list.
   *
   * @generated from field: repeated qdrant.cloud.common.v1.NetworkPolicyPeer to = 2;
   */
  to: NetworkPolicyPeer[];
};

export declare type NetworkPolicyEgressRuleValid = NetworkPolicyEgressRule;

/**
 * Describes the message qdrant.cloud.common.v1.NetworkPolicyEgressRule.
 * Use `create(NetworkPolicyEgressRuleSchema)` to create a new message.
 */
export declare const NetworkPolicyEgressRuleSchema: GenMessage<NetworkPolicyEgressRule, {validType: NetworkPolicyEgressRuleValid}>;

/**
 * ActorType specifies the type of actor that can call a method.
 *
 * @generated from enum qdrant.cloud.common.v1.ActorType
 */
export enum ActorType {
  /**
   * Default, unspecified actor type. Should generally not be used explicitly in options
   * unless to signify an error or uninitialized state.
   *
   * @generated from enum value: ACTOR_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Represents a human user, typically authenticated via an identity provider (Auth0).
   *
   * @generated from enum value: ACTOR_TYPE_USER = 1;
   */
  USER = 1,

  /**
   * Represents a programmatic access key, also called management key,
   * that is not be tied to a specific user or service account identity, but rather an account.
   *
   * @generated from enum value: ACTOR_TYPE_MANAGEMENT_KEY = 2;
   */
  MANAGEMENT_KEY = 2,

  /**
   * Represents a service account or machine user, often used for M2M communication.
   * This is for internal platform use only.
   *
   * @generated from enum value: ACTOR_TYPE_SERVICE_ACCOUNT = 3;
   */
  SERVICE_ACCOUNT = 3,
}

/**
 * Describes the enum qdrant.cloud.common.v1.ActorType.
 */
export declare const ActorTypeSchema: GenEnum<ActorType>;

/**
 * StorageTierType defines type of storage performance tiers which maps to predefined IOPS and Throughput amount
 *
 * @generated from enum qdrant.cloud.common.v1.StorageTierType
 */
export enum StorageTierType {
  /**
   * No storage tier type is configured, same as COST_OPTIMIZED
   *
   * @generated from enum value: STORAGE_TIER_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Base pre-configured type
   *
   * @generated from enum value: STORAGE_TIER_TYPE_COST_OPTIMISED = 1;
   */
  COST_OPTIMISED = 1,

  /**
   * Mid tier pre-configured type
   *
   * @generated from enum value: STORAGE_TIER_TYPE_BALANCED = 2;
   */
  BALANCED = 2,

  /**
   * Most performant pre-configured type
   *
   * @generated from enum value: STORAGE_TIER_TYPE_PERFORMANCE = 3;
   */
  PERFORMANCE = 3,
}

/**
 * Describes the enum qdrant.cloud.common.v1.StorageTierType.
 */
export declare const StorageTierTypeSchema: GenEnum<StorageTierType>;

/**
 * TopologySpreadConstraintWhenUnsatisfiable defines the valid whenUnsatisfiable for TopologySpreadConstraints.
 * See: https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/
 *
 * @generated from enum qdrant.cloud.common.v1.TopologySpreadConstraintWhenUnsatisfiable
 */
export enum TopologySpreadConstraintWhenUnsatisfiable {
  /**
   * Unspecified.
   *
   * @generated from enum value: TOPOLOGY_SPREAD_CONSTRAINT_WHEN_UNSATISFIABLE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * DoNotSchedule (default) tells the scheduler not to schedule it.
   *
   * @generated from enum value: TOPOLOGY_SPREAD_CONSTRAINT_WHEN_UNSATISFIABLE_DO_NOT_SCHEDULE = 1;
   */
  DO_NOT_SCHEDULE = 1,

  /**
   * ScheduleAnyway tells the scheduler to still schedule it while prioritizing nodes that minimize the skew.
   *
   * @generated from enum value: TOPOLOGY_SPREAD_CONSTRAINT_WHEN_UNSATISFIABLE_SCHEDULE_ANYWAY = 2;
   */
  SCHEDULE_ANYWAY = 2,
}

/**
 * Describes the enum qdrant.cloud.common.v1.TopologySpreadConstraintWhenUnsatisfiable.
 */
export declare const TopologySpreadConstraintWhenUnsatisfiableSchema: GenEnum<TopologySpreadConstraintWhenUnsatisfiable>;

/**
 * A list of permissions which need to be met by the current user.
 * If `requires_all_permissions` is true (or missing): ALL of the permissions should be met (and)
 * If `requires_all_permissions` is false: ANY-OF the permissions should be met (or)
 *
 * @generated from extension: repeated string permissions = 50001;
 */
export declare const permissions: GenExtension<MethodOptions, string[]>;

/**
 * The expression to find the account ID field, which should be a string field.
 * It is allowed to nest fields with a point, like 'cluster.account_id' or 'account.id'
 * If the expression is set to an empty string, no account ID will be used.
 *
 * @generated from extension: string account_id_expression = 50002;
 */
export declare const account_id_expression: GenExtension<MethodOptions, string>;

/**
 * Set to allow a method to be used without authentication.
 *
 * @generated from extension: bool requires_authentication = 50003;
 */
export declare const requires_authentication: GenExtension<MethodOptions, boolean>;

/**
 * If this option is set, only the specified actor types are allowed to call the method.
 * If empty or not set, all authenticated actor types (that pass other permission checks) are allowed.
 *
 * @generated from extension: repeated qdrant.cloud.common.v1.ActorType supported_actor_types = 50004 [packed = true];
 */
export declare const supported_actor_types: GenExtension<MethodOptions, ActorType[]>;

/**
 * If set to true the provided permissions are ALL (and)
 * if set to false the provided permissions are ANY-OF (or).
 *
 * @generated from extension: bool requires_all_permissions = 50005;
 */
export declare const requires_all_permissions: GenExtension<MethodOptions, boolean>;

/**
 * The override of the default maximum message size in MB (per message).
 *
 * @generated from extension: int32 max_message_size = 50006;
 */
export declare const max_message_size: GenExtension<MethodOptions, number>;

/**
 * The fields to log.
 *
 * @generated from extension: repeated qdrant.cloud.common.v1.LogField log_fields = 50007;
 */
export declare const log_fields: GenExtension<MethodOptions, LogField[]>;

/**
 * The version of the API, which should follow semantic versioning.
 * This can be used by API gateways to detect the version of a specific API.
 *
 * @generated from extension: optional qdrant.cloud.common.v1.Version api_version = 50008;
 */
export declare const api_version: GenExtension<ServiceOptions, Version>;

