// @generated by protoc-gen-es v2.2.3 with parameter "target=ts"
// @generated from file qdrant/cloud/cluster/v2/cluster.proto (package qdrant.cloud.cluster.v2, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import { file_buf_validate_validate } from "../../../../buf/validate/validate_pb";
import { file_google_api_annotations } from "../../../../google/api/annotations_pb";
import type { Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { KeyValue, SecretKeyRef } from "../../common/v1/common_pb";
import { file_qdrant_cloud_common_v1_common } from "../../common/v1/common_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file qdrant/cloud/cluster/v2/cluster.proto.
 */
export const file_qdrant_cloud_cluster_v2_cluster: GenFile = /*@__PURE__*/
  fileDesc("CiVxZHJhbnQvY2xvdWQvY2x1c3Rlci92Mi9jbHVzdGVyLnByb3RvEhdxZHJhbnQuY2xvdWQuY2x1c3Rlci52MiKRAwoTTGlzdENsdXN0ZXJzUmVxdWVzdBIcCgphY2NvdW50X2lkGAEgASgJQgi6SAVyA7ABARI7Cg5jbG91ZF9wcm92aWRlchgKIAEoCUIeukgbchlSA2F3c1IDZ2NwUgVhenVyZVIGaHlicmlkSACIAQESGQoMY2xvdWRfcmVnaW9uGAsgASgJSAGIAQE63wG6SNsBGtgBChRjbHVzdGVyLmNsb3VkX3JlZ2lvbhI5Y2xvdWRfcmVnaW9uIG11c3QgYmUgYSBVVUlEIGlmIGNsb3VkX3Byb3ZpZGVyIGlzICdoeWJyaWQnGoQBdGhpcy5jbG91ZF9yZWdpb24ubWF0Y2hlcygnXlswLTlhLWZdezh9LVswLTlhLWZdezR9LVswLTlhLWZdezN9LVswODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn0kJykgfHwgdGhpcy5jbG91ZF9wcm92aWRlciE9ICdoeWJyaWQnQhEKD19jbG91ZF9wcm92aWRlckIPCg1fY2xvdWRfcmVnaW9uIkcKFExpc3RDbHVzdGVyc1Jlc3BvbnNlEi8KBWl0ZW1zGAEgAygLMiAucWRyYW50LmNsb3VkLmNsdXN0ZXIudjIuQ2x1c3RlciJPChFHZXRDbHVzdGVyUmVxdWVzdBIcCgphY2NvdW50X2lkGAEgASgJQgi6SAVyA7ABARIcCgpjbHVzdGVyX2lkGAIgASgJQgi6SAVyA7ABASJHChJHZXRDbHVzdGVyUmVzcG9uc2USMQoHY2x1c3RlchgBIAEoCzIgLnFkcmFudC5jbG91ZC5jbHVzdGVyLnYyLkNsdXN0ZXIiSQoUQ3JlYXRlQ2x1c3RlclJlcXVlc3QSMQoHY2x1c3RlchgBIAEoCzIgLnFkcmFudC5jbG91ZC5jbHVzdGVyLnYyLkNsdXN0ZXIiSgoVQ3JlYXRlQ2x1c3RlclJlc3BvbnNlEjEKB2NsdXN0ZXIYASABKAsyIC5xZHJhbnQuY2xvdWQuY2x1c3Rlci52Mi5DbHVzdGVyIkkKFFVwZGF0ZUNsdXN0ZXJSZXF1ZXN0EjEKB2NsdXN0ZXIYASABKAsyIC5xZHJhbnQuY2xvdWQuY2x1c3Rlci52Mi5DbHVzdGVyIkoKFVVwZGF0ZUNsdXN0ZXJSZXNwb25zZRIxCgdjbHVzdGVyGAEgASgLMiAucWRyYW50LmNsb3VkLmNsdXN0ZXIudjIuQ2x1c3RlciKCAQoURGVsZXRlQ2x1c3RlclJlcXVlc3QSHAoKYWNjb3VudF9pZBgBIAEoCUIIukgFcgOwAQESHAoKY2x1c3Rlcl9pZBgCIAEoCUIIukgFcgOwAQESGwoOZGVsZXRlX2JhY2t1cHMYAyABKAhIAIgBAUIRCg9fZGVsZXRlX2JhY2t1cHMiFwoVRGVsZXRlQ2x1c3RlclJlc3BvbnNlIlMKFVJlc3RhcnRDbHVzdGVyUmVxdWVzdBIcCgphY2NvdW50X2lkGAEgASgJQgi6SAVyA7ABARIcCgpjbHVzdGVyX2lkGAIgASgJQgi6SAVyA7ABASIYChZSZXN0YXJ0Q2x1c3RlclJlc3BvbnNlImsKGUxpc3RRZHJhbnRSZWxlYXNlc1JlcXVlc3QSHAoKYWNjb3VudF9pZBgBIAEoCUIIukgFcgOwAQESIQoKY2x1c3Rlcl9pZBgCIAEoCUIIukgFcgOwAQFIAIgBAUINCgtfY2x1c3Rlcl9pZCJTChpMaXN0UWRyYW50UmVsZWFzZXNSZXNwb25zZRI1CgVpdGVtcxgBIAMoCzImLnFkcmFudC5jbG91ZC5jbHVzdGVyLnYyLlFkcmFudFJlbGVhc2UikAYKB0NsdXN0ZXISCgoCaWQYASABKAkSLgoKY3JlYXRlZF9hdBgCIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASHAoKYWNjb3VudF9pZBgDIAEoCUIIukgFcgOwAQESKQoEbmFtZRgEIAEoCUIbukgYchYQBBhAMhBeW2EtekEtWjAtOS1fXSskEi4KCmRlbGV0ZWRfYXQYBSABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEjYKDmNsb3VkX3Byb3ZpZGVyGAogASgJQh66SBtyGVIDYXdzUgNnY3BSBWF6dXJlUgZoeWJyaWQSFAoMY2xvdWRfcmVnaW9uGAsgASgJEkQKDWNvbmZpZ3VyYXRpb24YFCABKAsyLS5xZHJhbnQuY2xvdWQuY2x1c3Rlci52Mi5DbHVzdGVyQ29uZmlndXJhdGlvbhI0CgVzdGF0ZRhkIAEoCzIlLnFkcmFudC5jbG91ZC5jbHVzdGVyLnYyLkNsdXN0ZXJTdGF0ZTqFA7pIgQMaowEKCmNsdXN0ZXIuaWQSGnZhbHVlIG11c3QgYmUgYSB2YWxpZCBVVUlEGnl0aGlzLmlkLm1hdGNoZXMoJ15bMC05YS1mQS1GXXs4fS1bMC05YS1mQS1GXXs0fS1bMC05YS1mQS1GXXs0fS1bMC05YS1mQS1GXXs0fS1bMC05YS1mQS1GXXsxMn0kJykgfHwgIWhhcyh0aGlzLmNyZWF0ZWRfYXQpGtgBChRjbHVzdGVyLmNsb3VkX3JlZ2lvbhI5Y2xvdWRfcmVnaW9uIG11c3QgYmUgYSBVVUlEIGlmIGNsb3VkX3Byb3ZpZGVyIGlzICdoeWJyaWQnGoQBdGhpcy5jbG91ZF9yZWdpb24ubWF0Y2hlcygnXlswLTlhLWZdezh9LVswLTlhLWZdezR9LVswLTlhLWZdezN9LVswODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn0kJykgfHwgdGhpcy5jbG91ZF9wcm92aWRlciE9ICdoeWJyaWQnIukHChRDbHVzdGVyQ29uZmlndXJhdGlvbhI0ChBsYXN0X21vZGlmaWVkX2F0GAEgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIiCg9udW1iZXJfb2Zfbm9kZXMYAiABKA1CCbpIBioEGBQoARI3Cgd2ZXJzaW9uGAMgASgJQia6SCNyITIfXih2KFxkKylcLihcZCspXC4oXGQrKXxsYXRlc3QpJBIcCgpwYWNrYWdlX2lkGAQgASgJQgi6SAVyA7ABARJPChRhZGRpdGlvbmFsX3Jlc291cmNlcxgFIAEoCzIsLnFkcmFudC5jbG91ZC5jbHVzdGVyLnYyLkFkZGl0aW9uYWxSZXNvdXJjZXNIAIgBARJTChZkYXRhYmFzZV9jb25maWd1cmF0aW9uGAcgASgLMi4ucWRyYW50LmNsb3VkLmNsdXN0ZXIudjIuRGF0YWJhc2VDb25maWd1cmF0aW9uSAGIAQESQQoNbm9kZV9zZWxlY3RvchgIIAMoCzIgLnFkcmFudC5jbG91ZC5jb21tb24udjEuS2V5VmFsdWVCCLpIBZIBAhAKEkIKC3RvbGVyYXRpb25zGAkgAygLMiMucWRyYW50LmNsb3VkLmNsdXN0ZXIudjIuVG9sZXJhdGlvbkIIukgFkgECEAoSPwoLYW5ub3RhdGlvbnMYCiADKAsyIC5xZHJhbnQuY2xvdWQuY29tbW9uLnYxLktleVZhbHVlQgi6SAWSAQIQChIxChhhbGxvd2VkX2lwX3NvdXJjZV9yYW5nZXMYCyADKAlCD7pIDJIBCRAUIgVyA/ABARIqChdyZXNlcnZlZF9jcHVfcGVyY2VudGFnZRgUIAEoDUIJukgGKgQYUCgAEi0KGnJlc2VydmVkX21lbW9yeV9wZXJjZW50YWdlGBUgASgNQgm6SAYqBBhQKAASKQoIZ3B1X3R5cGUYFiABKAlCErpID3INUgZudmlkaWFSA2FtZEgCiAEBEkAKDnJlc3RhcnRfcG9saWN5GBcgASgJQiO6SCByHlIHUm9sbGluZ1IIUGFyYWxsZWxSCUF1dG9tYXRpY0gDiAEBEkwKEnJlYmFsYW5jZV9zdHJhdGVneRgYIAEoCUIrukgociZSCGJ5X2NvdW50UgdieV9zaXplUhFieV9jb3VudF9hbmRfc2l6ZUgEiAEBQhcKFV9hZGRpdGlvbmFsX3Jlc291cmNlc0IZChdfZGF0YWJhc2VfY29uZmlndXJhdGlvbkILCglfZ3B1X3R5cGVCEQoPX3Jlc3RhcnRfcG9saWN5QhUKE19yZWJhbGFuY2Vfc3RyYXRlZ3kiqAQKFURhdGFiYXNlQ29uZmlndXJhdGlvbhJRCgpjb2xsZWN0aW9uGAEgASgLMjgucWRyYW50LmNsb3VkLmNsdXN0ZXIudjIuRGF0YWJhc2VDb25maWd1cmF0aW9uQ29sbGVjdGlvbkgAiAEBEksKB3N0b3JhZ2UYAiABKAsyNS5xZHJhbnQuY2xvdWQuY2x1c3Rlci52Mi5EYXRhYmFzZUNvbmZpZ3VyYXRpb25TdG9yYWdlSAGIAQESSwoHc2VydmljZRgDIAEoCzI1LnFkcmFudC5jbG91ZC5jbHVzdGVyLnYyLkRhdGFiYXNlQ29uZmlndXJhdGlvblNlcnZpY2VIAogBARJBCglsb2dfbGV2ZWwYBCABKAlCKbpIJnIkUgVUcmFjZVIFRGVidWdSBEluZm9SBFdhcm5SCEVycm9yT2ZmSAOIAQESQwoDdGxzGAUgASgLMjEucWRyYW50LmNsb3VkLmNsdXN0ZXIudjIuRGF0YWJhc2VDb25maWd1cmF0aW9uVGxzSASIAQESTwoJaW5mZXJlbmNlGAYgASgLMjcucWRyYW50LmNsb3VkLmNsdXN0ZXIudjIuRGF0YWJhc2VDb25maWd1cmF0aW9uSW5mZXJlbmNlSAWIAQFCDQoLX2NvbGxlY3Rpb25CCgoIX3N0b3JhZ2VCCgoIX3NlcnZpY2VCDAoKX2xvZ19sZXZlbEIGCgRfdGxzQgwKCl9pbmZlcmVuY2UizQEKH0RhdGFiYXNlQ29uZmlndXJhdGlvbkNvbGxlY3Rpb24SHwoScmVwbGljYXRpb25fZmFjdG9yGAEgASgNSACIAQESIAoYd3JpdGVfY29uc2lzdGVuY3lfZmFjdG9yGAIgASgFElAKB3ZlY3RvcnMYAyABKAsyPy5xZHJhbnQuY2xvdWQuY2x1c3Rlci52Mi5EYXRhYmFzZUNvbmZpZ3VyYXRpb25Db2xsZWN0aW9uVmVjdG9yc0IVChNfcmVwbGljYXRpb25fZmFjdG9yIkoKJkRhdGFiYXNlQ29uZmlndXJhdGlvbkNvbGxlY3Rpb25WZWN0b3JzEhQKB29uX2Rpc2sYASABKAhIAIgBAUIKCghfb25fZGlzayJ1ChxEYXRhYmFzZUNvbmZpZ3VyYXRpb25TdG9yYWdlElUKC3BlcmZvcm1hbmNlGAEgASgLMkAucWRyYW50LmNsb3VkLmNsdXN0ZXIudjIuRGF0YWJhc2VDb25maWd1cmF0aW9uU3RvcmFnZVBlcmZvcm1hbmNlIl0KJ0RhdGFiYXNlQ29uZmlndXJhdGlvblN0b3JhZ2VQZXJmb3JtYW5jZRIcChRvcHRpbWl6ZXJfY3B1X2J1ZGdldBgBIAEoBRIUCgxhc3luY19zY29yZXIYAiABKAgi6AEKHERhdGFiYXNlQ29uZmlndXJhdGlvblNlcnZpY2USOgoHYXBpX2tleRgBIAEoCzIkLnFkcmFudC5jbG91ZC5jb21tb24udjEuU2VjcmV0S2V5UmVmSACIAQESRAoRcmVhZF9vbmx5X2FwaV9rZXkYAiABKAsyJC5xZHJhbnQuY2xvdWQuY29tbW9uLnYxLlNlY3JldEtleVJlZkgBiAEBEhAKCGp3dF9yYmFjGAMgASgIEhIKCmVuYWJsZV90bHMYBCABKAhCCgoIX2FwaV9rZXlCFAoSX3JlYWRfb25seV9hcGlfa2V5IoEBChhEYXRhYmFzZUNvbmZpZ3VyYXRpb25UbHMSMgoEY2VydBgBIAEoCzIkLnFkcmFudC5jbG91ZC5jb21tb24udjEuU2VjcmV0S2V5UmVmEjEKA2tleRgCIAEoCzIkLnFkcmFudC5jbG91ZC5jb21tb24udjEuU2VjcmV0S2V5UmVmIjEKHkRhdGFiYXNlQ29uZmlndXJhdGlvbkluZmVyZW5jZRIPCgdlbmFibGVkGAEgASgIIiMKE0FkZGl0aW9uYWxSZXNvdXJjZXMSDAoEZGlzaxgDIAEoDSKrAgoKVG9sZXJhdGlvbhJDCgNrZXkYASABKAlCNrpIM3IxGD8yLV4oW2EtekEtWjAtOV0oWy1hLXpBLVowLTlfLl0qW2EtekEtWjAtOV0pPyk/JBIrCghvcGVyYXRvchgCIAEoCUIUukgRcg9SBkV4aXN0c1IFRXF1YWxIAIgBARINCgV2YWx1ZRgDIAEoCRJDCgZlZmZlY3QYBCABKAlCLrpIK3IpUgpOb1NjaGVkdWxlUhBQcmVmZXJOb1NjaGVkdWxlUglOb0V4ZWN1dGVIAYgBARIoChJ0b2xlcmF0aW9uX3NlY29uZHMYBSABKARCB7pIBDICKABIAogBAUILCglfb3BlcmF0b3JCCQoHX2VmZmVjdEIVChNfdG9sZXJhdGlvbl9zZWNvbmRzIocCCgxDbHVzdGVyU3RhdGUSDwoHdmVyc2lvbhgBIAEoCRIQCghub2Rlc191cBgCIAEoDRIwCgxyZXN0YXJ0ZWRfYXQYAyABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEg0KBXBoYXNlGAQgASgJEg4KBnJlYXNvbhgFIAEoCRI6CghlbmRwb2ludBgGIAEoCzIoLnFkcmFudC5jbG91ZC5jbHVzdGVyLnYyLkNsdXN0ZXJFbmRwb2ludBJHCglyZXNvdXJjZXMYByABKAsyNC5xZHJhbnQuY2xvdWQuY2x1c3Rlci52Mi5DbHVzdGVyTm9kZVJlc291cmNlc1N1bW1hcnkiTgoPQ2x1c3RlckVuZHBvaW50EhUKA3VybBgBIAEoCUIIukgFcgOoAQESEQoJcmVzdF9wb3J0GAIgASgFEhEKCWdycGNfcG9ydBgDIAEoBSLSAQobQ2x1c3Rlck5vZGVSZXNvdXJjZXNTdW1tYXJ5EjsKBGRpc2sYASABKAsyLS5xZHJhbnQuY2xvdWQuY2x1c3Rlci52Mi5DbHVzdGVyTm9kZVJlc291cmNlcxI6CgNyYW0YAiABKAsyLS5xZHJhbnQuY2xvdWQuY2x1c3Rlci52Mi5DbHVzdGVyTm9kZVJlc291cmNlcxI6CgNjcHUYAyABKAsyLS5xZHJhbnQuY2xvdWQuY2x1c3Rlci52Mi5DbHVzdGVyTm9kZVJlc291cmNlcyJ0ChRDbHVzdGVyTm9kZVJlc291cmNlcxIMCgRiYXNlGAEgASgBEhUKDWNvbXBsaW1lbnRhcnkYAiABKAESEgoKYWRkaXRpb25hbBgDIAEoARIQCghyZXNlcnZlZBgEIAEoARIRCglhdmFpbGFibGUYBSABKAEiiQEKDVFkcmFudFJlbGVhc2USDwoHdmVyc2lvbhgBIAEoCRIPCgdkZWZhdWx0GAIgASgIEh4KEXJlbGVhc2Vfbm90ZXNfdXJsGAMgASgJSACIAQESFAoHcmVtYXJrcxgEIAEoCUgBiAEBQhQKEl9yZWxlYXNlX25vdGVzX3VybEIKCghfcmVtYXJrczKvCwoOQ2x1c3RlclNlcnZpY2UStAEKDExpc3RDbHVzdGVycxIsLnFkcmFudC5jbG91ZC5jbHVzdGVyLnYyLkxpc3RDbHVzdGVyc1JlcXVlc3QaLS5xZHJhbnQuY2xvdWQuY2x1c3Rlci52Mi5MaXN0Q2x1c3RlcnNSZXNwb25zZSJHirUYDXJlYWQ6Y2x1c3RlcnOC0+STAjASLi9hcGkvY2x1c3Rlci92Mi9hY2NvdW50cy97YWNjb3VudF9pZH0vY2x1c3RlcnMSuwEKCkdldENsdXN0ZXISKi5xZHJhbnQuY2xvdWQuY2x1c3Rlci52Mi5HZXRDbHVzdGVyUmVxdWVzdBorLnFkcmFudC5jbG91ZC5jbHVzdGVyLnYyLkdldENsdXN0ZXJSZXNwb25zZSJUirUYDXJlYWQ6Y2x1c3RlcnOC0+STAj0SOy9hcGkvY2x1c3Rlci92Mi9hY2NvdW50cy97YWNjb3VudF9pZH0vY2x1c3RlcnMve2NsdXN0ZXJfaWR9EtkBCg1DcmVhdGVDbHVzdGVyEi0ucWRyYW50LmNsb3VkLmNsdXN0ZXIudjIuQ3JlYXRlQ2x1c3RlclJlcXVlc3QaLi5xZHJhbnQuY2xvdWQuY2x1c3Rlci52Mi5DcmVhdGVDbHVzdGVyUmVzcG9uc2UiaYq1GA53cml0ZTpjbHVzdGVyc5K1GBJjbHVzdGVyLmFjY291bnRfaWSC0+STAjs6ASoiNi9hcGkvY2x1c3Rlci92Mi9hY2NvdW50cy97Y2x1c3Rlci5hY2NvdW50X2lkfS9jbHVzdGVycxLmAQoNVXBkYXRlQ2x1c3RlchItLnFkcmFudC5jbG91ZC5jbHVzdGVyLnYyLlVwZGF0ZUNsdXN0ZXJSZXF1ZXN0Gi4ucWRyYW50LmNsb3VkLmNsdXN0ZXIudjIuVXBkYXRlQ2x1c3RlclJlc3BvbnNlInaKtRgOd3JpdGU6Y2x1c3RlcnOStRgSY2x1c3Rlci5hY2NvdW50X2lkgtPkkwJIOgEqGkMvYXBpL2NsdXN0ZXIvdjIvYWNjb3VudHMve2NsdXN0ZXIuYWNjb3VudF9pZH0vY2x1c3RlcnMve2NsdXN0ZXIuaWR9EsYBCg1EZWxldGVDbHVzdGVyEi0ucWRyYW50LmNsb3VkLmNsdXN0ZXIudjIuRGVsZXRlQ2x1c3RlclJlcXVlc3QaLi5xZHJhbnQuY2xvdWQuY2x1c3Rlci52Mi5EZWxldGVDbHVzdGVyUmVzcG9uc2UiVoq1GA9kZWxldGU6Y2x1c3RlcnOC0+STAj0qOy9hcGkvY2x1c3Rlci92Mi9hY2NvdW50cy97YWNjb3VudF9pZH0vY2x1c3RlcnMve2NsdXN0ZXJfaWR9EtABCg5SZXN0YXJ0Q2x1c3RlchIuLnFkcmFudC5jbG91ZC5jbHVzdGVyLnYyLlJlc3RhcnRDbHVzdGVyUmVxdWVzdBovLnFkcmFudC5jbG91ZC5jbHVzdGVyLnYyLlJlc3RhcnRDbHVzdGVyUmVzcG9uc2UiXYq1GA53cml0ZTpjbHVzdGVyc4LT5JMCRSJDL2FwaS9jbHVzdGVyL3YyL2FjY291bnRzL3thY2NvdW50X2lkfS9jbHVzdGVycy97Y2x1c3Rlcl9pZH0vcmVzdGFydBLGAQoSTGlzdFFkcmFudFJlbGVhc2VzEjIucWRyYW50LmNsb3VkLmNsdXN0ZXIudjIuTGlzdFFkcmFudFJlbGVhc2VzUmVxdWVzdBozLnFkcmFudC5jbG91ZC5jbHVzdGVyLnYyLkxpc3RRZHJhbnRSZWxlYXNlc1Jlc3BvbnNlIkeKtRgNcmVhZDpjbHVzdGVyc4LT5JMCMBIuL2FwaS9jbHVzdGVyL3YyL2FjY291bnRzL3thY2NvdW50X2lkfS9yZWxlYXNlc0L+AQobY29tLnFkcmFudC5jbG91ZC5jbHVzdGVyLnYyQgxDbHVzdGVyUHJvdG9QAVpSZ2l0aHViLmNvbS9xZHJhbnQvcWRyYW50LWNsb3VkLXB1YmxpYy1hcGkvZ2VuL2dvL3FkcmFudC9jbG91ZC9jbHVzdGVyL3YyO2NsdXN0ZXJ2MqICA1FDQ6oCF1FkcmFudC5DbG91ZC5DbHVzdGVyLlYyygIXUWRyYW50XENsb3VkXENsdXN0ZXJcVjLiAiNRZHJhbnRcQ2xvdWRcQ2x1c3RlclxWMlxHUEJNZXRhZGF0YeoCGlFkcmFudDo6Q2xvdWQ6OkNsdXN0ZXI6OlYyYgZwcm90bzM", [file_buf_validate_validate, file_google_api_annotations, file_google_protobuf_timestamp, file_qdrant_cloud_common_v1_common]);

/**
 * ListClustersRequest is the request for the ListClusters function
 *
 * @generated from message qdrant.cloud.cluster.v2.ListClustersRequest
 */
export type ListClustersRequest = Message<"qdrant.cloud.cluster.v2.ListClustersRequest"> & {
  /**
   * The identifier of the account (in Guid format).
   * This is a required field.
   *
   * @generated from field: string account_id = 1;
   */
  accountId: string;

  /**
   * Optional filter for cloud provider where the cluster is hosted (one of the following: aws, gcp, azure, hybrid).
   * If omitted all clusters, including the hybrid cloud ones, which belongs to the provided account are returned.
   *
   * @generated from field: optional string cloud_provider = 10;
   */
  cloudProvider?: string;

  /**
   * Optional filter for cloud region where the cluster is located
   * If this field is set the cloud_provider is required to set as well (and it should match).
   * For hybrid this should be the hybrid cloud environment ID.
   *
   * @generated from field: optional string cloud_region = 11;
   */
  cloudRegion?: string;
};

/**
 * Describes the message qdrant.cloud.cluster.v2.ListClustersRequest.
 * Use `create(ListClustersRequestSchema)` to create a new message.
 */
export const ListClustersRequestSchema: GenMessage<ListClustersRequest> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v2_cluster, 0);

/**
 * ListClustersResponse is the response from the ListClusters function
 *
 * @generated from message qdrant.cloud.cluster.v2.ListClustersResponse
 */
export type ListClustersResponse = Message<"qdrant.cloud.cluster.v2.ListClustersResponse"> & {
  /**
   * The actual clusters in this list
   *
   * @generated from field: repeated qdrant.cloud.cluster.v2.Cluster items = 1;
   */
  items: Cluster[];
};

/**
 * Describes the message qdrant.cloud.cluster.v2.ListClustersResponse.
 * Use `create(ListClustersResponseSchema)` to create a new message.
 */
export const ListClustersResponseSchema: GenMessage<ListClustersResponse> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v2_cluster, 1);

/**
 * GetClusterRequest is the request for the GetCluster function
 *
 * @generated from message qdrant.cloud.cluster.v2.GetClusterRequest
 */
export type GetClusterRequest = Message<"qdrant.cloud.cluster.v2.GetClusterRequest"> & {
  /**
   * The identifier of the account (in Guid format).
   * This is a required field.
   *
   * @generated from field: string account_id = 1;
   */
  accountId: string;

  /**
   * The identifier for the cluster (in Guid format).
   * This cluster should be part of the provided account.
   * This is a required field.
   *
   * @generated from field: string cluster_id = 2;
   */
  clusterId: string;
};

/**
 * Describes the message qdrant.cloud.cluster.v2.GetClusterRequest.
 * Use `create(GetClusterRequestSchema)` to create a new message.
 */
export const GetClusterRequestSchema: GenMessage<GetClusterRequest> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v2_cluster, 2);

/**
 * GetClusterResponse is the response from the GetCluster function
 *
 * @generated from message qdrant.cloud.cluster.v2.GetClusterResponse
 */
export type GetClusterResponse = Message<"qdrant.cloud.cluster.v2.GetClusterResponse"> & {
  /**
   * The actual cluster
   *
   * @generated from field: qdrant.cloud.cluster.v2.Cluster cluster = 1;
   */
  cluster?: Cluster;
};

/**
 * Describes the message qdrant.cloud.cluster.v2.GetClusterResponse.
 * Use `create(GetClusterResponseSchema)` to create a new message.
 */
export const GetClusterResponseSchema: GenMessage<GetClusterResponse> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v2_cluster, 3);

/**
 * CreateClusterRequest is the request for the CreateCluster function
 *
 * @generated from message qdrant.cloud.cluster.v2.CreateClusterRequest
 */
export type CreateClusterRequest = Message<"qdrant.cloud.cluster.v2.CreateClusterRequest"> & {
  /**
   * The actual cluster
   *
   * @generated from field: qdrant.cloud.cluster.v2.Cluster cluster = 1;
   */
  cluster?: Cluster;
};

/**
 * Describes the message qdrant.cloud.cluster.v2.CreateClusterRequest.
 * Use `create(CreateClusterRequestSchema)` to create a new message.
 */
export const CreateClusterRequestSchema: GenMessage<CreateClusterRequest> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v2_cluster, 4);

/**
 * CreateClusterResponse is the response from the CreateCluster function
 *
 * @generated from message qdrant.cloud.cluster.v2.CreateClusterResponse
 */
export type CreateClusterResponse = Message<"qdrant.cloud.cluster.v2.CreateClusterResponse"> & {
  /**
   * The actual cluster
   *
   * @generated from field: qdrant.cloud.cluster.v2.Cluster cluster = 1;
   */
  cluster?: Cluster;
};

/**
 * Describes the message qdrant.cloud.cluster.v2.CreateClusterResponse.
 * Use `create(CreateClusterResponseSchema)` to create a new message.
 */
export const CreateClusterResponseSchema: GenMessage<CreateClusterResponse> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v2_cluster, 5);

/**
 * UpdateClusterRequest is the request for the UpdateCluster function
 *
 * @generated from message qdrant.cloud.cluster.v2.UpdateClusterRequest
 */
export type UpdateClusterRequest = Message<"qdrant.cloud.cluster.v2.UpdateClusterRequest"> & {
  /**
   * The actual cluster
   *
   * @generated from field: qdrant.cloud.cluster.v2.Cluster cluster = 1;
   */
  cluster?: Cluster;
};

/**
 * Describes the message qdrant.cloud.cluster.v2.UpdateClusterRequest.
 * Use `create(UpdateClusterRequestSchema)` to create a new message.
 */
export const UpdateClusterRequestSchema: GenMessage<UpdateClusterRequest> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v2_cluster, 6);

/**
 * UpdateClusterResponse is the response from the UpdateCluster function
 *
 * @generated from message qdrant.cloud.cluster.v2.UpdateClusterResponse
 */
export type UpdateClusterResponse = Message<"qdrant.cloud.cluster.v2.UpdateClusterResponse"> & {
  /**
   * The actual cluster
   *
   * @generated from field: qdrant.cloud.cluster.v2.Cluster cluster = 1;
   */
  cluster?: Cluster;
};

/**
 * Describes the message qdrant.cloud.cluster.v2.UpdateClusterResponse.
 * Use `create(UpdateClusterResponseSchema)` to create a new message.
 */
export const UpdateClusterResponseSchema: GenMessage<UpdateClusterResponse> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v2_cluster, 7);

/**
 * DeleteClusterRequest is the request for the DeleteCluster function
 *
 * @generated from message qdrant.cloud.cluster.v2.DeleteClusterRequest
 */
export type DeleteClusterRequest = Message<"qdrant.cloud.cluster.v2.DeleteClusterRequest"> & {
  /**
   * The identifier of the account (in Guid format).
   * This is a required field.
   *
   * @generated from field: string account_id = 1;
   */
  accountId: string;

  /**
   * The identifier for the cluster (in Guid format).
   * This cluster should be part of the provided account.
   * This is a required field.
   *
   * @generated from field: string cluster_id = 2;
   */
  clusterId: string;

  /**
   * If set, the backups of this cluster will be deleted as well.
   *
   * @generated from field: optional bool delete_backups = 3;
   */
  deleteBackups?: boolean;
};

/**
 * Describes the message qdrant.cloud.cluster.v2.DeleteClusterRequest.
 * Use `create(DeleteClusterRequestSchema)` to create a new message.
 */
export const DeleteClusterRequestSchema: GenMessage<DeleteClusterRequest> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v2_cluster, 8);

/**
 * DeleteClusterResponse is the response from the DeleteCluster function
 *
 * Empty
 *
 * @generated from message qdrant.cloud.cluster.v2.DeleteClusterResponse
 */
export type DeleteClusterResponse = Message<"qdrant.cloud.cluster.v2.DeleteClusterResponse"> & {
};

/**
 * Describes the message qdrant.cloud.cluster.v2.DeleteClusterResponse.
 * Use `create(DeleteClusterResponseSchema)` to create a new message.
 */
export const DeleteClusterResponseSchema: GenMessage<DeleteClusterResponse> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v2_cluster, 9);

/**
 * RestartClusterRequest is the request for the RestartCluster function
 *
 * @generated from message qdrant.cloud.cluster.v2.RestartClusterRequest
 */
export type RestartClusterRequest = Message<"qdrant.cloud.cluster.v2.RestartClusterRequest"> & {
  /**
   * The identifier of the account (in Guid format).
   * This is a required field.
   *
   * @generated from field: string account_id = 1;
   */
  accountId: string;

  /**
   * The identifier for the cluster (in Guid format).
   * This cluster should be part of the provided account.
   * This is a required field.
   *
   * @generated from field: string cluster_id = 2;
   */
  clusterId: string;
};

/**
 * Describes the message qdrant.cloud.cluster.v2.RestartClusterRequest.
 * Use `create(RestartClusterRequestSchema)` to create a new message.
 */
export const RestartClusterRequestSchema: GenMessage<RestartClusterRequest> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v2_cluster, 10);

/**
 * RestartClusterResponse is the response from the RestartCluster function
 *
 * Empty
 *
 * @generated from message qdrant.cloud.cluster.v2.RestartClusterResponse
 */
export type RestartClusterResponse = Message<"qdrant.cloud.cluster.v2.RestartClusterResponse"> & {
};

/**
 * Describes the message qdrant.cloud.cluster.v2.RestartClusterResponse.
 * Use `create(RestartClusterResponseSchema)` to create a new message.
 */
export const RestartClusterResponseSchema: GenMessage<RestartClusterResponse> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v2_cluster, 11);

/**
 * ListQdrantReleasesRequest is the request for the ListQdrantReleases function
 *
 * @generated from message qdrant.cloud.cluster.v2.ListQdrantReleasesRequest
 */
export type ListQdrantReleasesRequest = Message<"qdrant.cloud.cluster.v2.ListQdrantReleasesRequest"> & {
  /**
   * The identifier of the account (in Guid format).
   * This is a required field.
   *
   * @generated from field: string account_id = 1;
   */
  accountId: string;

  /**
   * The identifier for the cluster (in Guid format).
   * This cluster should be part of the provided account.
   * This is an optional field.
   *
   * @generated from field: optional string cluster_id = 2;
   */
  clusterId?: string;
};

/**
 * Describes the message qdrant.cloud.cluster.v2.ListQdrantReleasesRequest.
 * Use `create(ListQdrantReleasesRequestSchema)` to create a new message.
 */
export const ListQdrantReleasesRequestSchema: GenMessage<ListQdrantReleasesRequest> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v2_cluster, 12);

/**
 * ListQdrantReleasesResponse is the response from the ListQdrantReleases function
 *
 * @generated from message qdrant.cloud.cluster.v2.ListQdrantReleasesResponse
 */
export type ListQdrantReleasesResponse = Message<"qdrant.cloud.cluster.v2.ListQdrantReleasesResponse"> & {
  /**
   * The actual Qdrant releases in this list
   *
   * @generated from field: repeated qdrant.cloud.cluster.v2.QdrantRelease items = 1;
   */
  items: QdrantRelease[];
};

/**
 * Describes the message qdrant.cloud.cluster.v2.ListQdrantReleasesResponse.
 * Use `create(ListQdrantReleasesResponseSchema)` to create a new message.
 */
export const ListQdrantReleasesResponseSchema: GenMessage<ListQdrantReleasesResponse> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v2_cluster, 13);

/**
 * A Cluster represents one cluster of a Qdrant database.
 *
 * @generated from message qdrant.cloud.cluster.v2.Cluster
 */
export type Cluster = Message<"qdrant.cloud.cluster.v2.Cluster"> & {
  /**
   * Unique identifier for the cluster (in Guid format).
   * This is a read-only field and will be available after a cluster is created.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * Timestamp when the cluster was created.
   * This is a read-only field and will be available after a cluster is created.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 2;
   */
  createdAt?: Timestamp;

  /**
   * Identifier of the account associated with the cluster (in Guid format).
   * This is a required field.
   *
   * @generated from field: string account_id = 3;
   */
  accountId: string;

  /**
   * Name of the cluster.
   * This is a required field.
   * Name can only contain letters, numbers, underscores and dashes
   *
   * @generated from field: string name = 4;
   */
  name: string;

  /**
   * Timestamp when the cluster was deleted (or is started to be deleting).
   * This is a read-only field and will be set after DeleteCluster is called.
   *
   * @generated from field: google.protobuf.Timestamp deleted_at = 5;
   */
  deletedAt?: Timestamp;

  /**
   * Cloud provider where the cluster is hosted.
   * This is a required field (one of the following: aws, gcp, azure, hybrid).
   * After creation, this field cannot be changed.
   *
   * @generated from field: string cloud_provider = 10;
   */
  cloudProvider: string;

  /**
   * Cloud region where the cluster is located.
   * For hybrid this should be the hybrid cloud environment ID.
   * This is a required field.
   * After creation, this field cannot be changed.
   *
   * @generated from field: string cloud_region = 11;
   */
  cloudRegion: string;

  /**
   * Current configuration details of the cluster.
   *
   * @generated from field: qdrant.cloud.cluster.v2.ClusterConfiguration configuration = 20;
   */
  configuration?: ClusterConfiguration;

  /**
   * Current state of the cluster.
   * All fields inside `state` are read-only.
   *
   * @generated from field: qdrant.cloud.cluster.v2.ClusterState state = 100;
   */
  state?: ClusterState;
};

/**
 * Describes the message qdrant.cloud.cluster.v2.Cluster.
 * Use `create(ClusterSchema)` to create a new message.
 */
export const ClusterSchema: GenMessage<Cluster> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v2_cluster, 14);

/**
 * A ClusterConfiguration represents the configuration of a cluster.
 *
 * @generated from message qdrant.cloud.cluster.v2.ClusterConfiguration
 */
export type ClusterConfiguration = Message<"qdrant.cloud.cluster.v2.ClusterConfiguration"> & {
  /**
   * Timestamp when the cluster configuration was last updated.
   * This is a read-only field and will be available after a cluster is created.
   *
   * @generated from field: google.protobuf.Timestamp last_modified_at = 1;
   */
  lastModifiedAt?: Timestamp;

  /**
   * The number of nodes in a cluster.
   * This should be a number 1...20 [both included].
   *
   * @generated from field: uint32 number_of_nodes = 2;
   */
  numberOfNodes: number;

  /**
   * Version of the cluster software.
   * If omitted the latest version will be used and filled out during create.
   * Use ListReleases() to determine which versions are allowed to be used.
   * See upgrade guidelines for more info.
   *
   * @generated from field: string version = 3;
   */
  version: string;

  /**
   * TODO: Needing a package_id here is very bad usability for users.
   * That means we would need to start documenting all package_ids somewhere.
   * Rather we should introduce speaking package names in the public api (even if we have them different internally).
   * In the price list we already have them kind of 'https://docs.google.com/spreadsheets/d/1dDo1u6YExocd2MJfi_Xgjnret2vJqo84S-9-gcOltkc/edit?gid=0#gid=0'
   * We could derive them from the SKU, e.g. QN_16x128 fine with something else as well.
   * The package identifier used to configure the resources of the cluster. Use ListPackages() to select one.
   *
   * @generated from field: string package_id = 4;
   */
  packageId: string;

  /**
   * The additional resources on top of the selected package.
   * This is an optional field, if not specified all additional resources are 0.
   *
   * @generated from field: optional qdrant.cloud.cluster.v2.AdditionalResources additional_resources = 5;
   */
  additionalResources?: AdditionalResources;

  /**
   * Configuration to setup a qdrant database in a hybrid cloud.
   * It is ignored for managed cloud clusters. This is an optional field
   *
   * @generated from field: optional qdrant.cloud.cluster.v2.DatabaseConfiguration database_configuration = 7;
   */
  databaseConfiguration?: DatabaseConfiguration;

  /**
   * The node selector for this cluster in a hybrid cloud.
   * It is ignored for managed cloud clusters. This is an optional field
   *
   * @generated from field: repeated qdrant.cloud.common.v1.KeyValue node_selector = 8;
   */
  nodeSelector: KeyValue[];

  /**
   * List of tolerations for this cluster in a hybrid cloud.
   * It is ignored for managed cloud clusters. This is an optional field
   *
   * @generated from field: repeated qdrant.cloud.cluster.v2.Toleration tolerations = 9;
   */
  tolerations: Toleration[];

  /**
   * List of annotations for this cluster in a hybrid cloud.
   * It is ignored for managed cloud clusters. This is an optional field
   *
   * @generated from field: repeated qdrant.cloud.common.v1.KeyValue annotations = 10;
   */
  annotations: KeyValue[];

  /**
   * List of allowed IP source ranges for this cluster.
   * Field is used for both managed cloud and hybrid cloud and clusters. This is an optional field
   * The CIDRs supports IPv4 only.
   *
   * @generated from field: repeated string allowed_ip_source_ranges = 11;
   */
  allowedIpSourceRanges: string[];

  /**
   * The percentage of CPU resources reserved for system components
   * This is an optional field, default is 0.
   * Number between 0..80
   *
   * @generated from field: uint32 reserved_cpu_percentage = 20;
   */
  reservedCpuPercentage: number;

  /**
   * The percentage of RAM resources reserved for system components
   * This is an optional field, default is 0.
   * Number between 0..80
   *
   * @generated from field: uint32 reserved_memory_percentage = 21;
   */
  reservedMemoryPercentage: number;

  /**
   * The gpu type that should be used for the database
   * This is an optional field, default is No configured GPU
   * The allowed values are: nvidia, amd
   *
   * @generated from field: optional string gpu_type = 22;
   */
  gpuType?: string;

  /**
   * The restart policy for the database
   * This is an optional field, default is Automatic
   * The allowed values are: Rolling, Parallel, Automatic
   *
   * @generated from field: optional string restart_policy = 23;
   */
  restartPolicy?: string;

  /**
   * The automatic shard rebalancing strategy for the database
   * This is an optional field, default is none
   * The allowed values are: by_count, by_size, by_count_and_size
   *
   * @generated from field: optional string rebalance_strategy = 24;
   */
  rebalanceStrategy?: string;
};

/**
 * Describes the message qdrant.cloud.cluster.v2.ClusterConfiguration.
 * Use `create(ClusterConfigurationSchema)` to create a new message.
 */
export const ClusterConfigurationSchema: GenMessage<ClusterConfiguration> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v2_cluster, 15);

/**
 * Configuration to setup a Qdrant database in a hybrid cloud.
 * All settings apply to hybrid cloud only.
 *
 * @generated from message qdrant.cloud.cluster.v2.DatabaseConfiguration
 */
export type DatabaseConfiguration = Message<"qdrant.cloud.cluster.v2.DatabaseConfiguration"> & {
  /**
   * The default Qdrant database collection configuration
   * This is an optional field
   *
   * @generated from field: optional qdrant.cloud.cluster.v2.DatabaseConfigurationCollection collection = 1;
   */
  collection?: DatabaseConfigurationCollection;

  /**
   * The default Qdrant database storage configuration
   * This is an optional field
   *
   * @generated from field: optional qdrant.cloud.cluster.v2.DatabaseConfigurationStorage storage = 2;
   */
  storage?: DatabaseConfigurationStorage;

  /**
   * The Qdrant database service configuration
   * This is an optional field
   *
   * @generated from field: optional qdrant.cloud.cluster.v2.DatabaseConfigurationService service = 3;
   */
  service?: DatabaseConfigurationService;

  /**
   * The log level for the database
   * This is an optional field, default is Info
   * The allowed values are: Trace, Debug, Info, Warn, Error, Off
   * Qdrant is written in Rust and is using: https://docs.rs/log/latest/log/enum.LevelFilter.html
   *
   * @generated from field: optional string log_level = 4;
   */
  logLevel?: string;

  /**
   * The Qdrant database TLS configuration
   * This is an optional field, if not set an unsecure connection is provided
   *
   * @generated from field: optional qdrant.cloud.cluster.v2.DatabaseConfigurationTls tls = 5;
   */
  tls?: DatabaseConfigurationTls;

  /**
   * The Qdrant database inference configuration
   * This is an optional field, if unset, the database is not configured for cloud inferencing
   *
   * @generated from field: optional qdrant.cloud.cluster.v2.DatabaseConfigurationInference inference = 6;
   */
  inference?: DatabaseConfigurationInference;
};

/**
 * Describes the message qdrant.cloud.cluster.v2.DatabaseConfiguration.
 * Use `create(DatabaseConfigurationSchema)` to create a new message.
 */
export const DatabaseConfigurationSchema: GenMessage<DatabaseConfiguration> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v2_cluster, 16);

/**
 * The default Qdrant database collection configuration
 *
 * @generated from message qdrant.cloud.cluster.v2.DatabaseConfigurationCollection
 */
export type DatabaseConfigurationCollection = Message<"qdrant.cloud.cluster.v2.DatabaseConfigurationCollection"> & {
  /**
   * Number of replicas of each shard that network tries to maintain
   * This is an optional, the default is 1
   *
   * @generated from field: optional uint32 replication_factor = 1;
   */
  replicationFactor?: number;

  /**
   * How many replicas should apply the operation for us to consider it successful
   * This is an optional, the default is 1
   *
   * @generated from field: int32 write_consistency_factor = 2;
   */
  writeConsistencyFactor: number;

  /**
   * The default parameters for vectors.
   *
   * @generated from field: qdrant.cloud.cluster.v2.DatabaseConfigurationCollectionVectors vectors = 3;
   */
  vectors?: DatabaseConfigurationCollectionVectors;
};

/**
 * Describes the message qdrant.cloud.cluster.v2.DatabaseConfigurationCollection.
 * Use `create(DatabaseConfigurationCollectionSchema)` to create a new message.
 */
export const DatabaseConfigurationCollectionSchema: GenMessage<DatabaseConfigurationCollection> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v2_cluster, 17);

/**
 * The default Qdrant database collection vectors configuration
 *
 * @generated from message qdrant.cloud.cluster.v2.DatabaseConfigurationCollectionVectors
 */
export type DatabaseConfigurationCollectionVectors = Message<"qdrant.cloud.cluster.v2.DatabaseConfigurationCollectionVectors"> & {
  /**
   * If set, this will create a collection with all vectors immediately stored in memmap storage.
   * This is the recommended way, in case your Qdrant instance operates with fast disks and you are working with large collections.
   * For more info see: https://qdrant.tech/documentation/concepts/storage/#configuring-memmap-storage
   * This is an optional field, the default value will be true.
   *
   * @generated from field: optional bool on_disk = 1;
   */
  onDisk?: boolean;
};

/**
 * Describes the message qdrant.cloud.cluster.v2.DatabaseConfigurationCollectionVectors.
 * Use `create(DatabaseConfigurationCollectionVectorsSchema)` to create a new message.
 */
export const DatabaseConfigurationCollectionVectorsSchema: GenMessage<DatabaseConfigurationCollectionVectors> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v2_cluster, 18);

/**
 * The Qdrant storage configuration
 *
 * @generated from message qdrant.cloud.cluster.v2.DatabaseConfigurationStorage
 */
export type DatabaseConfigurationStorage = Message<"qdrant.cloud.cluster.v2.DatabaseConfigurationStorage"> & {
  /**
   * The performance related Qdrant database storage configuration
   *
   * @generated from field: qdrant.cloud.cluster.v2.DatabaseConfigurationStoragePerformance performance = 1;
   */
  performance?: DatabaseConfigurationStoragePerformance;
};

/**
 * Describes the message qdrant.cloud.cluster.v2.DatabaseConfigurationStorage.
 * Use `create(DatabaseConfigurationStorageSchema)` to create a new message.
 */
export const DatabaseConfigurationStorageSchema: GenMessage<DatabaseConfigurationStorage> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v2_cluster, 19);

/**
 * The performance related Qdrant database storage configuration
 *
 * @generated from message qdrant.cloud.cluster.v2.DatabaseConfigurationStoragePerformance
 */
export type DatabaseConfigurationStoragePerformance = Message<"qdrant.cloud.cluster.v2.DatabaseConfigurationStoragePerformance"> & {
  /**
   * CPU budget, how many CPUs (threads) to allocate for an optimization job.
   * If 0 - auto selection, keep 1 or more CPUs unallocated depending on CPU size
   * If negative - subtract this number of CPUs from the available CPUs.
   * If positive - use this exact number of CPUs.
   *
   * @generated from field: int32 optimizer_cpu_budget = 1;
   */
  optimizerCpuBudget: number;

  /**
   * Enable async scorer which uses io_uring when rescoring.
   * Only supported on Linux, must be enabled in your kernel.
   * See: https://qdrant.tech/articles/io_uring/#and-what-about-qdrant
   *
   * @generated from field: bool async_scorer = 2;
   */
  asyncScorer: boolean;
};

/**
 * Describes the message qdrant.cloud.cluster.v2.DatabaseConfigurationStoragePerformance.
 * Use `create(DatabaseConfigurationStoragePerformanceSchema)` to create a new message.
 */
export const DatabaseConfigurationStoragePerformanceSchema: GenMessage<DatabaseConfigurationStoragePerformance> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v2_cluster, 20);

/**
 * The Qdrant database service configuration
 *
 * @generated from message qdrant.cloud.cluster.v2.DatabaseConfigurationService
 */
export type DatabaseConfigurationService = Message<"qdrant.cloud.cluster.v2.DatabaseConfigurationService"> & {
  /**
   * Set an api-key.
   * If set, all requests must include a header with the api-key.
   * example header: `api-key: <API-KEY>`
   *
   * @generated from field: optional qdrant.cloud.common.v1.SecretKeyRef api_key = 1;
   */
  apiKey?: SecretKeyRef;

  /**
   * Set an api-key for read-only operations.
   * If set, all requests must include a header with the api-key.
   * example header: `api-key: <API-KEY>`
   *
   * @generated from field: optional qdrant.cloud.common.v1.SecretKeyRef read_only_api_key = 2;
   */
  readOnlyApiKey?: SecretKeyRef;

  /**
   * Enable JWT Role Based Access Control (RBAC).
   * If enabled, you can generate JWT tokens with fine-grained rules for access control.
   * Use generated token instead of API key.
   *
   * @generated from field: bool jwt_rbac = 3;
   */
  jwtRbac: boolean;

  /**
   * Enable HTTPS for the REST and gRPC API
   *
   * @generated from field: bool enable_tls = 4;
   */
  enableTls: boolean;
};

/**
 * Describes the message qdrant.cloud.cluster.v2.DatabaseConfigurationService.
 * Use `create(DatabaseConfigurationServiceSchema)` to create a new message.
 */
export const DatabaseConfigurationServiceSchema: GenMessage<DatabaseConfigurationService> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v2_cluster, 21);

/**
 * DatabaseConfigurationTls contains the information to setup a TLS connection to the database endpoint
 *
 * @generated from message qdrant.cloud.cluster.v2.DatabaseConfigurationTls
 */
export type DatabaseConfigurationTls = Message<"qdrant.cloud.cluster.v2.DatabaseConfigurationTls"> & {
  /**
   * Secret to use for the certificate
   *
   * @generated from field: qdrant.cloud.common.v1.SecretKeyRef cert = 1;
   */
  cert?: SecretKeyRef;

  /**
   * Secret to use for the private key
   *
   * @generated from field: qdrant.cloud.common.v1.SecretKeyRef key = 2;
   */
  key?: SecretKeyRef;
};

/**
 * Describes the message qdrant.cloud.cluster.v2.DatabaseConfigurationTls.
 * Use `create(DatabaseConfigurationTlsSchema)` to create a new message.
 */
export const DatabaseConfigurationTlsSchema: GenMessage<DatabaseConfigurationTls> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v2_cluster, 22);

/**
 * DatabaseConfigurationInference contains cloud inferencing configuration
 *
 * @generated from message qdrant.cloud.cluster.v2.DatabaseConfigurationInference
 */
export type DatabaseConfigurationInference = Message<"qdrant.cloud.cluster.v2.DatabaseConfigurationInference"> & {
  /**
   * If true, the database is configured to use cloud inferencing
   *
   * @generated from field: bool enabled = 1;
   */
  enabled: boolean;
};

/**
 * Describes the message qdrant.cloud.cluster.v2.DatabaseConfigurationInference.
 * Use `create(DatabaseConfigurationInferenceSchema)` to create a new message.
 */
export const DatabaseConfigurationInferenceSchema: GenMessage<DatabaseConfigurationInference> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v2_cluster, 23);

/**
 * AdditionalResources contains the information about additional resources
 *
 * @generated from message qdrant.cloud.cluster.v2.AdditionalResources
 */
export type AdditionalResources = Message<"qdrant.cloud.cluster.v2.AdditionalResources"> & {
  /**
   * Additional Disk (expressed in Gib)
   *
   * @generated from field: uint32 disk = 3;
   */
  disk: number;
};

/**
 * Describes the message qdrant.cloud.cluster.v2.AdditionalResources.
 * Use `create(AdditionalResourcesSchema)` to create a new message.
 */
export const AdditionalResourcesSchema: GenMessage<AdditionalResources> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v2_cluster, 24);

/**
 * The Toleration message represents a toleration object for Kubernetes.
 *
 * @generated from message qdrant.cloud.cluster.v2.Toleration
 */
export type Toleration = Message<"qdrant.cloud.cluster.v2.Toleration"> & {
  /**
   * The key to match against the key of a node label.
   *
   * @generated from field: string key = 1;
   */
  key: string;

  /**
   * The operator represents a key's relationship to the value.
   * Valid operators are "Exists" and "Equal".
   * The default is Exists
   *
   * @generated from field: optional string operator = 2;
   */
  operator?: string;

  /**
   * The value to match against the value of a node label.
   *
   * @generated from field: string value = 3;
   */
  value: string;

  /**
   * The effect indicates the taint effect to match.
   * Valid effects are "NoSchedule", "PreferNoSchedule", and "NoExecute".
   * The default is NoSchedule
   *
   * @generated from field: optional string effect = 4;
   */
  effect?: string;

  /**
   * The toleration seconds indicates the duration to tolerate the taint.
   *
   * @generated from field: optional uint64 toleration_seconds = 5;
   */
  tolerationSeconds?: bigint;
};

/**
 * Describes the message qdrant.cloud.cluster.v2.Toleration.
 * Use `create(TolerationSchema)` to create a new message.
 */
export const TolerationSchema: GenMessage<Toleration> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v2_cluster, 25);

/**
 * ClusterState represents the current state of a cluster
 * All fields in this message are read-only.
 *
 * @generated from message qdrant.cloud.cluster.v2.ClusterState
 */
export type ClusterState = Message<"qdrant.cloud.cluster.v2.ClusterState"> & {
  /**
   * Version of the cluster software
   *
   * @generated from field: string version = 1;
   */
  version: string;

  /**
   * Number of cluster nodes that are up and running
   *
   * @generated from field: uint32 nodes_up = 2;
   */
  nodesUp: number;

  /**
   * The date and time when the cluster was restarted
   *
   * @generated from field: google.protobuf.Timestamp restarted_at = 3;
   */
  restartedAt?: Timestamp;

  /**
   * Current phase of the cluster
   * One of the following: Creating, ...
   *
   * @generated from field: string phase = 4;
   */
  phase: string;

  /**
   * Reason for the current phase of the cluster.
   *
   * @generated from field: string reason = 5;
   */
  reason: string;

  /**
   * Endpoint information to access the qdrant cluster (aka database).
   *
   * @generated from field: qdrant.cloud.cluster.v2.ClusterEndpoint endpoint = 6;
   */
  endpoint?: ClusterEndpoint;

  /**
   * The resources used by the cluster per node.
   * For the complete cluster you have to multiply by cluster.configuration.number_of_nodes
   *
   * @generated from field: qdrant.cloud.cluster.v2.ClusterNodeResourcesSummary resources = 7;
   */
  resources?: ClusterNodeResourcesSummary;
};

/**
 * Describes the message qdrant.cloud.cluster.v2.ClusterState.
 * Use `create(ClusterStateSchema)` to create a new message.
 */
export const ClusterStateSchema: GenMessage<ClusterState> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v2_cluster, 26);

/**
 * Endpoint information to access the qdrant cluster (aka database).
 * All fields in this message are a read-only field.
 *
 * @generated from message qdrant.cloud.cluster.v2.ClusterEndpoint
 */
export type ClusterEndpoint = Message<"qdrant.cloud.cluster.v2.ClusterEndpoint"> & {
  /**
   * URL to access the qdrant cluster (aka database) without port
   *
   * @generated from field: string url = 1;
   */
  url: string;

  /**
   * The port to use for HTTP REST calls (6333)
   *
   * @generated from field: int32 rest_port = 2;
   */
  restPort: number;

  /**
   * The port to use for gRPC calls (6334)
   *
   * @generated from field: int32 grpc_port = 3;
   */
  grpcPort: number;
};

/**
 * Describes the message qdrant.cloud.cluster.v2.ClusterEndpoint.
 * Use `create(ClusterEndpointSchema)` to create a new message.
 */
export const ClusterEndpointSchema: GenMessage<ClusterEndpoint> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v2_cluster, 27);

/**
 * ClusterNodeResourcesSummary represents the resources used in this cluster per node.
 *
 * @generated from message qdrant.cloud.cluster.v2.ClusterNodeResourcesSummary
 */
export type ClusterNodeResourcesSummary = Message<"qdrant.cloud.cluster.v2.ClusterNodeResourcesSummary"> & {
  /**
   * Disk resources
   *
   * @generated from field: qdrant.cloud.cluster.v2.ClusterNodeResources disk = 1;
   */
  disk?: ClusterNodeResources;

  /**
   * Memory resources
   *
   * @generated from field: qdrant.cloud.cluster.v2.ClusterNodeResources ram = 2;
   */
  ram?: ClusterNodeResources;

  /**
   * CPU resources
   *
   * @generated from field: qdrant.cloud.cluster.v2.ClusterNodeResources cpu = 3;
   */
  cpu?: ClusterNodeResources;
};

/**
 * Describes the message qdrant.cloud.cluster.v2.ClusterNodeResourcesSummary.
 * Use `create(ClusterNodeResourcesSummarySchema)` to create a new message.
 */
export const ClusterNodeResourcesSummarySchema: GenMessage<ClusterNodeResourcesSummary> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v2_cluster, 28);

/**
 * ClusterNodeResources represents the allocation of various resources for a cluster per node.
 *
 * @generated from message qdrant.cloud.cluster.v2.ClusterNodeResources
 */
export type ClusterNodeResources = Message<"qdrant.cloud.cluster.v2.ClusterNodeResources"> & {
  /**
   * Base resources that are part of the standard allocation for the cluster per node.
   * This includes default CPU, memory, storage, etc.
   *
   * @generated from field: double base = 1;
   */
  base: number;

  /**
   * Complimentary resources provided to the cluster at no additional cost.
   * This might include complimentary network bandwidth, credits, etc.
   *
   * @generated from field: double complimentary = 2;
   */
  complimentary: number;

  /**
   * Additional resources allocated to the cluster.
   * This could include additional storage, compute power, etc.
   *
   * @generated from field: double additional = 3;
   */
  additional: number;

  /**
   * The reserved is the amount used by the system, which cannot be used by the database itself.
   *
   * @generated from field: double reserved = 4;
   */
  reserved: number;

  /**
   * The available is the total (base+complimentary+additional) - reserved
   *
   * @generated from field: double available = 5;
   */
  available: number;
};

/**
 * Describes the message qdrant.cloud.cluster.v2.ClusterNodeResources.
 * Use `create(ClusterNodeResourcesSchema)` to create a new message.
 */
export const ClusterNodeResourcesSchema: GenMessage<ClusterNodeResources> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v2_cluster, 29);

/**
 * QdrantRelease represent a single Qdrant release
 *
 * @generated from message qdrant.cloud.cluster.v2.QdrantRelease
 */
export type QdrantRelease = Message<"qdrant.cloud.cluster.v2.QdrantRelease"> & {
  /**
   * Version of the Qdrant release
   *
   * @generated from field: string version = 1;
   */
  version: string;

  /**
   * Flag to indicate if this is the default release
   * There can be at most a single item in the list that have this property set.
   *
   * @generated from field: bool default = 2;
   */
  default: boolean;

  /**
   * URL to the release notes
   *
   * @generated from field: optional string release_notes_url = 3;
   */
  releaseNotesUrl?: string;

  /**
   * Additional message regarding this release that might be useful to the client"
   *
   * @generated from field: optional string remarks = 4;
   */
  remarks?: string;
};

/**
 * Describes the message qdrant.cloud.cluster.v2.QdrantRelease.
 * Use `create(QdrantReleaseSchema)` to create a new message.
 */
export const QdrantReleaseSchema: GenMessage<QdrantRelease> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v2_cluster, 30);

/**
 * ClusterService is the API used to configure cluster objects.
 *
 * @generated from service qdrant.cloud.cluster.v2.ClusterService
 */
export const ClusterService: GenService<{
  /**
   * Fetch all clusters in the account identified by the given ID.
   * Required permissions:
   * - read:clusters
   *
   * @generated from rpc qdrant.cloud.cluster.v2.ClusterService.ListClusters
   */
  listClusters: {
    methodKind: "unary";
    input: typeof ListClustersRequestSchema;
    output: typeof ListClustersResponseSchema;
  },
  /**
   * Fetch a cluster in the account identified by the given IDs.
   * Required permissions:
   * - read:clusters
   *
   * @generated from rpc qdrant.cloud.cluster.v2.ClusterService.GetCluster
   */
  getCluster: {
    methodKind: "unary";
    input: typeof GetClusterRequestSchema;
    output: typeof GetClusterResponseSchema;
  },
  /**
   * Creates a cluster in the account identified by the given ID.
   * Required permissions:
   * - write:clusters
   *
   * @generated from rpc qdrant.cloud.cluster.v2.ClusterService.CreateCluster
   */
  createCluster: {
    methodKind: "unary";
    input: typeof CreateClusterRequestSchema;
    output: typeof CreateClusterResponseSchema;
  },
  /**
   * Update a cluster in the account identified by the given ID.
   * Required permissions:
   * - write:clusters
   *
   * @generated from rpc qdrant.cloud.cluster.v2.ClusterService.UpdateCluster
   */
  updateCluster: {
    methodKind: "unary";
    input: typeof UpdateClusterRequestSchema;
    output: typeof UpdateClusterResponseSchema;
  },
  /**
   * Deletes a cluster in the account identified by the given ID.
   * Required permissions:
   * - delete:clusters
   *
   * @generated from rpc qdrant.cloud.cluster.v2.ClusterService.DeleteCluster
   */
  deleteCluster: {
    methodKind: "unary";
    input: typeof DeleteClusterRequestSchema;
    output: typeof DeleteClusterResponseSchema;
  },
  /**
   * Restarts a cluster in the account identified by the given ID.
   * Required permissions:
   * - write:clusters
   *
   * @generated from rpc qdrant.cloud.cluster.v2.ClusterService.RestartCluster
   */
  restartCluster: {
    methodKind: "unary";
    input: typeof RestartClusterRequestSchema;
    output: typeof RestartClusterResponseSchema;
  },
  /**
   * Fetch all qdrant releases in the account identified by the given ID.
   * Optional a cluster ID can be provided, the list will return the options to update to only.
   * Required permissions:
   * - read:clusters
   *
   * @generated from rpc qdrant.cloud.cluster.v2.ClusterService.ListQdrantReleases
   */
  listQdrantReleases: {
    methodKind: "unary";
    input: typeof ListQdrantReleasesRequestSchema;
    output: typeof ListQdrantReleasesResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_qdrant_cloud_cluster_v2_cluster, 0);

