// @generated by protoc-gen-es v2.2.3 with parameter "target=ts"
// @generated from file qdrant/cloud/cluster/v1/cluster.proto (package qdrant.cloud.cluster.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import { file_buf_validate_validate } from "../../../../buf/validate/validate_pb";
import { file_google_api_annotations } from "../../../../google/api/annotations_pb";
import type { Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { KeyValue, SecretKeyRef } from "../../common/v1/common_pb";
import { file_qdrant_cloud_common_v1_common } from "../../common/v1/common_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file qdrant/cloud/cluster/v1/cluster.proto.
 */
export const file_qdrant_cloud_cluster_v1_cluster: GenFile = /*@__PURE__*/
  fileDesc("CiVxZHJhbnQvY2xvdWQvY2x1c3Rlci92MS9jbHVzdGVyLnByb3RvEhdxZHJhbnQuY2xvdWQuY2x1c3Rlci52MSLCAwoTTGlzdENsdXN0ZXJzUmVxdWVzdBIcCgphY2NvdW50X2lkGAEgASgJQgi6SAVyA7ABARInChFjbG91ZF9wcm92aWRlcl9pZBgKIAEoCUIHukgEcgIQA0gAiAEBEiUKGGNsb3VkX3Byb3ZpZGVyX3JlZ2lvbl9pZBgLIAEoCUgBiAEBOokCukiFAhqCAgogY2x1c3Rlci5jbG91ZF9wcm92aWRlcl9yZWdpb25faWQSSGNsb3VkX3Byb3ZpZGVyX3JlZ2lvbl9pZCBtdXN0IGJlIGEgVVVJRCBpZiBjbG91ZF9wcm92aWRlcl9pZCBpcyAnaHlicmlkJxqTAXRoaXMuY2xvdWRfcHJvdmlkZXJfcmVnaW9uX2lkLm1hdGNoZXMoJ15bMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMC05YS1mXXszfS1bMDg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9JCcpIHx8IHRoaXMuY2xvdWRfcHJvdmlkZXJfaWQhPSAnaHlicmlkJ0IUChJfY2xvdWRfcHJvdmlkZXJfaWRCGwoZX2Nsb3VkX3Byb3ZpZGVyX3JlZ2lvbl9pZCJHChRMaXN0Q2x1c3RlcnNSZXNwb25zZRIvCgVpdGVtcxgBIAMoCzIgLnFkcmFudC5jbG91ZC5jbHVzdGVyLnYxLkNsdXN0ZXIiTwoRR2V0Q2x1c3RlclJlcXVlc3QSHAoKYWNjb3VudF9pZBgBIAEoCUIIukgFcgOwAQESHAoKY2x1c3Rlcl9pZBgCIAEoCUIIukgFcgOwAQEiRwoSR2V0Q2x1c3RlclJlc3BvbnNlEjEKB2NsdXN0ZXIYASABKAsyIC5xZHJhbnQuY2xvdWQuY2x1c3Rlci52MS5DbHVzdGVyIkkKFENyZWF0ZUNsdXN0ZXJSZXF1ZXN0EjEKB2NsdXN0ZXIYASABKAsyIC5xZHJhbnQuY2xvdWQuY2x1c3Rlci52MS5DbHVzdGVyIkoKFUNyZWF0ZUNsdXN0ZXJSZXNwb25zZRIxCgdjbHVzdGVyGAEgASgLMiAucWRyYW50LmNsb3VkLmNsdXN0ZXIudjEuQ2x1c3RlciJJChRVcGRhdGVDbHVzdGVyUmVxdWVzdBIxCgdjbHVzdGVyGAEgASgLMiAucWRyYW50LmNsb3VkLmNsdXN0ZXIudjEuQ2x1c3RlciJKChVVcGRhdGVDbHVzdGVyUmVzcG9uc2USMQoHY2x1c3RlchgBIAEoCzIgLnFkcmFudC5jbG91ZC5jbHVzdGVyLnYxLkNsdXN0ZXIiggEKFERlbGV0ZUNsdXN0ZXJSZXF1ZXN0EhwKCmFjY291bnRfaWQYASABKAlCCLpIBXIDsAEBEhwKCmNsdXN0ZXJfaWQYAiABKAlCCLpIBXIDsAEBEhsKDmRlbGV0ZV9iYWNrdXBzGAMgASgISACIAQFCEQoPX2RlbGV0ZV9iYWNrdXBzIhcKFURlbGV0ZUNsdXN0ZXJSZXNwb25zZSJTChVSZXN0YXJ0Q2x1c3RlclJlcXVlc3QSHAoKYWNjb3VudF9pZBgBIAEoCUIIukgFcgOwAQESHAoKY2x1c3Rlcl9pZBgCIAEoCUIIukgFcgOwAQEiGAoWUmVzdGFydENsdXN0ZXJSZXNwb25zZSJrChlMaXN0UWRyYW50UmVsZWFzZXNSZXF1ZXN0EhwKCmFjY291bnRfaWQYASABKAlCCLpIBXIDsAEBEiEKCmNsdXN0ZXJfaWQYAiABKAlCCLpIBXIDsAEBSACIAQFCDQoLX2NsdXN0ZXJfaWQiUwoaTGlzdFFkcmFudFJlbGVhc2VzUmVzcG9uc2USNQoFaXRlbXMYASADKAsyJi5xZHJhbnQuY2xvdWQuY2x1c3Rlci52MS5RZHJhbnRSZWxlYXNlIrIGCgdDbHVzdGVyEgoKAmlkGAEgASgJEi4KCmNyZWF0ZWRfYXQYAiABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEhwKCmFjY291bnRfaWQYAyABKAlCCLpIBXIDsAEBEikKBG5hbWUYBCABKAlCG7pIGHIWEAQYQDIQXlthLXpBLVowLTktX10rJBIuCgpkZWxldGVkX2F0GAUgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIiChFjbG91ZF9wcm92aWRlcl9pZBgKIAEoCUIHukgEcgIQAxIgChhjbG91ZF9wcm92aWRlcl9yZWdpb25faWQYCyABKAkSRAoNY29uZmlndXJhdGlvbhgUIAEoCzItLnFkcmFudC5jbG91ZC5jbHVzdGVyLnYxLkNsdXN0ZXJDb25maWd1cmF0aW9uEjQKBXN0YXRlGGQgASgLMiUucWRyYW50LmNsb3VkLmNsdXN0ZXIudjEuQ2x1c3RlclN0YXRlOq8DukirAxqjAQoKY2x1c3Rlci5pZBIadmFsdWUgbXVzdCBiZSBhIHZhbGlkIFVVSUQaeXRoaXMuaWQubWF0Y2hlcygnXlswLTlhLWZBLUZdezh9LVswLTlhLWZBLUZdezR9LVswLTlhLWZBLUZdezR9LVswLTlhLWZBLUZdezR9LVswLTlhLWZBLUZdezEyfSQnKSB8fCAhaGFzKHRoaXMuY3JlYXRlZF9hdCkaggIKIGNsdXN0ZXIuY2xvdWRfcHJvdmlkZXJfcmVnaW9uX2lkEkhjbG91ZF9wcm92aWRlcl9yZWdpb25faWQgbXVzdCBiZSBhIFVVSUQgaWYgY2xvdWRfcHJvdmlkZXJfaWQgaXMgJ2h5YnJpZCcakwF0aGlzLmNsb3VkX3Byb3ZpZGVyX3JlZ2lvbl9pZC5tYXRjaGVzKCdeWzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzAtOWEtZl17M30tWzA4OWFiXVswLTlhLWZdezN9LVswLTlhLWZdezEyfSQnKSB8fCB0aGlzLmNsb3VkX3Byb3ZpZGVyX2lkIT0gJ2h5YnJpZCcitQgKFENsdXN0ZXJDb25maWd1cmF0aW9uEjQKEGxhc3RfbW9kaWZpZWRfYXQYASABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEiIKD251bWJlcl9vZl9ub2RlcxgCIAEoDUIJukgGKgQYFCgBEjcKB3ZlcnNpb24YAyABKAlCJrpII3IhMh9eKHYoXGQrKVwuKFxkKylcLihcZCspfGxhdGVzdCkkEhwKCnBhY2thZ2VfaWQYBCABKAlCCLpIBXIDsAEBEk8KFGFkZGl0aW9uYWxfcmVzb3VyY2VzGAUgASgLMiwucWRyYW50LmNsb3VkLmNsdXN0ZXIudjEuQWRkaXRpb25hbFJlc291cmNlc0gAiAEBElMKFmRhdGFiYXNlX2NvbmZpZ3VyYXRpb24YByABKAsyLi5xZHJhbnQuY2xvdWQuY2x1c3Rlci52MS5EYXRhYmFzZUNvbmZpZ3VyYXRpb25IAYgBARJBCg1ub2RlX3NlbGVjdG9yGAggAygLMiAucWRyYW50LmNsb3VkLmNvbW1vbi52MS5LZXlWYWx1ZUIIukgFkgECEAoSQgoLdG9sZXJhdGlvbnMYCSADKAsyIy5xZHJhbnQuY2xvdWQuY2x1c3Rlci52MS5Ub2xlcmF0aW9uQgi6SAWSAQIQChI/Cgthbm5vdGF0aW9ucxgKIAMoCzIgLnFkcmFudC5jbG91ZC5jb21tb24udjEuS2V5VmFsdWVCCLpIBZIBAhAKEjEKGGFsbG93ZWRfaXBfc291cmNlX3JhbmdlcxgLIAMoCUIPukgMkgEJEBQiBXID8AEBEioKF3Jlc2VydmVkX2NwdV9wZXJjZW50YWdlGBQgASgNQgm6SAYqBBhQKAASLQoacmVzZXJ2ZWRfbWVtb3J5X3BlcmNlbnRhZ2UYFSABKA1CCbpIBioEGFAoABJLCghncHVfdHlwZRgWIAEoDjI0LnFkcmFudC5jbG91ZC5jbHVzdGVyLnYxLkNsdXN0ZXJDb25maWd1cmF0aW9uR3B1VHlwZUgCiAEBElcKDnJlc3RhcnRfcG9saWN5GBcgASgOMjoucWRyYW50LmNsb3VkLmNsdXN0ZXIudjEuQ2x1c3RlckNvbmZpZ3VyYXRpb25SZXN0YXJ0UG9saWN5SAOIAQESXwoScmViYWxhbmNlX3N0cmF0ZWd5GBggASgOMj4ucWRyYW50LmNsb3VkLmNsdXN0ZXIudjEuQ2x1c3RlckNvbmZpZ3VyYXRpb25SZWJhbGFuY2VTdHJhdGVneUgEiAEBQhcKFV9hZGRpdGlvbmFsX3Jlc291cmNlc0IZChdfZGF0YWJhc2VfY29uZmlndXJhdGlvbkILCglfZ3B1X3R5cGVCEQoPX3Jlc3RhcnRfcG9saWN5QhUKE19yZWJhbGFuY2Vfc3RyYXRlZ3kitQQKFURhdGFiYXNlQ29uZmlndXJhdGlvbhJRCgpjb2xsZWN0aW9uGAEgASgLMjgucWRyYW50LmNsb3VkLmNsdXN0ZXIudjEuRGF0YWJhc2VDb25maWd1cmF0aW9uQ29sbGVjdGlvbkgAiAEBEksKB3N0b3JhZ2UYAiABKAsyNS5xZHJhbnQuY2xvdWQuY2x1c3Rlci52MS5EYXRhYmFzZUNvbmZpZ3VyYXRpb25TdG9yYWdlSAGIAQESSwoHc2VydmljZRgDIAEoCzI1LnFkcmFudC5jbG91ZC5jbHVzdGVyLnYxLkRhdGFiYXNlQ29uZmlndXJhdGlvblNlcnZpY2VIAogBARJOCglsb2dfbGV2ZWwYBCABKA4yNi5xZHJhbnQuY2xvdWQuY2x1c3Rlci52MS5EYXRhYmFzZUNvbmZpZ3VyYXRpb25Mb2dMZXZlbEgDiAEBEkMKA3RscxgFIAEoCzIxLnFkcmFudC5jbG91ZC5jbHVzdGVyLnYxLkRhdGFiYXNlQ29uZmlndXJhdGlvblRsc0gEiAEBEk8KCWluZmVyZW5jZRgGIAEoCzI3LnFkcmFudC5jbG91ZC5jbHVzdGVyLnYxLkRhdGFiYXNlQ29uZmlndXJhdGlvbkluZmVyZW5jZUgFiAEBQg0KC19jb2xsZWN0aW9uQgoKCF9zdG9yYWdlQgoKCF9zZXJ2aWNlQgwKCl9sb2dfbGV2ZWxCBgoEX3Rsc0IMCgpfaW5mZXJlbmNlIs0BCh9EYXRhYmFzZUNvbmZpZ3VyYXRpb25Db2xsZWN0aW9uEh8KEnJlcGxpY2F0aW9uX2ZhY3RvchgBIAEoDUgAiAEBEiAKGHdyaXRlX2NvbnNpc3RlbmN5X2ZhY3RvchgCIAEoBRJQCgd2ZWN0b3JzGAMgASgLMj8ucWRyYW50LmNsb3VkLmNsdXN0ZXIudjEuRGF0YWJhc2VDb25maWd1cmF0aW9uQ29sbGVjdGlvblZlY3RvcnNCFQoTX3JlcGxpY2F0aW9uX2ZhY3RvciJKCiZEYXRhYmFzZUNvbmZpZ3VyYXRpb25Db2xsZWN0aW9uVmVjdG9ycxIUCgdvbl9kaXNrGAEgASgISACIAQFCCgoIX29uX2Rpc2sidQocRGF0YWJhc2VDb25maWd1cmF0aW9uU3RvcmFnZRJVCgtwZXJmb3JtYW5jZRgBIAEoCzJALnFkcmFudC5jbG91ZC5jbHVzdGVyLnYxLkRhdGFiYXNlQ29uZmlndXJhdGlvblN0b3JhZ2VQZXJmb3JtYW5jZSJdCidEYXRhYmFzZUNvbmZpZ3VyYXRpb25TdG9yYWdlUGVyZm9ybWFuY2USHAoUb3B0aW1pemVyX2NwdV9idWRnZXQYASABKAUSFAoMYXN5bmNfc2NvcmVyGAIgASgIIugBChxEYXRhYmFzZUNvbmZpZ3VyYXRpb25TZXJ2aWNlEjoKB2FwaV9rZXkYASABKAsyJC5xZHJhbnQuY2xvdWQuY29tbW9uLnYxLlNlY3JldEtleVJlZkgAiAEBEkQKEXJlYWRfb25seV9hcGlfa2V5GAIgASgLMiQucWRyYW50LmNsb3VkLmNvbW1vbi52MS5TZWNyZXRLZXlSZWZIAYgBARIQCghqd3RfcmJhYxgDIAEoCBISCgplbmFibGVfdGxzGAQgASgIQgoKCF9hcGlfa2V5QhQKEl9yZWFkX29ubHlfYXBpX2tleSKBAQoYRGF0YWJhc2VDb25maWd1cmF0aW9uVGxzEjIKBGNlcnQYASABKAsyJC5xZHJhbnQuY2xvdWQuY29tbW9uLnYxLlNlY3JldEtleVJlZhIxCgNrZXkYAiABKAsyJC5xZHJhbnQuY2xvdWQuY29tbW9uLnYxLlNlY3JldEtleVJlZiIxCh5EYXRhYmFzZUNvbmZpZ3VyYXRpb25JbmZlcmVuY2USDwoHZW5hYmxlZBgBIAEoCCIjChNBZGRpdGlvbmFsUmVzb3VyY2VzEgwKBGRpc2sYAyABKA0ivQIKClRvbGVyYXRpb24SQwoDa2V5GAEgASgJQja6SDNyMRg/Mi1eKFthLXpBLVowLTldKFstYS16QS1aMC05Xy5dKlthLXpBLVowLTldKT8pPyQSQgoIb3BlcmF0b3IYAiABKA4yKy5xZHJhbnQuY2xvdWQuY2x1c3Rlci52MS5Ub2xlcmF0aW9uT3BlcmF0b3JIAIgBARINCgV2YWx1ZRgDIAEoCRI+CgZlZmZlY3QYBCABKA4yKS5xZHJhbnQuY2xvdWQuY2x1c3Rlci52MS5Ub2xlcmF0aW9uRWZmZWN0SAGIAQESKAoSdG9sZXJhdGlvbl9zZWNvbmRzGAUgASgEQge6SAQyAigASAKIAQFCCwoJX29wZXJhdG9yQgkKB19lZmZlY3RCFQoTX3RvbGVyYXRpb25fc2Vjb25kcyKHAgoMQ2x1c3RlclN0YXRlEg8KB3ZlcnNpb24YASABKAkSEAoIbm9kZXNfdXAYAiABKA0SMAoMcmVzdGFydGVkX2F0GAMgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBINCgVwaGFzZRgEIAEoCRIOCgZyZWFzb24YBSABKAkSOgoIZW5kcG9pbnQYBiABKAsyKC5xZHJhbnQuY2xvdWQuY2x1c3Rlci52MS5DbHVzdGVyRW5kcG9pbnQSRwoJcmVzb3VyY2VzGAcgASgLMjQucWRyYW50LmNsb3VkLmNsdXN0ZXIudjEuQ2x1c3Rlck5vZGVSZXNvdXJjZXNTdW1tYXJ5Ik4KD0NsdXN0ZXJFbmRwb2ludBIVCgN1cmwYASABKAlCCLpIBXIDqAEBEhEKCXJlc3RfcG9ydBgCIAEoBRIRCglncnBjX3BvcnQYAyABKAUi0gEKG0NsdXN0ZXJOb2RlUmVzb3VyY2VzU3VtbWFyeRI7CgRkaXNrGAEgASgLMi0ucWRyYW50LmNsb3VkLmNsdXN0ZXIudjEuQ2x1c3Rlck5vZGVSZXNvdXJjZXMSOgoDcmFtGAIgASgLMi0ucWRyYW50LmNsb3VkLmNsdXN0ZXIudjEuQ2x1c3Rlck5vZGVSZXNvdXJjZXMSOgoDY3B1GAMgASgLMi0ucWRyYW50LmNsb3VkLmNsdXN0ZXIudjEuQ2x1c3Rlck5vZGVSZXNvdXJjZXMidAoUQ2x1c3Rlck5vZGVSZXNvdXJjZXMSDAoEYmFzZRgBIAEoARIVCg1jb21wbGltZW50YXJ5GAIgASgBEhIKCmFkZGl0aW9uYWwYAyABKAESEAoIcmVzZXJ2ZWQYBCABKAESEQoJYXZhaWxhYmxlGAUgASgBIokBCg1RZHJhbnRSZWxlYXNlEg8KB3ZlcnNpb24YASABKAkSDwoHZGVmYXVsdBgCIAEoCBIeChFyZWxlYXNlX25vdGVzX3VybBgDIAEoCUgAiAEBEhQKB3JlbWFya3MYBCABKAlIAYgBAUIUChJfcmVsZWFzZV9ub3Rlc191cmxCCgoIX3JlbWFya3MqoAEKG0NsdXN0ZXJDb25maWd1cmF0aW9uR3B1VHlwZRIuCipDTFVTVEVSX0NPTkZJR1VSQVRJT05fR1BVX1RZUEVfVU5TUEVDSUZJRUQQABIpCiVDTFVTVEVSX0NPTkZJR1VSQVRJT05fR1BVX1RZUEVfTlZJRElBEAESJgoiQ0xVU1RFUl9DT05GSUdVUkFUSU9OX0dQVV9UWVBFX0FNRBACKvIBCiFDbHVzdGVyQ29uZmlndXJhdGlvblJlc3RhcnRQb2xpY3kSNAowQ0xVU1RFUl9DT05GSUdVUkFUSU9OX1JFU1RBUlRfUE9MSUNZX1VOU1BFQ0lGSUVEEAASMAosQ0xVU1RFUl9DT05GSUdVUkFUSU9OX1JFU1RBUlRfUE9MSUNZX1JPTExJTkcQARIxCi1DTFVTVEVSX0NPTkZJR1VSQVRJT05fUkVTVEFSVF9QT0xJQ1lfUEFSQUxMRUwQAhIyCi5DTFVTVEVSX0NPTkZJR1VSQVRJT05fUkVTVEFSVF9QT0xJQ1lfQVVUT01BVElDEAMqjgIKJUNsdXN0ZXJDb25maWd1cmF0aW9uUmViYWxhbmNlU3RyYXRlZ3kSOAo0Q0xVU1RFUl9DT05GSUdVUkFUSU9OX1JFQkFMQU5DRV9TVFJBVEVHWV9VTlNQRUNJRklFRBAAEjUKMUNMVVNURVJfQ09ORklHVVJBVElPTl9SRUJBTEFOQ0VfU1RSQVRFR1lfQllfQ09VTlQQARI0CjBDTFVTVEVSX0NPTkZJR1VSQVRJT05fUkVCQUxBTkNFX1NUUkFURUdZX0JZX1NJWkUQAhI+CjpDTFVTVEVSX0NPTkZJR1VSQVRJT05fUkVCQUxBTkNFX1NUUkFURUdZX0JZX0NPVU5UX0FORF9TSVpFEAMq1QIKHURhdGFiYXNlQ29uZmlndXJhdGlvbkxvZ0xldmVsEjAKLERBVEFCQVNFX0NPTkZJR1VSQVRJT05fTE9HX0xFVkVMX1VOU1BFQ0lGSUVEEAASKgomREFUQUJBU0VfQ09ORklHVVJBVElPTl9MT0dfTEVWRUxfVFJBQ0UQARIqCiZEQVRBQkFTRV9DT05GSUdVUkFUSU9OX0xPR19MRVZFTF9ERUJVRxACEikKJURBVEFCQVNFX0NPTkZJR1VSQVRJT05fTE9HX0xFVkVMX0lORk8QAxIpCiVEQVRBQkFTRV9DT05GSUdVUkFUSU9OX0xPR19MRVZFTF9XQVJOEAQSKgomREFUQUJBU0VfQ09ORklHVVJBVElPTl9MT0dfTEVWRUxfRVJST1IQBRIoCiREQVRBQkFTRV9DT05GSUdVUkFUSU9OX0xPR19MRVZFTF9PRkYQBip4ChJUb2xlcmF0aW9uT3BlcmF0b3ISIwofVE9MRVJBVElPTl9PUEVSQVRPUl9VTlNQRUNJRklFRBAAEh4KGlRPTEVSQVRJT05fT1BFUkFUT1JfRVhJU1RTEAESHQoZVE9MRVJBVElPTl9PUEVSQVRPUl9FUVVBTBACKqQBChBUb2xlcmF0aW9uRWZmZWN0EiEKHVRPTEVSQVRJT05fRUZGRUNUX1VOU1BFQ0lGSUVEEAASIQodVE9MRVJBVElPTl9FRkZFQ1RfTk9fU0NIRURVTEUQARIoCiRUT0xFUkFUSU9OX0VGRkVDVF9QUkVGRVJfTk9fU0NIRURVTEUQAhIgChxUT0xFUkFUSU9OX0VGRkVDVF9OT19FWEVDVVRFEAMyrwsKDkNsdXN0ZXJTZXJ2aWNlErQBCgxMaXN0Q2x1c3RlcnMSLC5xZHJhbnQuY2xvdWQuY2x1c3Rlci52MS5MaXN0Q2x1c3RlcnNSZXF1ZXN0Gi0ucWRyYW50LmNsb3VkLmNsdXN0ZXIudjEuTGlzdENsdXN0ZXJzUmVzcG9uc2UiR4q1GA1yZWFkOmNsdXN0ZXJzgtPkkwIwEi4vYXBpL2NsdXN0ZXIvdjEvYWNjb3VudHMve2FjY291bnRfaWR9L2NsdXN0ZXJzErsBCgpHZXRDbHVzdGVyEioucWRyYW50LmNsb3VkLmNsdXN0ZXIudjEuR2V0Q2x1c3RlclJlcXVlc3QaKy5xZHJhbnQuY2xvdWQuY2x1c3Rlci52MS5HZXRDbHVzdGVyUmVzcG9uc2UiVIq1GA1yZWFkOmNsdXN0ZXJzgtPkkwI9EjsvYXBpL2NsdXN0ZXIvdjEvYWNjb3VudHMve2FjY291bnRfaWR9L2NsdXN0ZXJzL3tjbHVzdGVyX2lkfRLZAQoNQ3JlYXRlQ2x1c3RlchItLnFkcmFudC5jbG91ZC5jbHVzdGVyLnYxLkNyZWF0ZUNsdXN0ZXJSZXF1ZXN0Gi4ucWRyYW50LmNsb3VkLmNsdXN0ZXIudjEuQ3JlYXRlQ2x1c3RlclJlc3BvbnNlImmKtRgOd3JpdGU6Y2x1c3RlcnOStRgSY2x1c3Rlci5hY2NvdW50X2lkgtPkkwI7OgEqIjYvYXBpL2NsdXN0ZXIvdjEvYWNjb3VudHMve2NsdXN0ZXIuYWNjb3VudF9pZH0vY2x1c3RlcnMS5gEKDVVwZGF0ZUNsdXN0ZXISLS5xZHJhbnQuY2xvdWQuY2x1c3Rlci52MS5VcGRhdGVDbHVzdGVyUmVxdWVzdBouLnFkcmFudC5jbG91ZC5jbHVzdGVyLnYxLlVwZGF0ZUNsdXN0ZXJSZXNwb25zZSJ2irUYDndyaXRlOmNsdXN0ZXJzkrUYEmNsdXN0ZXIuYWNjb3VudF9pZILT5JMCSDoBKhpDL2FwaS9jbHVzdGVyL3YxL2FjY291bnRzL3tjbHVzdGVyLmFjY291bnRfaWR9L2NsdXN0ZXJzL3tjbHVzdGVyLmlkfRLGAQoNRGVsZXRlQ2x1c3RlchItLnFkcmFudC5jbG91ZC5jbHVzdGVyLnYxLkRlbGV0ZUNsdXN0ZXJSZXF1ZXN0Gi4ucWRyYW50LmNsb3VkLmNsdXN0ZXIudjEuRGVsZXRlQ2x1c3RlclJlc3BvbnNlIlaKtRgPZGVsZXRlOmNsdXN0ZXJzgtPkkwI9KjsvYXBpL2NsdXN0ZXIvdjEvYWNjb3VudHMve2FjY291bnRfaWR9L2NsdXN0ZXJzL3tjbHVzdGVyX2lkfRLQAQoOUmVzdGFydENsdXN0ZXISLi5xZHJhbnQuY2xvdWQuY2x1c3Rlci52MS5SZXN0YXJ0Q2x1c3RlclJlcXVlc3QaLy5xZHJhbnQuY2xvdWQuY2x1c3Rlci52MS5SZXN0YXJ0Q2x1c3RlclJlc3BvbnNlIl2KtRgOd3JpdGU6Y2x1c3RlcnOC0+STAkUiQy9hcGkvY2x1c3Rlci92MS9hY2NvdW50cy97YWNjb3VudF9pZH0vY2x1c3RlcnMve2NsdXN0ZXJfaWR9L3Jlc3RhcnQSxgEKEkxpc3RRZHJhbnRSZWxlYXNlcxIyLnFkcmFudC5jbG91ZC5jbHVzdGVyLnYxLkxpc3RRZHJhbnRSZWxlYXNlc1JlcXVlc3QaMy5xZHJhbnQuY2xvdWQuY2x1c3Rlci52MS5MaXN0UWRyYW50UmVsZWFzZXNSZXNwb25zZSJHirUYDXJlYWQ6Y2x1c3RlcnOC0+STAjASLi9hcGkvY2x1c3Rlci92MS9hY2NvdW50cy97YWNjb3VudF9pZH0vcmVsZWFzZXNC/gEKG2NvbS5xZHJhbnQuY2xvdWQuY2x1c3Rlci52MUIMQ2x1c3RlclByb3RvUAFaUmdpdGh1Yi5jb20vcWRyYW50L3FkcmFudC1jbG91ZC1wdWJsaWMtYXBpL2dlbi9nby9xZHJhbnQvY2xvdWQvY2x1c3Rlci92MTtjbHVzdGVydjGiAgNRQ0OqAhdRZHJhbnQuQ2xvdWQuQ2x1c3Rlci5WMcoCF1FkcmFudFxDbG91ZFxDbHVzdGVyXFYx4gIjUWRyYW50XENsb3VkXENsdXN0ZXJcVjFcR1BCTWV0YWRhdGHqAhpRZHJhbnQ6OkNsb3VkOjpDbHVzdGVyOjpWMWIGcHJvdG8z", [file_buf_validate_validate, file_google_api_annotations, file_google_protobuf_timestamp, file_qdrant_cloud_common_v1_common]);

/**
 * ListClustersRequest is the request for the ListClusters function
 *
 * @generated from message qdrant.cloud.cluster.v1.ListClustersRequest
 */
export type ListClustersRequest = Message<"qdrant.cloud.cluster.v1.ListClustersRequest"> & {
  /**
   * The identifier of the account (in Guid format).
   * This is a required field.
   *
   * @generated from field: string account_id = 1;
   */
  accountId: string;

  /**
   * Optional filter specifying the cloud provider where the cluster is hosted.
   * Must match one of the provider IDs returned by the `qdrant.cloud.platform.v1.PlatformService.ListCloudProviders` method.
   * If omitted, all clusters for the specified account are returned, including those hosted in hybrid cloud environments.
   *
   * @generated from field: optional string cloud_provider_id = 10;
   */
  cloudProviderId?: string;

  /**
   * Optional filter specifying the cloud provider region where the cluster is hosted.
   * Must match one of the region IDs returned by the `qdrant.cloud.platform.v1.PlatformService.ListCloudProviderRegions` method.
   * If this field is set, the `cloud_provider_id` is required to set as well (and it should match).
   * For hybrid this should be the hybrid cloud environment ID.
   *
   * @generated from field: optional string cloud_provider_region_id = 11;
   */
  cloudProviderRegionId?: string;
};

/**
 * Describes the message qdrant.cloud.cluster.v1.ListClustersRequest.
 * Use `create(ListClustersRequestSchema)` to create a new message.
 */
export const ListClustersRequestSchema: GenMessage<ListClustersRequest> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v1_cluster, 0);

/**
 * ListClustersResponse is the response from the ListClusters function
 *
 * @generated from message qdrant.cloud.cluster.v1.ListClustersResponse
 */
export type ListClustersResponse = Message<"qdrant.cloud.cluster.v1.ListClustersResponse"> & {
  /**
   * The actual clusters in this list
   *
   * @generated from field: repeated qdrant.cloud.cluster.v1.Cluster items = 1;
   */
  items: Cluster[];
};

/**
 * Describes the message qdrant.cloud.cluster.v1.ListClustersResponse.
 * Use `create(ListClustersResponseSchema)` to create a new message.
 */
export const ListClustersResponseSchema: GenMessage<ListClustersResponse> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v1_cluster, 1);

/**
 * GetClusterRequest is the request for the GetCluster function
 *
 * @generated from message qdrant.cloud.cluster.v1.GetClusterRequest
 */
export type GetClusterRequest = Message<"qdrant.cloud.cluster.v1.GetClusterRequest"> & {
  /**
   * The identifier of the account (in Guid format).
   * This is a required field.
   *
   * @generated from field: string account_id = 1;
   */
  accountId: string;

  /**
   * The identifier for the cluster (in Guid format).
   * This cluster should be part of the provided account.
   * This is a required field.
   *
   * @generated from field: string cluster_id = 2;
   */
  clusterId: string;
};

/**
 * Describes the message qdrant.cloud.cluster.v1.GetClusterRequest.
 * Use `create(GetClusterRequestSchema)` to create a new message.
 */
export const GetClusterRequestSchema: GenMessage<GetClusterRequest> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v1_cluster, 2);

/**
 * GetClusterResponse is the response from the GetCluster function
 *
 * @generated from message qdrant.cloud.cluster.v1.GetClusterResponse
 */
export type GetClusterResponse = Message<"qdrant.cloud.cluster.v1.GetClusterResponse"> & {
  /**
   * The actual cluster
   *
   * @generated from field: qdrant.cloud.cluster.v1.Cluster cluster = 1;
   */
  cluster?: Cluster;
};

/**
 * Describes the message qdrant.cloud.cluster.v1.GetClusterResponse.
 * Use `create(GetClusterResponseSchema)` to create a new message.
 */
export const GetClusterResponseSchema: GenMessage<GetClusterResponse> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v1_cluster, 3);

/**
 * CreateClusterRequest is the request for the CreateCluster function
 *
 * @generated from message qdrant.cloud.cluster.v1.CreateClusterRequest
 */
export type CreateClusterRequest = Message<"qdrant.cloud.cluster.v1.CreateClusterRequest"> & {
  /**
   * The actual cluster
   *
   * @generated from field: qdrant.cloud.cluster.v1.Cluster cluster = 1;
   */
  cluster?: Cluster;
};

/**
 * Describes the message qdrant.cloud.cluster.v1.CreateClusterRequest.
 * Use `create(CreateClusterRequestSchema)` to create a new message.
 */
export const CreateClusterRequestSchema: GenMessage<CreateClusterRequest> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v1_cluster, 4);

/**
 * CreateClusterResponse is the response from the CreateCluster function
 *
 * @generated from message qdrant.cloud.cluster.v1.CreateClusterResponse
 */
export type CreateClusterResponse = Message<"qdrant.cloud.cluster.v1.CreateClusterResponse"> & {
  /**
   * The actual cluster
   *
   * @generated from field: qdrant.cloud.cluster.v1.Cluster cluster = 1;
   */
  cluster?: Cluster;
};

/**
 * Describes the message qdrant.cloud.cluster.v1.CreateClusterResponse.
 * Use `create(CreateClusterResponseSchema)` to create a new message.
 */
export const CreateClusterResponseSchema: GenMessage<CreateClusterResponse> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v1_cluster, 5);

/**
 * UpdateClusterRequest is the request for the UpdateCluster function
 *
 * @generated from message qdrant.cloud.cluster.v1.UpdateClusterRequest
 */
export type UpdateClusterRequest = Message<"qdrant.cloud.cluster.v1.UpdateClusterRequest"> & {
  /**
   * The actual cluster
   *
   * @generated from field: qdrant.cloud.cluster.v1.Cluster cluster = 1;
   */
  cluster?: Cluster;
};

/**
 * Describes the message qdrant.cloud.cluster.v1.UpdateClusterRequest.
 * Use `create(UpdateClusterRequestSchema)` to create a new message.
 */
export const UpdateClusterRequestSchema: GenMessage<UpdateClusterRequest> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v1_cluster, 6);

/**
 * UpdateClusterResponse is the response from the UpdateCluster function
 *
 * @generated from message qdrant.cloud.cluster.v1.UpdateClusterResponse
 */
export type UpdateClusterResponse = Message<"qdrant.cloud.cluster.v1.UpdateClusterResponse"> & {
  /**
   * The actual cluster
   *
   * @generated from field: qdrant.cloud.cluster.v1.Cluster cluster = 1;
   */
  cluster?: Cluster;
};

/**
 * Describes the message qdrant.cloud.cluster.v1.UpdateClusterResponse.
 * Use `create(UpdateClusterResponseSchema)` to create a new message.
 */
export const UpdateClusterResponseSchema: GenMessage<UpdateClusterResponse> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v1_cluster, 7);

/**
 * DeleteClusterRequest is the request for the DeleteCluster function
 *
 * @generated from message qdrant.cloud.cluster.v1.DeleteClusterRequest
 */
export type DeleteClusterRequest = Message<"qdrant.cloud.cluster.v1.DeleteClusterRequest"> & {
  /**
   * The identifier of the account (in Guid format).
   * This is a required field.
   *
   * @generated from field: string account_id = 1;
   */
  accountId: string;

  /**
   * The identifier for the cluster (in Guid format).
   * This cluster should be part of the provided account.
   * This is a required field.
   *
   * @generated from field: string cluster_id = 2;
   */
  clusterId: string;

  /**
   * If set, the backups of this cluster will be deleted as well.
   *
   * @generated from field: optional bool delete_backups = 3;
   */
  deleteBackups?: boolean;
};

/**
 * Describes the message qdrant.cloud.cluster.v1.DeleteClusterRequest.
 * Use `create(DeleteClusterRequestSchema)` to create a new message.
 */
export const DeleteClusterRequestSchema: GenMessage<DeleteClusterRequest> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v1_cluster, 8);

/**
 * DeleteClusterResponse is the response from the DeleteCluster function
 *
 * Empty
 *
 * @generated from message qdrant.cloud.cluster.v1.DeleteClusterResponse
 */
export type DeleteClusterResponse = Message<"qdrant.cloud.cluster.v1.DeleteClusterResponse"> & {
};

/**
 * Describes the message qdrant.cloud.cluster.v1.DeleteClusterResponse.
 * Use `create(DeleteClusterResponseSchema)` to create a new message.
 */
export const DeleteClusterResponseSchema: GenMessage<DeleteClusterResponse> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v1_cluster, 9);

/**
 * RestartClusterRequest is the request for the RestartCluster function
 *
 * @generated from message qdrant.cloud.cluster.v1.RestartClusterRequest
 */
export type RestartClusterRequest = Message<"qdrant.cloud.cluster.v1.RestartClusterRequest"> & {
  /**
   * The identifier of the account (in Guid format).
   * This is a required field.
   *
   * @generated from field: string account_id = 1;
   */
  accountId: string;

  /**
   * The identifier for the cluster (in Guid format).
   * This cluster should be part of the provided account.
   * This is a required field.
   *
   * @generated from field: string cluster_id = 2;
   */
  clusterId: string;
};

/**
 * Describes the message qdrant.cloud.cluster.v1.RestartClusterRequest.
 * Use `create(RestartClusterRequestSchema)` to create a new message.
 */
export const RestartClusterRequestSchema: GenMessage<RestartClusterRequest> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v1_cluster, 10);

/**
 * RestartClusterResponse is the response from the RestartCluster function
 *
 * Empty
 *
 * @generated from message qdrant.cloud.cluster.v1.RestartClusterResponse
 */
export type RestartClusterResponse = Message<"qdrant.cloud.cluster.v1.RestartClusterResponse"> & {
};

/**
 * Describes the message qdrant.cloud.cluster.v1.RestartClusterResponse.
 * Use `create(RestartClusterResponseSchema)` to create a new message.
 */
export const RestartClusterResponseSchema: GenMessage<RestartClusterResponse> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v1_cluster, 11);

/**
 * ListQdrantReleasesRequest is the request for the ListQdrantReleases function
 *
 * @generated from message qdrant.cloud.cluster.v1.ListQdrantReleasesRequest
 */
export type ListQdrantReleasesRequest = Message<"qdrant.cloud.cluster.v1.ListQdrantReleasesRequest"> & {
  /**
   * The identifier of the account (in Guid format).
   * This is a required field.
   *
   * @generated from field: string account_id = 1;
   */
  accountId: string;

  /**
   * The identifier for the cluster (in Guid format).
   * This cluster should be part of the provided account.
   * This is an optional field.
   *
   * @generated from field: optional string cluster_id = 2;
   */
  clusterId?: string;
};

/**
 * Describes the message qdrant.cloud.cluster.v1.ListQdrantReleasesRequest.
 * Use `create(ListQdrantReleasesRequestSchema)` to create a new message.
 */
export const ListQdrantReleasesRequestSchema: GenMessage<ListQdrantReleasesRequest> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v1_cluster, 12);

/**
 * ListQdrantReleasesResponse is the response from the ListQdrantReleases function
 *
 * @generated from message qdrant.cloud.cluster.v1.ListQdrantReleasesResponse
 */
export type ListQdrantReleasesResponse = Message<"qdrant.cloud.cluster.v1.ListQdrantReleasesResponse"> & {
  /**
   * The actual Qdrant releases in this list
   *
   * @generated from field: repeated qdrant.cloud.cluster.v1.QdrantRelease items = 1;
   */
  items: QdrantRelease[];
};

/**
 * Describes the message qdrant.cloud.cluster.v1.ListQdrantReleasesResponse.
 * Use `create(ListQdrantReleasesResponseSchema)` to create a new message.
 */
export const ListQdrantReleasesResponseSchema: GenMessage<ListQdrantReleasesResponse> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v1_cluster, 13);

/**
 * A Cluster represents one cluster of a Qdrant database.
 *
 * @generated from message qdrant.cloud.cluster.v1.Cluster
 */
export type Cluster = Message<"qdrant.cloud.cluster.v1.Cluster"> & {
  /**
   * Unique identifier for the cluster (in Guid format).
   * This is a read-only field and will be available after a cluster is created.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * Timestamp when the cluster was created.
   * This is a read-only field and will be available after a cluster is created.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 2;
   */
  createdAt?: Timestamp;

  /**
   * Identifier of the account associated with the cluster (in Guid format).
   * This is a required field.
   *
   * @generated from field: string account_id = 3;
   */
  accountId: string;

  /**
   * Name of the cluster.
   * This is a required field.
   * Name can only contain letters, numbers, underscores and dashes
   *
   * @generated from field: string name = 4;
   */
  name: string;

  /**
   * Timestamp when the cluster was deleted (or is started to be deleting).
   * This is a read-only field and will be set after DeleteCluster is called.
   *
   * @generated from field: google.protobuf.Timestamp deleted_at = 5;
   */
  deletedAt?: Timestamp;

  /**
   * Cloud provider where the cluster is hosted.
   * Must match one of the provider IDs returned by the `qdrant.cloud.platform.v1.PlatformService.ListCloudProviders` method.
   * After creation, this field cannot be changed.
   *
   * @generated from field: string cloud_provider_id = 10;
   */
  cloudProviderId: string;

  /**
   * Cloud provider region where the cluster is hosted.
   * Must match one of the region IDs returned by the `qdrant.cloud.platform.v1.PlatformService.ListCloudProviderRegions` method.
   * For hybrid this should be the hybrid cloud environment ID.
   * This is a required field.
   * After creation, this field cannot be changed.
   *
   * @generated from field: string cloud_provider_region_id = 11;
   */
  cloudProviderRegionId: string;

  /**
   * Current configuration details of the cluster.
   *
   * @generated from field: qdrant.cloud.cluster.v1.ClusterConfiguration configuration = 20;
   */
  configuration?: ClusterConfiguration;

  /**
   * Current state of the cluster.
   * All fields inside `state` are read-only.
   *
   * @generated from field: qdrant.cloud.cluster.v1.ClusterState state = 100;
   */
  state?: ClusterState;
};

/**
 * Describes the message qdrant.cloud.cluster.v1.Cluster.
 * Use `create(ClusterSchema)` to create a new message.
 */
export const ClusterSchema: GenMessage<Cluster> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v1_cluster, 14);

/**
 * A ClusterConfiguration represents the configuration of a cluster.
 *
 * @generated from message qdrant.cloud.cluster.v1.ClusterConfiguration
 */
export type ClusterConfiguration = Message<"qdrant.cloud.cluster.v1.ClusterConfiguration"> & {
  /**
   * Timestamp when the cluster configuration was last updated.
   * This is a read-only field and will be available after a cluster is created.
   *
   * @generated from field: google.protobuf.Timestamp last_modified_at = 1;
   */
  lastModifiedAt?: Timestamp;

  /**
   * The number of nodes in a cluster.
   * This should be a number 1...20 [both included].
   *
   * @generated from field: uint32 number_of_nodes = 2;
   */
  numberOfNodes: number;

  /**
   * Version of the cluster software.
   * If omitted the latest version will be used and filled out during create.
   * Use ListReleases() to determine which versions are allowed to be used.
   * See upgrade guidelines for more info.
   *
   * @generated from field: string version = 3;
   */
  version: string;

  /**
   * TODO: Needing a package_id here is very bad usability for users.
   * That means we would need to start documenting all package_ids somewhere.
   * Rather we should introduce speaking package names in the public api (even if we have them different internally).
   * In the price list we already have them kind of 'https://docs.google.com/spreadsheets/d/1dDo1u6YExocd2MJfi_Xgjnret2vJqo84S-9-gcOltkc/edit?gid=0#gid=0'
   * We could derive them from the SKU, e.g. QN_16x128 fine with something else as well.
   * The package identifier used to configure the resources of the cluster. Use ListPackages() to select one.
   *
   * @generated from field: string package_id = 4;
   */
  packageId: string;

  /**
   * The additional resources on top of the selected package.
   * This is an optional field, if not specified all additional resources are 0.
   *
   * @generated from field: optional qdrant.cloud.cluster.v1.AdditionalResources additional_resources = 5;
   */
  additionalResources?: AdditionalResources;

  /**
   * Configuration to setup a qdrant database in a hybrid cloud.
   * It is ignored for managed cloud clusters. This is an optional field
   *
   * @generated from field: optional qdrant.cloud.cluster.v1.DatabaseConfiguration database_configuration = 7;
   */
  databaseConfiguration?: DatabaseConfiguration;

  /**
   * The node selector for this cluster in a hybrid cloud.
   * It is ignored for managed cloud clusters. This is an optional field
   *
   * @generated from field: repeated qdrant.cloud.common.v1.KeyValue node_selector = 8;
   */
  nodeSelector: KeyValue[];

  /**
   * List of tolerations for this cluster in a hybrid cloud.
   * It is ignored for managed cloud clusters. This is an optional field
   *
   * @generated from field: repeated qdrant.cloud.cluster.v1.Toleration tolerations = 9;
   */
  tolerations: Toleration[];

  /**
   * List of annotations for this cluster in a hybrid cloud.
   * It is ignored for managed cloud clusters. This is an optional field
   *
   * @generated from field: repeated qdrant.cloud.common.v1.KeyValue annotations = 10;
   */
  annotations: KeyValue[];

  /**
   * List of allowed IP source ranges for this cluster.
   * Field is used for both managed cloud and hybrid cloud and clusters. This is an optional field
   * The CIDRs supports IPv4 only.
   *
   * @generated from field: repeated string allowed_ip_source_ranges = 11;
   */
  allowedIpSourceRanges: string[];

  /**
   * The percentage of CPU resources reserved for system components
   * This is an optional field, default is 0.
   * Number between 0..80
   *
   * @generated from field: uint32 reserved_cpu_percentage = 20;
   */
  reservedCpuPercentage: number;

  /**
   * The percentage of RAM resources reserved for system components
   * This is an optional field, default is 0.
   * Number between 0..80
   *
   * @generated from field: uint32 reserved_memory_percentage = 21;
   */
  reservedMemoryPercentage: number;

  /**
   * The gpu type that should be used for the database
   * This is an optional field, default is No configured GPU
   *
   * @generated from field: optional qdrant.cloud.cluster.v1.ClusterConfigurationGpuType gpu_type = 22;
   */
  gpuType?: ClusterConfigurationGpuType;

  /**
   * The restart policy for the database
   * This is an optional field, default is Automatic
   *
   * @generated from field: optional qdrant.cloud.cluster.v1.ClusterConfigurationRestartPolicy restart_policy = 23;
   */
  restartPolicy?: ClusterConfigurationRestartPolicy;

  /**
   * The automatic shard rebalancing strategy for the database
   * This is an optional field, default is none
   *
   * @generated from field: optional qdrant.cloud.cluster.v1.ClusterConfigurationRebalanceStrategy rebalance_strategy = 24;
   */
  rebalanceStrategy?: ClusterConfigurationRebalanceStrategy;
};

/**
 * Describes the message qdrant.cloud.cluster.v1.ClusterConfiguration.
 * Use `create(ClusterConfigurationSchema)` to create a new message.
 */
export const ClusterConfigurationSchema: GenMessage<ClusterConfiguration> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v1_cluster, 15);

/**
 * Configuration to setup a Qdrant database in a hybrid cloud.
 * All settings apply to hybrid cloud only.
 *
 * @generated from message qdrant.cloud.cluster.v1.DatabaseConfiguration
 */
export type DatabaseConfiguration = Message<"qdrant.cloud.cluster.v1.DatabaseConfiguration"> & {
  /**
   * The default Qdrant database collection configuration
   * This is an optional field
   *
   * @generated from field: optional qdrant.cloud.cluster.v1.DatabaseConfigurationCollection collection = 1;
   */
  collection?: DatabaseConfigurationCollection;

  /**
   * The default Qdrant database storage configuration
   * This is an optional field
   *
   * @generated from field: optional qdrant.cloud.cluster.v1.DatabaseConfigurationStorage storage = 2;
   */
  storage?: DatabaseConfigurationStorage;

  /**
   * The Qdrant database service configuration
   * This is an optional field
   *
   * @generated from field: optional qdrant.cloud.cluster.v1.DatabaseConfigurationService service = 3;
   */
  service?: DatabaseConfigurationService;

  /**
   * The log level for the database
   * This is an optional field, default is Info.
   * Qdrant is written in Rust and is using: https://docs.rs/log/latest/log/enum.LevelFilter.html
   *
   * @generated from field: optional qdrant.cloud.cluster.v1.DatabaseConfigurationLogLevel log_level = 4;
   */
  logLevel?: DatabaseConfigurationLogLevel;

  /**
   * The Qdrant database TLS configuration
   * This is an optional field, if not set an unsecure connection is provided
   *
   * @generated from field: optional qdrant.cloud.cluster.v1.DatabaseConfigurationTls tls = 5;
   */
  tls?: DatabaseConfigurationTls;

  /**
   * The Qdrant database inference configuration
   * This is an optional field, if unset, the database is not configured for cloud inferencing
   *
   * @generated from field: optional qdrant.cloud.cluster.v1.DatabaseConfigurationInference inference = 6;
   */
  inference?: DatabaseConfigurationInference;
};

/**
 * Describes the message qdrant.cloud.cluster.v1.DatabaseConfiguration.
 * Use `create(DatabaseConfigurationSchema)` to create a new message.
 */
export const DatabaseConfigurationSchema: GenMessage<DatabaseConfiguration> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v1_cluster, 16);

/**
 * The default Qdrant database collection configuration
 *
 * @generated from message qdrant.cloud.cluster.v1.DatabaseConfigurationCollection
 */
export type DatabaseConfigurationCollection = Message<"qdrant.cloud.cluster.v1.DatabaseConfigurationCollection"> & {
  /**
   * Number of replicas of each shard that network tries to maintain
   * This is an optional, the default is 1
   *
   * @generated from field: optional uint32 replication_factor = 1;
   */
  replicationFactor?: number;

  /**
   * How many replicas should apply the operation for us to consider it successful
   * This is an optional, the default is 1
   *
   * @generated from field: int32 write_consistency_factor = 2;
   */
  writeConsistencyFactor: number;

  /**
   * The default parameters for vectors.
   *
   * @generated from field: qdrant.cloud.cluster.v1.DatabaseConfigurationCollectionVectors vectors = 3;
   */
  vectors?: DatabaseConfigurationCollectionVectors;
};

/**
 * Describes the message qdrant.cloud.cluster.v1.DatabaseConfigurationCollection.
 * Use `create(DatabaseConfigurationCollectionSchema)` to create a new message.
 */
export const DatabaseConfigurationCollectionSchema: GenMessage<DatabaseConfigurationCollection> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v1_cluster, 17);

/**
 * The default Qdrant database collection vectors configuration
 *
 * @generated from message qdrant.cloud.cluster.v1.DatabaseConfigurationCollectionVectors
 */
export type DatabaseConfigurationCollectionVectors = Message<"qdrant.cloud.cluster.v1.DatabaseConfigurationCollectionVectors"> & {
  /**
   * If set, this will create a collection with all vectors immediately stored in memmap storage.
   * This is the recommended way, in case your Qdrant instance operates with fast disks and you are working with large collections.
   * For more info see: https://qdrant.tech/documentation/concepts/storage/#configuring-memmap-storage
   * This is an optional field, the default value will be true.
   *
   * @generated from field: optional bool on_disk = 1;
   */
  onDisk?: boolean;
};

/**
 * Describes the message qdrant.cloud.cluster.v1.DatabaseConfigurationCollectionVectors.
 * Use `create(DatabaseConfigurationCollectionVectorsSchema)` to create a new message.
 */
export const DatabaseConfigurationCollectionVectorsSchema: GenMessage<DatabaseConfigurationCollectionVectors> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v1_cluster, 18);

/**
 * The Qdrant storage configuration
 *
 * @generated from message qdrant.cloud.cluster.v1.DatabaseConfigurationStorage
 */
export type DatabaseConfigurationStorage = Message<"qdrant.cloud.cluster.v1.DatabaseConfigurationStorage"> & {
  /**
   * The performance related Qdrant database storage configuration
   *
   * @generated from field: qdrant.cloud.cluster.v1.DatabaseConfigurationStoragePerformance performance = 1;
   */
  performance?: DatabaseConfigurationStoragePerformance;
};

/**
 * Describes the message qdrant.cloud.cluster.v1.DatabaseConfigurationStorage.
 * Use `create(DatabaseConfigurationStorageSchema)` to create a new message.
 */
export const DatabaseConfigurationStorageSchema: GenMessage<DatabaseConfigurationStorage> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v1_cluster, 19);

/**
 * The performance related Qdrant database storage configuration
 *
 * @generated from message qdrant.cloud.cluster.v1.DatabaseConfigurationStoragePerformance
 */
export type DatabaseConfigurationStoragePerformance = Message<"qdrant.cloud.cluster.v1.DatabaseConfigurationStoragePerformance"> & {
  /**
   * CPU budget, how many CPUs (threads) to allocate for an optimization job.
   * If 0 - auto selection, keep 1 or more CPUs unallocated depending on CPU size
   * If negative - subtract this number of CPUs from the available CPUs.
   * If positive - use this exact number of CPUs.
   *
   * @generated from field: int32 optimizer_cpu_budget = 1;
   */
  optimizerCpuBudget: number;

  /**
   * Enable async scorer which uses io_uring when rescoring.
   * Only supported on Linux, must be enabled in your kernel.
   * See: https://qdrant.tech/articles/io_uring/#and-what-about-qdrant
   *
   * @generated from field: bool async_scorer = 2;
   */
  asyncScorer: boolean;
};

/**
 * Describes the message qdrant.cloud.cluster.v1.DatabaseConfigurationStoragePerformance.
 * Use `create(DatabaseConfigurationStoragePerformanceSchema)` to create a new message.
 */
export const DatabaseConfigurationStoragePerformanceSchema: GenMessage<DatabaseConfigurationStoragePerformance> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v1_cluster, 20);

/**
 * The Qdrant database service configuration
 *
 * @generated from message qdrant.cloud.cluster.v1.DatabaseConfigurationService
 */
export type DatabaseConfigurationService = Message<"qdrant.cloud.cluster.v1.DatabaseConfigurationService"> & {
  /**
   * Set an api-key.
   * If set, all requests must include a header with the api-key.
   * example header: `api-key: <API-KEY>`
   *
   * @generated from field: optional qdrant.cloud.common.v1.SecretKeyRef api_key = 1;
   */
  apiKey?: SecretKeyRef;

  /**
   * Set an api-key for read-only operations.
   * If set, all requests must include a header with the api-key.
   * example header: `api-key: <API-KEY>`
   *
   * @generated from field: optional qdrant.cloud.common.v1.SecretKeyRef read_only_api_key = 2;
   */
  readOnlyApiKey?: SecretKeyRef;

  /**
   * Enable JWT Role Based Access Control (RBAC).
   * If enabled, you can generate JWT tokens with fine-grained rules for access control.
   * Use generated token instead of API key.
   *
   * @generated from field: bool jwt_rbac = 3;
   */
  jwtRbac: boolean;

  /**
   * Enable HTTPS for the REST and gRPC API
   *
   * @generated from field: bool enable_tls = 4;
   */
  enableTls: boolean;
};

/**
 * Describes the message qdrant.cloud.cluster.v1.DatabaseConfigurationService.
 * Use `create(DatabaseConfigurationServiceSchema)` to create a new message.
 */
export const DatabaseConfigurationServiceSchema: GenMessage<DatabaseConfigurationService> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v1_cluster, 21);

/**
 * DatabaseConfigurationTls contains the information to setup a TLS connection to the database endpoint
 *
 * @generated from message qdrant.cloud.cluster.v1.DatabaseConfigurationTls
 */
export type DatabaseConfigurationTls = Message<"qdrant.cloud.cluster.v1.DatabaseConfigurationTls"> & {
  /**
   * Secret to use for the certificate
   *
   * @generated from field: qdrant.cloud.common.v1.SecretKeyRef cert = 1;
   */
  cert?: SecretKeyRef;

  /**
   * Secret to use for the private key
   *
   * @generated from field: qdrant.cloud.common.v1.SecretKeyRef key = 2;
   */
  key?: SecretKeyRef;
};

/**
 * Describes the message qdrant.cloud.cluster.v1.DatabaseConfigurationTls.
 * Use `create(DatabaseConfigurationTlsSchema)` to create a new message.
 */
export const DatabaseConfigurationTlsSchema: GenMessage<DatabaseConfigurationTls> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v1_cluster, 22);

/**
 * DatabaseConfigurationInference contains cloud inferencing configuration
 *
 * @generated from message qdrant.cloud.cluster.v1.DatabaseConfigurationInference
 */
export type DatabaseConfigurationInference = Message<"qdrant.cloud.cluster.v1.DatabaseConfigurationInference"> & {
  /**
   * If true, the database is configured to use cloud inferencing
   *
   * @generated from field: bool enabled = 1;
   */
  enabled: boolean;
};

/**
 * Describes the message qdrant.cloud.cluster.v1.DatabaseConfigurationInference.
 * Use `create(DatabaseConfigurationInferenceSchema)` to create a new message.
 */
export const DatabaseConfigurationInferenceSchema: GenMessage<DatabaseConfigurationInference> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v1_cluster, 23);

/**
 * AdditionalResources contains the information about additional resources
 *
 * @generated from message qdrant.cloud.cluster.v1.AdditionalResources
 */
export type AdditionalResources = Message<"qdrant.cloud.cluster.v1.AdditionalResources"> & {
  /**
   * Additional Disk (expressed in Gib)
   *
   * @generated from field: uint32 disk = 3;
   */
  disk: number;
};

/**
 * Describes the message qdrant.cloud.cluster.v1.AdditionalResources.
 * Use `create(AdditionalResourcesSchema)` to create a new message.
 */
export const AdditionalResourcesSchema: GenMessage<AdditionalResources> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v1_cluster, 24);

/**
 * The Toleration message represents a toleration object for Kubernetes.
 *
 * @generated from message qdrant.cloud.cluster.v1.Toleration
 */
export type Toleration = Message<"qdrant.cloud.cluster.v1.Toleration"> & {
  /**
   * The key to match against the key of a node label.
   *
   * @generated from field: string key = 1;
   */
  key: string;

  /**
   * The operator represents a key's relationship to the value.
   * The default is TOLERATION_OPERATOR_EXISTS.
   *
   * @generated from field: optional qdrant.cloud.cluster.v1.TolerationOperator operator = 2;
   */
  operator?: TolerationOperator;

  /**
   * The value to match against the value of a node label.
   *
   * @generated from field: string value = 3;
   */
  value: string;

  /**
   * The effect indicates the taint effect to match.
   * The default is TOLERATION_EFFECT_NO_SCHEDULE.
   *
   * @generated from field: optional qdrant.cloud.cluster.v1.TolerationEffect effect = 4;
   */
  effect?: TolerationEffect;

  /**
   * The toleration seconds indicates the duration to tolerate the taint.
   *
   * @generated from field: optional uint64 toleration_seconds = 5;
   */
  tolerationSeconds?: bigint;
};

/**
 * Describes the message qdrant.cloud.cluster.v1.Toleration.
 * Use `create(TolerationSchema)` to create a new message.
 */
export const TolerationSchema: GenMessage<Toleration> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v1_cluster, 25);

/**
 * ClusterState represents the current state of a cluster
 * All fields in this message are read-only.
 *
 * @generated from message qdrant.cloud.cluster.v1.ClusterState
 */
export type ClusterState = Message<"qdrant.cloud.cluster.v1.ClusterState"> & {
  /**
   * Version of the cluster software
   *
   * @generated from field: string version = 1;
   */
  version: string;

  /**
   * Number of cluster nodes that are up and running
   *
   * @generated from field: uint32 nodes_up = 2;
   */
  nodesUp: number;

  /**
   * The date and time when the cluster was restarted
   *
   * @generated from field: google.protobuf.Timestamp restarted_at = 3;
   */
  restartedAt?: Timestamp;

  /**
   * Current phase of the cluster
   * One of the following: Creating, ...
   *
   * @generated from field: string phase = 4;
   */
  phase: string;

  /**
   * Reason for the current phase of the cluster.
   *
   * @generated from field: string reason = 5;
   */
  reason: string;

  /**
   * Endpoint information to access the qdrant cluster (aka database).
   *
   * @generated from field: qdrant.cloud.cluster.v1.ClusterEndpoint endpoint = 6;
   */
  endpoint?: ClusterEndpoint;

  /**
   * The resources used by the cluster per node.
   * For the complete cluster you have to multiply by cluster.configuration.number_of_nodes
   *
   * @generated from field: qdrant.cloud.cluster.v1.ClusterNodeResourcesSummary resources = 7;
   */
  resources?: ClusterNodeResourcesSummary;
};

/**
 * Describes the message qdrant.cloud.cluster.v1.ClusterState.
 * Use `create(ClusterStateSchema)` to create a new message.
 */
export const ClusterStateSchema: GenMessage<ClusterState> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v1_cluster, 26);

/**
 * Endpoint information to access the qdrant cluster (aka database).
 * All fields in this message are a read-only field.
 *
 * @generated from message qdrant.cloud.cluster.v1.ClusterEndpoint
 */
export type ClusterEndpoint = Message<"qdrant.cloud.cluster.v1.ClusterEndpoint"> & {
  /**
   * URL to access the qdrant cluster (aka database) without port
   *
   * @generated from field: string url = 1;
   */
  url: string;

  /**
   * The port to use for HTTP REST calls (6333)
   *
   * @generated from field: int32 rest_port = 2;
   */
  restPort: number;

  /**
   * The port to use for gRPC calls (6334)
   *
   * @generated from field: int32 grpc_port = 3;
   */
  grpcPort: number;
};

/**
 * Describes the message qdrant.cloud.cluster.v1.ClusterEndpoint.
 * Use `create(ClusterEndpointSchema)` to create a new message.
 */
export const ClusterEndpointSchema: GenMessage<ClusterEndpoint> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v1_cluster, 27);

/**
 * ClusterNodeResourcesSummary represents the resources used in this cluster per node.
 *
 * @generated from message qdrant.cloud.cluster.v1.ClusterNodeResourcesSummary
 */
export type ClusterNodeResourcesSummary = Message<"qdrant.cloud.cluster.v1.ClusterNodeResourcesSummary"> & {
  /**
   * Disk resources
   *
   * @generated from field: qdrant.cloud.cluster.v1.ClusterNodeResources disk = 1;
   */
  disk?: ClusterNodeResources;

  /**
   * Memory resources
   *
   * @generated from field: qdrant.cloud.cluster.v1.ClusterNodeResources ram = 2;
   */
  ram?: ClusterNodeResources;

  /**
   * CPU resources
   *
   * @generated from field: qdrant.cloud.cluster.v1.ClusterNodeResources cpu = 3;
   */
  cpu?: ClusterNodeResources;
};

/**
 * Describes the message qdrant.cloud.cluster.v1.ClusterNodeResourcesSummary.
 * Use `create(ClusterNodeResourcesSummarySchema)` to create a new message.
 */
export const ClusterNodeResourcesSummarySchema: GenMessage<ClusterNodeResourcesSummary> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v1_cluster, 28);

/**
 * ClusterNodeResources represents the allocation of various resources for a cluster per node.
 *
 * @generated from message qdrant.cloud.cluster.v1.ClusterNodeResources
 */
export type ClusterNodeResources = Message<"qdrant.cloud.cluster.v1.ClusterNodeResources"> & {
  /**
   * Base resources that are part of the standard allocation for the cluster per node.
   * This includes default CPU, memory, storage, etc.
   *
   * @generated from field: double base = 1;
   */
  base: number;

  /**
   * Complimentary resources provided to the cluster at no additional cost.
   * This might include complimentary network bandwidth, credits, etc.
   *
   * @generated from field: double complimentary = 2;
   */
  complimentary: number;

  /**
   * Additional resources allocated to the cluster.
   * This could include additional storage, compute power, etc.
   *
   * @generated from field: double additional = 3;
   */
  additional: number;

  /**
   * The reserved is the amount used by the system, which cannot be used by the database itself.
   *
   * @generated from field: double reserved = 4;
   */
  reserved: number;

  /**
   * The available is the total (base+complimentary+additional) - reserved
   *
   * @generated from field: double available = 5;
   */
  available: number;
};

/**
 * Describes the message qdrant.cloud.cluster.v1.ClusterNodeResources.
 * Use `create(ClusterNodeResourcesSchema)` to create a new message.
 */
export const ClusterNodeResourcesSchema: GenMessage<ClusterNodeResources> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v1_cluster, 29);

/**
 * QdrantRelease represent a single Qdrant release
 *
 * @generated from message qdrant.cloud.cluster.v1.QdrantRelease
 */
export type QdrantRelease = Message<"qdrant.cloud.cluster.v1.QdrantRelease"> & {
  /**
   * Version of the Qdrant release
   *
   * @generated from field: string version = 1;
   */
  version: string;

  /**
   * Flag to indicate if this is the default release
   * There can be at most a single item in the list that have this property set.
   *
   * @generated from field: bool default = 2;
   */
  default: boolean;

  /**
   * URL to the release notes
   *
   * @generated from field: optional string release_notes_url = 3;
   */
  releaseNotesUrl?: string;

  /**
   * Additional message regarding this release that might be useful to the client"
   *
   * @generated from field: optional string remarks = 4;
   */
  remarks?: string;
};

/**
 * Describes the message qdrant.cloud.cluster.v1.QdrantRelease.
 * Use `create(QdrantReleaseSchema)` to create a new message.
 */
export const QdrantReleaseSchema: GenMessage<QdrantRelease> = /*@__PURE__*/
  messageDesc(file_qdrant_cloud_cluster_v1_cluster, 30);

/**
 * ClusterConfigurationGpuType defines GPU types available for clusters.
 *
 * @generated from enum qdrant.cloud.cluster.v1.ClusterConfigurationGpuType
 */
export enum ClusterConfigurationGpuType {
  /**
   * No GPU is configured.
   *
   * @generated from enum value: CLUSTER_CONFIGURATION_GPU_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Use an NVIDIA GPU.
   *
   * @generated from enum value: CLUSTER_CONFIGURATION_GPU_TYPE_NVIDIA = 1;
   */
  NVIDIA = 1,

  /**
   * Use an AMD GPU.
   *
   * @generated from enum value: CLUSTER_CONFIGURATION_GPU_TYPE_AMD = 2;
   */
  AMD = 2,
}

/**
 * Describes the enum qdrant.cloud.cluster.v1.ClusterConfigurationGpuType.
 */
export const ClusterConfigurationGpuTypeSchema: GenEnum<ClusterConfigurationGpuType> = /*@__PURE__*/
  enumDesc(file_qdrant_cloud_cluster_v1_cluster, 0);

/**
 * ClusterConfigurationRestartPolicy defines restart strategies for the cluster's database.
 *
 * @generated from enum qdrant.cloud.cluster.v1.ClusterConfigurationRestartPolicy
 */
export enum ClusterConfigurationRestartPolicy {
  /**
   * Restart policy is unspecified.
   *
   * @generated from enum value: CLUSTER_CONFIGURATION_RESTART_POLICY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Rolling restart policy (one by one).
   *
   * @generated from enum value: CLUSTER_CONFIGURATION_RESTART_POLICY_ROLLING = 1;
   */
  ROLLING = 1,

  /**
   * Parallel restart policy (restart all at once).
   *
   * @generated from enum value: CLUSTER_CONFIGURATION_RESTART_POLICY_PARALLEL = 2;
   */
  PARALLEL = 2,

  /**
   * Automatic restart policy.
   *
   * @generated from enum value: CLUSTER_CONFIGURATION_RESTART_POLICY_AUTOMATIC = 3;
   */
  AUTOMATIC = 3,
}

/**
 * Describes the enum qdrant.cloud.cluster.v1.ClusterConfigurationRestartPolicy.
 */
export const ClusterConfigurationRestartPolicySchema: GenEnum<ClusterConfigurationRestartPolicy> = /*@__PURE__*/
  enumDesc(file_qdrant_cloud_cluster_v1_cluster, 1);

/**
 * ClusterConfigurationRebalanceStrategy defines shard rebalancing strategies.
 *
 * @generated from enum qdrant.cloud.cluster.v1.ClusterConfigurationRebalanceStrategy
 */
export enum ClusterConfigurationRebalanceStrategy {
  /**
   * No rebalancing strategy is configured.
   *
   * @generated from enum value: CLUSTER_CONFIGURATION_REBALANCE_STRATEGY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Rebalance shards by count.
   *
   * @generated from enum value: CLUSTER_CONFIGURATION_REBALANCE_STRATEGY_BY_COUNT = 1;
   */
  BY_COUNT = 1,

  /**
   * Rebalance shards by size.
   *
   * @generated from enum value: CLUSTER_CONFIGURATION_REBALANCE_STRATEGY_BY_SIZE = 2;
   */
  BY_SIZE = 2,

  /**
   * Rebalance shards by both count and size.
   *
   * @generated from enum value: CLUSTER_CONFIGURATION_REBALANCE_STRATEGY_BY_COUNT_AND_SIZE = 3;
   */
  BY_COUNT_AND_SIZE = 3,
}

/**
 * Describes the enum qdrant.cloud.cluster.v1.ClusterConfigurationRebalanceStrategy.
 */
export const ClusterConfigurationRebalanceStrategySchema: GenEnum<ClusterConfigurationRebalanceStrategy> = /*@__PURE__*/
  enumDesc(file_qdrant_cloud_cluster_v1_cluster, 2);

/**
 * DatabaseConfigurationLogLevel defines the supported logging levels for the
 * Qdrant database. See: https://docs.rs/log/latest/log/enum.LevelFilter.html
 *
 * @generated from enum qdrant.cloud.cluster.v1.DatabaseConfigurationLogLevel
 */
export enum DatabaseConfigurationLogLevel {
  /**
   * Unspecified log level.
   *
   * @generated from enum value: DATABASE_CONFIGURATION_LOG_LEVEL_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Trace log level.
   *
   * @generated from enum value: DATABASE_CONFIGURATION_LOG_LEVEL_TRACE = 1;
   */
  TRACE = 1,

  /**
   * Debug log level.
   *
   * @generated from enum value: DATABASE_CONFIGURATION_LOG_LEVEL_DEBUG = 2;
   */
  DEBUG = 2,

  /**
   * Info log level.
   *
   * @generated from enum value: DATABASE_CONFIGURATION_LOG_LEVEL_INFO = 3;
   */
  INFO = 3,

  /**
   * Warn log level.
   *
   * @generated from enum value: DATABASE_CONFIGURATION_LOG_LEVEL_WARN = 4;
   */
  WARN = 4,

  /**
   * Error log level.
   *
   * @generated from enum value: DATABASE_CONFIGURATION_LOG_LEVEL_ERROR = 5;
   */
  ERROR = 5,

  /**
   * Off log level.
   *
   * @generated from enum value: DATABASE_CONFIGURATION_LOG_LEVEL_OFF = 6;
   */
  OFF = 6,
}

/**
 * Describes the enum qdrant.cloud.cluster.v1.DatabaseConfigurationLogLevel.
 */
export const DatabaseConfigurationLogLevelSchema: GenEnum<DatabaseConfigurationLogLevel> = /*@__PURE__*/
  enumDesc(file_qdrant_cloud_cluster_v1_cluster, 3);

/**
 * TolerationOperator defines the valid operators for tolerations.
 * See: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
 *
 * @generated from enum qdrant.cloud.cluster.v1.TolerationOperator
 */
export enum TolerationOperator {
  /**
   * Unspecified operator.
   *
   * @generated from enum value: TOLERATION_OPERATOR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The operator means the key exists.
   *
   * @generated from enum value: TOLERATION_OPERATOR_EXISTS = 1;
   */
  EXISTS = 1,

  /**
   * The operator means the key equals the given value.
   *
   * @generated from enum value: TOLERATION_OPERATOR_EQUAL = 2;
   */
  EQUAL = 2,
}

/**
 * Describes the enum qdrant.cloud.cluster.v1.TolerationOperator.
 */
export const TolerationOperatorSchema: GenEnum<TolerationOperator> = /*@__PURE__*/
  enumDesc(file_qdrant_cloud_cluster_v1_cluster, 4);

/**
 * TolerationEffect represents the effects a taint has on pod scheduling and eviction.
 * See: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
 *
 * @generated from enum qdrant.cloud.cluster.v1.TolerationEffect
 */
export enum TolerationEffect {
  /**
   * Unspecified effect.
   *
   * @generated from enum value: TOLERATION_EFFECT_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * NoSchedule taint effect.
   *
   * @generated from enum value: TOLERATION_EFFECT_NO_SCHEDULE = 1;
   */
  NO_SCHEDULE = 1,

  /**
   * PreferNoSchedule taint effect.
   *
   * @generated from enum value: TOLERATION_EFFECT_PREFER_NO_SCHEDULE = 2;
   */
  PREFER_NO_SCHEDULE = 2,

  /**
   * NoExecute taint effect.
   *
   * @generated from enum value: TOLERATION_EFFECT_NO_EXECUTE = 3;
   */
  NO_EXECUTE = 3,
}

/**
 * Describes the enum qdrant.cloud.cluster.v1.TolerationEffect.
 */
export const TolerationEffectSchema: GenEnum<TolerationEffect> = /*@__PURE__*/
  enumDesc(file_qdrant_cloud_cluster_v1_cluster, 5);

/**
 * ClusterService is the API used to configure cluster objects.
 *
 * @generated from service qdrant.cloud.cluster.v1.ClusterService
 */
export const ClusterService: GenService<{
  /**
   * Fetch all clusters in the account identified by the given ID.
   * Required permissions:
   * - read:clusters
   *
   * @generated from rpc qdrant.cloud.cluster.v1.ClusterService.ListClusters
   */
  listClusters: {
    methodKind: "unary";
    input: typeof ListClustersRequestSchema;
    output: typeof ListClustersResponseSchema;
  },
  /**
   * Fetch a cluster in the account identified by the given IDs.
   * Required permissions:
   * - read:clusters
   *
   * @generated from rpc qdrant.cloud.cluster.v1.ClusterService.GetCluster
   */
  getCluster: {
    methodKind: "unary";
    input: typeof GetClusterRequestSchema;
    output: typeof GetClusterResponseSchema;
  },
  /**
   * Creates a cluster in the account identified by the given ID.
   * Required permissions:
   * - write:clusters
   *
   * @generated from rpc qdrant.cloud.cluster.v1.ClusterService.CreateCluster
   */
  createCluster: {
    methodKind: "unary";
    input: typeof CreateClusterRequestSchema;
    output: typeof CreateClusterResponseSchema;
  },
  /**
   * Update a cluster in the account identified by the given ID.
   * Required permissions:
   * - write:clusters
   *
   * @generated from rpc qdrant.cloud.cluster.v1.ClusterService.UpdateCluster
   */
  updateCluster: {
    methodKind: "unary";
    input: typeof UpdateClusterRequestSchema;
    output: typeof UpdateClusterResponseSchema;
  },
  /**
   * Deletes a cluster in the account identified by the given ID.
   * Required permissions:
   * - delete:clusters
   *
   * @generated from rpc qdrant.cloud.cluster.v1.ClusterService.DeleteCluster
   */
  deleteCluster: {
    methodKind: "unary";
    input: typeof DeleteClusterRequestSchema;
    output: typeof DeleteClusterResponseSchema;
  },
  /**
   * Restarts a cluster in the account identified by the given ID.
   * Required permissions:
   * - write:clusters
   *
   * @generated from rpc qdrant.cloud.cluster.v1.ClusterService.RestartCluster
   */
  restartCluster: {
    methodKind: "unary";
    input: typeof RestartClusterRequestSchema;
    output: typeof RestartClusterResponseSchema;
  },
  /**
   * Fetch all qdrant releases in the account identified by the given ID.
   * Optional a cluster ID can be provided, the list will return the options to update to only.
   * Required permissions:
   * - read:clusters
   *
   * @generated from rpc qdrant.cloud.cluster.v1.ClusterService.ListQdrantReleases
   */
  listQdrantReleases: {
    methodKind: "unary";
    input: typeof ListQdrantReleasesRequestSchema;
    output: typeof ListQdrantReleasesResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_qdrant_cloud_cluster_v1_cluster, 0);

