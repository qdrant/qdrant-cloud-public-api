// @generated by protoc-gen-es v2.7.0 with parameter "target=js+dts,import_extension=js,valid_types=protovalidate_required"
// @generated from file qdrant/cloud/cluster/v1/cluster.proto (package qdrant.cloud.cluster.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { Timestamp } from "@bufbuild/protobuf/wkt";
import type { KeyValue, SecretKeyRef, SecretKeyRefValid } from "../../common/v1/common_pb.js";

/**
 * Describes the file qdrant/cloud/cluster/v1/cluster.proto.
 */
export declare const file_qdrant_cloud_cluster_v1_cluster: GenFile;

/**
 * ListClustersRequest is the request for the ListClusters function
 *
 * @generated from message qdrant.cloud.cluster.v1.ListClustersRequest
 */
export declare type ListClustersRequest = Message<"qdrant.cloud.cluster.v1.ListClustersRequest"> & {
  /**
   * The identifier of the account (in GUID format).
   * This is a required field.
   *
   * @generated from field: string account_id = 1;
   */
  accountId: string;

  /**
   * Optional filter specifying the cloud provider where the cluster is hosted.
   * Must match one of the provider IDs returned by the `qdrant.cloud.platform.v1.PlatformService.ListCloudProviders` method.
   * If omitted, all clusters for the specified account are returned, including those hosted in hybrid cloud environments.
   *
   * @generated from field: optional string cloud_provider_id = 10;
   */
  cloudProviderId?: string;

  /**
   * Optional filter specifying the cloud provider region where the cluster is hosted.
   * Must match one of the region IDs returned by the `qdrant.cloud.platform.v1.PlatformService.ListCloudProviderRegions` method.
   * If this field is set, the `cloud_provider_id` is required to set as well (and it should match).
   * For hybrid this should be the hybrid cloud environment ID.
   *
   * @generated from field: optional string cloud_provider_region_id = 11;
   */
  cloudProviderRegionId?: string;
};

export declare type ListClustersRequestValid = ListClustersRequest;

/**
 * Describes the message qdrant.cloud.cluster.v1.ListClustersRequest.
 * Use `create(ListClustersRequestSchema)` to create a new message.
 */
export declare const ListClustersRequestSchema: GenMessage<ListClustersRequest, {validType: ListClustersRequestValid}>;

/**
 * ListClustersResponse is the response from the ListClusters function
 *
 * @generated from message qdrant.cloud.cluster.v1.ListClustersResponse
 */
export declare type ListClustersResponse = Message<"qdrant.cloud.cluster.v1.ListClustersResponse"> & {
  /**
   * The actual clusters in this list
   *
   * @generated from field: repeated qdrant.cloud.cluster.v1.Cluster items = 1;
   */
  items: Cluster[];
};

export declare type ListClustersResponseValid = ListClustersResponse;

/**
 * Describes the message qdrant.cloud.cluster.v1.ListClustersResponse.
 * Use `create(ListClustersResponseSchema)` to create a new message.
 */
export declare const ListClustersResponseSchema: GenMessage<ListClustersResponse, {validType: ListClustersResponseValid}>;

/**
 * GetClusterRequest is the request for the GetCluster function
 *
 * @generated from message qdrant.cloud.cluster.v1.GetClusterRequest
 */
export declare type GetClusterRequest = Message<"qdrant.cloud.cluster.v1.GetClusterRequest"> & {
  /**
   * The identifier of the account (in GUID format).
   * This is a required field.
   *
   * @generated from field: string account_id = 1;
   */
  accountId: string;

  /**
   * The identifier for the cluster (in GUID format).
   * This cluster should be part of the provided account.
   * This is a required field.
   *
   * @generated from field: string cluster_id = 2;
   */
  clusterId: string;
};

export declare type GetClusterRequestValid = GetClusterRequest;

/**
 * Describes the message qdrant.cloud.cluster.v1.GetClusterRequest.
 * Use `create(GetClusterRequestSchema)` to create a new message.
 */
export declare const GetClusterRequestSchema: GenMessage<GetClusterRequest, {validType: GetClusterRequestValid}>;

/**
 * GetClusterResponse is the response from the GetCluster function
 *
 * @generated from message qdrant.cloud.cluster.v1.GetClusterResponse
 */
export declare type GetClusterResponse = Message<"qdrant.cloud.cluster.v1.GetClusterResponse"> & {
  /**
   * The actual cluster
   *
   * @generated from field: qdrant.cloud.cluster.v1.Cluster cluster = 1;
   */
  cluster?: Cluster;
};

/**
 * GetClusterResponse is the response from the GetCluster function
 *
 * @generated from message qdrant.cloud.cluster.v1.GetClusterResponse
 */
export declare type GetClusterResponseValid = Message<"qdrant.cloud.cluster.v1.GetClusterResponse"> & {
  /**
   * The actual cluster
   *
   * @generated from field: qdrant.cloud.cluster.v1.Cluster cluster = 1;
   */
  cluster: ClusterValid;
};

/**
 * Describes the message qdrant.cloud.cluster.v1.GetClusterResponse.
 * Use `create(GetClusterResponseSchema)` to create a new message.
 */
export declare const GetClusterResponseSchema: GenMessage<GetClusterResponse, {validType: GetClusterResponseValid}>;

/**
 * CreateClusterRequest is the request for the CreateCluster function
 *
 * @generated from message qdrant.cloud.cluster.v1.CreateClusterRequest
 */
export declare type CreateClusterRequest = Message<"qdrant.cloud.cluster.v1.CreateClusterRequest"> & {
  /**
   * The actual cluster
   *
   * @generated from field: qdrant.cloud.cluster.v1.Cluster cluster = 1;
   */
  cluster?: Cluster;
};

/**
 * CreateClusterRequest is the request for the CreateCluster function
 *
 * @generated from message qdrant.cloud.cluster.v1.CreateClusterRequest
 */
export declare type CreateClusterRequestValid = Message<"qdrant.cloud.cluster.v1.CreateClusterRequest"> & {
  /**
   * The actual cluster
   *
   * @generated from field: qdrant.cloud.cluster.v1.Cluster cluster = 1;
   */
  cluster: ClusterValid;
};

/**
 * Describes the message qdrant.cloud.cluster.v1.CreateClusterRequest.
 * Use `create(CreateClusterRequestSchema)` to create a new message.
 */
export declare const CreateClusterRequestSchema: GenMessage<CreateClusterRequest, {validType: CreateClusterRequestValid}>;

/**
 * CreateClusterResponse is the response from the CreateCluster function
 *
 * @generated from message qdrant.cloud.cluster.v1.CreateClusterResponse
 */
export declare type CreateClusterResponse = Message<"qdrant.cloud.cluster.v1.CreateClusterResponse"> & {
  /**
   * The actual cluster
   *
   * @generated from field: qdrant.cloud.cluster.v1.Cluster cluster = 1;
   */
  cluster?: Cluster;
};

/**
 * CreateClusterResponse is the response from the CreateCluster function
 *
 * @generated from message qdrant.cloud.cluster.v1.CreateClusterResponse
 */
export declare type CreateClusterResponseValid = Message<"qdrant.cloud.cluster.v1.CreateClusterResponse"> & {
  /**
   * The actual cluster
   *
   * @generated from field: qdrant.cloud.cluster.v1.Cluster cluster = 1;
   */
  cluster: ClusterValid;
};

/**
 * Describes the message qdrant.cloud.cluster.v1.CreateClusterResponse.
 * Use `create(CreateClusterResponseSchema)` to create a new message.
 */
export declare const CreateClusterResponseSchema: GenMessage<CreateClusterResponse, {validType: CreateClusterResponseValid}>;

/**
 * UpdateClusterRequest is the request for the UpdateCluster function
 *
 * @generated from message qdrant.cloud.cluster.v1.UpdateClusterRequest
 */
export declare type UpdateClusterRequest = Message<"qdrant.cloud.cluster.v1.UpdateClusterRequest"> & {
  /**
   * The actual cluster
   *
   * @generated from field: qdrant.cloud.cluster.v1.Cluster cluster = 1;
   */
  cluster?: Cluster;
};

/**
 * UpdateClusterRequest is the request for the UpdateCluster function
 *
 * @generated from message qdrant.cloud.cluster.v1.UpdateClusterRequest
 */
export declare type UpdateClusterRequestValid = Message<"qdrant.cloud.cluster.v1.UpdateClusterRequest"> & {
  /**
   * The actual cluster
   *
   * @generated from field: qdrant.cloud.cluster.v1.Cluster cluster = 1;
   */
  cluster: ClusterValid;
};

/**
 * Describes the message qdrant.cloud.cluster.v1.UpdateClusterRequest.
 * Use `create(UpdateClusterRequestSchema)` to create a new message.
 */
export declare const UpdateClusterRequestSchema: GenMessage<UpdateClusterRequest, {validType: UpdateClusterRequestValid}>;

/**
 * UpdateClusterResponse is the response from the UpdateCluster function
 *
 * @generated from message qdrant.cloud.cluster.v1.UpdateClusterResponse
 */
export declare type UpdateClusterResponse = Message<"qdrant.cloud.cluster.v1.UpdateClusterResponse"> & {
  /**
   * The actual cluster
   *
   * @generated from field: qdrant.cloud.cluster.v1.Cluster cluster = 1;
   */
  cluster?: Cluster;
};

/**
 * UpdateClusterResponse is the response from the UpdateCluster function
 *
 * @generated from message qdrant.cloud.cluster.v1.UpdateClusterResponse
 */
export declare type UpdateClusterResponseValid = Message<"qdrant.cloud.cluster.v1.UpdateClusterResponse"> & {
  /**
   * The actual cluster
   *
   * @generated from field: qdrant.cloud.cluster.v1.Cluster cluster = 1;
   */
  cluster: ClusterValid;
};

/**
 * Describes the message qdrant.cloud.cluster.v1.UpdateClusterResponse.
 * Use `create(UpdateClusterResponseSchema)` to create a new message.
 */
export declare const UpdateClusterResponseSchema: GenMessage<UpdateClusterResponse, {validType: UpdateClusterResponseValid}>;

/**
 * DeleteClusterRequest is the request for the DeleteCluster function
 *
 * @generated from message qdrant.cloud.cluster.v1.DeleteClusterRequest
 */
export declare type DeleteClusterRequest = Message<"qdrant.cloud.cluster.v1.DeleteClusterRequest"> & {
  /**
   * The identifier of the account (in GUID format).
   * This is a required field.
   *
   * @generated from field: string account_id = 1;
   */
  accountId: string;

  /**
   * The identifier for the cluster (in GUID format).
   * This cluster should be part of the provided account.
   * This is a required field.
   *
   * @generated from field: string cluster_id = 2;
   */
  clusterId: string;

  /**
   * If set, the backups of this cluster will be deleted as well.
   *
   * @generated from field: optional bool delete_backups = 3;
   */
  deleteBackups?: boolean;
};

export declare type DeleteClusterRequestValid = DeleteClusterRequest;

/**
 * Describes the message qdrant.cloud.cluster.v1.DeleteClusterRequest.
 * Use `create(DeleteClusterRequestSchema)` to create a new message.
 */
export declare const DeleteClusterRequestSchema: GenMessage<DeleteClusterRequest, {validType: DeleteClusterRequestValid}>;

/**
 * DeleteClusterResponse is the response from the DeleteCluster function
 *
 * Empty
 *
 * @generated from message qdrant.cloud.cluster.v1.DeleteClusterResponse
 */
export declare type DeleteClusterResponse = Message<"qdrant.cloud.cluster.v1.DeleteClusterResponse"> & {
};

export declare type DeleteClusterResponseValid = DeleteClusterResponse;

/**
 * Describes the message qdrant.cloud.cluster.v1.DeleteClusterResponse.
 * Use `create(DeleteClusterResponseSchema)` to create a new message.
 */
export declare const DeleteClusterResponseSchema: GenMessage<DeleteClusterResponse, {validType: DeleteClusterResponseValid}>;

/**
 * RestartClusterRequest is the request for the RestartCluster function
 *
 * @generated from message qdrant.cloud.cluster.v1.RestartClusterRequest
 */
export declare type RestartClusterRequest = Message<"qdrant.cloud.cluster.v1.RestartClusterRequest"> & {
  /**
   * The identifier of the account (in GUID format).
   * This is a required field.
   *
   * @generated from field: string account_id = 1;
   */
  accountId: string;

  /**
   * The identifier for the cluster (in GUID format).
   * This cluster should be part of the provided account.
   * This is a required field.
   *
   * @generated from field: string cluster_id = 2;
   */
  clusterId: string;
};

export declare type RestartClusterRequestValid = RestartClusterRequest;

/**
 * Describes the message qdrant.cloud.cluster.v1.RestartClusterRequest.
 * Use `create(RestartClusterRequestSchema)` to create a new message.
 */
export declare const RestartClusterRequestSchema: GenMessage<RestartClusterRequest, {validType: RestartClusterRequestValid}>;

/**
 * RestartClusterResponse is the response from the RestartCluster function
 *
 * Empty
 *
 * @generated from message qdrant.cloud.cluster.v1.RestartClusterResponse
 */
export declare type RestartClusterResponse = Message<"qdrant.cloud.cluster.v1.RestartClusterResponse"> & {
};

export declare type RestartClusterResponseValid = RestartClusterResponse;

/**
 * Describes the message qdrant.cloud.cluster.v1.RestartClusterResponse.
 * Use `create(RestartClusterResponseSchema)` to create a new message.
 */
export declare const RestartClusterResponseSchema: GenMessage<RestartClusterResponse, {validType: RestartClusterResponseValid}>;

/**
 * SuspendClusterRequest is the request for the SuspendCluster function
 *
 * @generated from message qdrant.cloud.cluster.v1.SuspendClusterRequest
 */
export declare type SuspendClusterRequest = Message<"qdrant.cloud.cluster.v1.SuspendClusterRequest"> & {
  /**
   * The identifier of the account (in GUID format).
   * This is a required field.
   *
   * @generated from field: string account_id = 1;
   */
  accountId: string;

  /**
   * The identifier for the cluster (in GUID format).
   * This cluster should be part of the provided account.
   * This is a required field.
   *
   * @generated from field: string cluster_id = 2;
   */
  clusterId: string;
};

export declare type SuspendClusterRequestValid = SuspendClusterRequest;

/**
 * Describes the message qdrant.cloud.cluster.v1.SuspendClusterRequest.
 * Use `create(SuspendClusterRequestSchema)` to create a new message.
 */
export declare const SuspendClusterRequestSchema: GenMessage<SuspendClusterRequest, {validType: SuspendClusterRequestValid}>;

/**
 * SuspendClusterResponse is the response from the SuspendCluster function
 *
 * Empty
 *
 * @generated from message qdrant.cloud.cluster.v1.SuspendClusterResponse
 */
export declare type SuspendClusterResponse = Message<"qdrant.cloud.cluster.v1.SuspendClusterResponse"> & {
};

export declare type SuspendClusterResponseValid = SuspendClusterResponse;

/**
 * Describes the message qdrant.cloud.cluster.v1.SuspendClusterResponse.
 * Use `create(SuspendClusterResponseSchema)` to create a new message.
 */
export declare const SuspendClusterResponseSchema: GenMessage<SuspendClusterResponse, {validType: SuspendClusterResponseValid}>;

/**
 * SuggestClusterNameRequest is the request for the SuggestClusterName function
 *
 * @generated from message qdrant.cloud.cluster.v1.SuggestClusterNameRequest
 */
export declare type SuggestClusterNameRequest = Message<"qdrant.cloud.cluster.v1.SuggestClusterNameRequest"> & {
  /**
   * The identifier of the account (in GUID format).
   * This is a required field.
   *
   * @generated from field: string account_id = 1;
   */
  accountId: string;
};

export declare type SuggestClusterNameRequestValid = SuggestClusterNameRequest;

/**
 * Describes the message qdrant.cloud.cluster.v1.SuggestClusterNameRequest.
 * Use `create(SuggestClusterNameRequestSchema)` to create a new message.
 */
export declare const SuggestClusterNameRequestSchema: GenMessage<SuggestClusterNameRequest, {validType: SuggestClusterNameRequestValid}>;

/**
 * SuggestClusterNameResponse is the response from the SuggestClusterName function
 *
 * @generated from message qdrant.cloud.cluster.v1.SuggestClusterNameResponse
 */
export declare type SuggestClusterNameResponse = Message<"qdrant.cloud.cluster.v1.SuggestClusterNameResponse"> & {
  /**
   * The suggested name for a new cluster.
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

export declare type SuggestClusterNameResponseValid = SuggestClusterNameResponse;

/**
 * Describes the message qdrant.cloud.cluster.v1.SuggestClusterNameResponse.
 * Use `create(SuggestClusterNameResponseSchema)` to create a new message.
 */
export declare const SuggestClusterNameResponseSchema: GenMessage<SuggestClusterNameResponse, {validType: SuggestClusterNameResponseValid}>;

/**
 * ListQdrantReleasesRequest is the request for the ListQdrantReleases function
 *
 * @generated from message qdrant.cloud.cluster.v1.ListQdrantReleasesRequest
 */
export declare type ListQdrantReleasesRequest = Message<"qdrant.cloud.cluster.v1.ListQdrantReleasesRequest"> & {
  /**
   * The identifier of the account (in GUID format).
   * This is a required field.
   *
   * @generated from field: string account_id = 1;
   */
  accountId: string;

  /**
   * The identifier for the cluster (in GUID format).
   * This cluster should be part of the provided account.
   * This is an optional field.
   *
   * @generated from field: optional string cluster_id = 2;
   */
  clusterId?: string;
};

export declare type ListQdrantReleasesRequestValid = ListQdrantReleasesRequest;

/**
 * Describes the message qdrant.cloud.cluster.v1.ListQdrantReleasesRequest.
 * Use `create(ListQdrantReleasesRequestSchema)` to create a new message.
 */
export declare const ListQdrantReleasesRequestSchema: GenMessage<ListQdrantReleasesRequest, {validType: ListQdrantReleasesRequestValid}>;

/**
 * ListQdrantReleasesResponse is the response from the ListQdrantReleases function
 *
 * @generated from message qdrant.cloud.cluster.v1.ListQdrantReleasesResponse
 */
export declare type ListQdrantReleasesResponse = Message<"qdrant.cloud.cluster.v1.ListQdrantReleasesResponse"> & {
  /**
   * The actual Qdrant releases in this list
   *
   * @generated from field: repeated qdrant.cloud.cluster.v1.QdrantRelease items = 1;
   */
  items: QdrantRelease[];
};

export declare type ListQdrantReleasesResponseValid = ListQdrantReleasesResponse;

/**
 * Describes the message qdrant.cloud.cluster.v1.ListQdrantReleasesResponse.
 * Use `create(ListQdrantReleasesResponseSchema)` to create a new message.
 */
export declare const ListQdrantReleasesResponseSchema: GenMessage<ListQdrantReleasesResponse, {validType: ListQdrantReleasesResponseValid}>;

/**
 * A Cluster represents one cluster of a Qdrant database.
 *
 * @generated from message qdrant.cloud.cluster.v1.Cluster
 */
export declare type Cluster = Message<"qdrant.cloud.cluster.v1.Cluster"> & {
  /**
   * Unique identifier for the cluster (in GUID format).
   * This is a read-only field and will be available after a cluster is created.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * Timestamp when the cluster was created.
   * This is a read-only field and will be available after a cluster is created.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 2;
   */
  createdAt?: Timestamp;

  /**
   * Identifier of the account associated with the cluster (in GUID format).
   * This is a required field.
   *
   * @generated from field: string account_id = 3;
   */
  accountId: string;

  /**
   * Name of the cluster.
   * This is a required field.
   * Name can only contain letters, numbers, underscores and dashes
   *
   * @generated from field: string name = 4;
   */
  name: string;

  /**
   * Timestamp when the cluster was deleted (or is started to be deleting).
   * This is a read-only field and will be set after DeleteCluster is called.
   *
   * @generated from field: google.protobuf.Timestamp deleted_at = 5;
   */
  deletedAt?: Timestamp;

  /**
   * Cloud provider where the cluster is hosted.
   * Must match one of the provider IDs returned by the `qdrant.cloud.platform.v1.PlatformService.ListCloudProviders` method.
   * After creation, this field cannot be changed.
   *
   * @generated from field: string cloud_provider_id = 10;
   */
  cloudProviderId: string;

  /**
   * Cloud provider region where the cluster is hosted.
   * Must match one of the region IDs returned by the `qdrant.cloud.platform.v1.PlatformService.ListCloudProviderRegions` method.
   * For hybrid this should be the hybrid cloud environment ID.
   * This is a required field.
   * After creation, this field cannot be changed.
   *
   * @generated from field: string cloud_provider_region_id = 11;
   */
  cloudProviderRegionId: string;

  /**
   * Current configuration details of the cluster.
   *
   * @generated from field: qdrant.cloud.cluster.v1.ClusterConfiguration configuration = 20;
   */
  configuration?: ClusterConfiguration;

  /**
   * Current state of the cluster (available after the cluster has been created).
   * All fields inside `state` are read-only.
   *
   * @generated from field: qdrant.cloud.cluster.v1.ClusterState state = 100;
   */
  state?: ClusterState;
};

/**
 * A Cluster represents one cluster of a Qdrant database.
 *
 * @generated from message qdrant.cloud.cluster.v1.Cluster
 */
export declare type ClusterValid = Message<"qdrant.cloud.cluster.v1.Cluster"> & {
  /**
   * Unique identifier for the cluster (in GUID format).
   * This is a read-only field and will be available after a cluster is created.
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * Timestamp when the cluster was created.
   * This is a read-only field and will be available after a cluster is created.
   *
   * @generated from field: google.protobuf.Timestamp created_at = 2;
   */
  createdAt?: Timestamp;

  /**
   * Identifier of the account associated with the cluster (in GUID format).
   * This is a required field.
   *
   * @generated from field: string account_id = 3;
   */
  accountId: string;

  /**
   * Name of the cluster.
   * This is a required field.
   * Name can only contain letters, numbers, underscores and dashes
   *
   * @generated from field: string name = 4;
   */
  name: string;

  /**
   * Timestamp when the cluster was deleted (or is started to be deleting).
   * This is a read-only field and will be set after DeleteCluster is called.
   *
   * @generated from field: google.protobuf.Timestamp deleted_at = 5;
   */
  deletedAt?: Timestamp;

  /**
   * Cloud provider where the cluster is hosted.
   * Must match one of the provider IDs returned by the `qdrant.cloud.platform.v1.PlatformService.ListCloudProviders` method.
   * After creation, this field cannot be changed.
   *
   * @generated from field: string cloud_provider_id = 10;
   */
  cloudProviderId: string;

  /**
   * Cloud provider region where the cluster is hosted.
   * Must match one of the region IDs returned by the `qdrant.cloud.platform.v1.PlatformService.ListCloudProviderRegions` method.
   * For hybrid this should be the hybrid cloud environment ID.
   * This is a required field.
   * After creation, this field cannot be changed.
   *
   * @generated from field: string cloud_provider_region_id = 11;
   */
  cloudProviderRegionId: string;

  /**
   * Current configuration details of the cluster.
   *
   * @generated from field: qdrant.cloud.cluster.v1.ClusterConfiguration configuration = 20;
   */
  configuration: ClusterConfigurationValid;

  /**
   * Current state of the cluster (available after the cluster has been created).
   * All fields inside `state` are read-only.
   *
   * @generated from field: qdrant.cloud.cluster.v1.ClusterState state = 100;
   */
  state?: ClusterStateValid;
};

/**
 * Describes the message qdrant.cloud.cluster.v1.Cluster.
 * Use `create(ClusterSchema)` to create a new message.
 */
export declare const ClusterSchema: GenMessage<Cluster, {validType: ClusterValid}>;

/**
 * A ClusterConfiguration represents the configuration of a cluster.
 *
 * @generated from message qdrant.cloud.cluster.v1.ClusterConfiguration
 */
export declare type ClusterConfiguration = Message<"qdrant.cloud.cluster.v1.ClusterConfiguration"> & {
  /**
   * Timestamp when the cluster configuration was last updated.
   * This is a read-only field and will be available after a cluster is created.
   *
   * @generated from field: google.protobuf.Timestamp last_modified_at = 1;
   */
  lastModifiedAt?: Timestamp;

  /**
   * The number of nodes in a cluster.
   * This should be a number 1...20 [both included].
   * This is a required field.
   *
   * @generated from field: uint32 number_of_nodes = 2;
   */
  numberOfNodes: number;

  /**
   * Version of the cluster software.
   * If omitted the latest version will be used and filled out during create.
   * Use ListReleases() to determine which versions are allowed to be used.
   * See upgrade guidelines for more info.
   *
   * @generated from field: optional string version = 3;
   */
  version?: string;

  /**
   * The package identifier used to configure the resources of the cluster. Use `qdrant.cloud.booking.v1.BookingService.ListPackages` to select one.
   * This is a required field.
   *
   * @generated from field: string package_id = 4;
   */
  packageId: string;

  /**
   * The additional resources on top of the selected package.
   * This is an optional field, if not specified all additional resources are 0.
   *
   * @generated from field: optional qdrant.cloud.cluster.v1.AdditionalResources additional_resources = 5;
   */
  additionalResources?: AdditionalResources;

  /**
   * Configuration to setup a qdrant database.
   * This is an optional field.
   *
   * @generated from field: optional qdrant.cloud.cluster.v1.DatabaseConfiguration database_configuration = 7;
   */
  databaseConfiguration?: DatabaseConfiguration;

  /**
   * The node selector for this cluster in a hybrid cloud environment.
   * It is ignored for managed cloud clusters. This is an optional field
   *
   * @generated from field: repeated qdrant.cloud.common.v1.KeyValue node_selector = 8;
   */
  nodeSelector: KeyValue[];

  /**
   * List of tolerations for this cluster in a hybrid cloud environment.
   * It is ignored for managed cloud clusters. This is an optional field
   *
   * @generated from field: repeated qdrant.cloud.cluster.v1.Toleration tolerations = 9;
   */
  tolerations: Toleration[];

  /**
   * List of annotations for this cluster in a hybrid cloud environment.
   * It is ignored for managed cloud clusters. This is an optional field
   *
   * @generated from field: repeated qdrant.cloud.common.v1.KeyValue annotations = 10;
   */
  annotations: KeyValue[];

  /**
   * List of allowed IP source ranges for this cluster.
   * Field is used for both managed cloud and hybrid cloud and clusters. This is an optional field
   * The CIDRs supports IPv4 only.
   *
   * @generated from field: repeated string allowed_ip_source_ranges = 11;
   */
  allowedIpSourceRanges: string[];

  /**
   * The type of service to use for this cluster in a hybrid cloud environment.
   * It is ignored for managed cloud clusters. This is an optional field, default is Cluster IP.
   *
   * @generated from field: optional qdrant.cloud.cluster.v1.ClusterServiceType service_type = 12;
   */
  serviceType?: ClusterServiceType;

  /**
   * List of annotations applied to the service of this cluster in a hybrid cloud environment.
   * It is ignored for managed cloud clusters. This is an optional field
   *
   * @generated from field: repeated qdrant.cloud.common.v1.KeyValue service_annotations = 13;
   */
  serviceAnnotations: KeyValue[];

  /**
   * List of labels applied to the pods of this cluster in a hybrid cloud environment.
   * It is ignored for managed cloud clusters. This is an optional field
   *
   * @generated from field: repeated qdrant.cloud.common.v1.KeyValue pod_labels = 14;
   */
  podLabels: KeyValue[];

  /**
   * The percentage of CPU resources reserved for system components
   * This is an optional field, default is 0.
   * Number between 0..80
   *
   * @generated from field: uint32 reserved_cpu_percentage = 20;
   */
  reservedCpuPercentage: number;

  /**
   * The percentage of RAM resources reserved for system components
   * This is an optional field, default is 0.
   * Number between 0..80
   *
   * @generated from field: uint32 reserved_memory_percentage = 21;
   */
  reservedMemoryPercentage: number;

  /**
   * The gpu type that should be used for the database
   * This is an optional field, default is No configured GPU
   *
   * @generated from field: optional qdrant.cloud.cluster.v1.ClusterConfigurationGpuType gpu_type = 22;
   */
  gpuType?: ClusterConfigurationGpuType;

  /**
   * The restart policy for the database
   * This is an optional field, default is Automatic
   *
   * @generated from field: optional qdrant.cloud.cluster.v1.ClusterConfigurationRestartPolicy restart_policy = 23;
   */
  restartPolicy?: ClusterConfigurationRestartPolicy;

  /**
   * The automatic shard rebalancing strategy for the database
   * This is an optional field, default is none
   *
   * @generated from field: optional qdrant.cloud.cluster.v1.ClusterConfigurationRebalanceStrategy rebalance_strategy = 24;
   */
  rebalanceStrategy?: ClusterConfigurationRebalanceStrategy;
};

export declare type ClusterConfigurationValid = ClusterConfiguration;

/**
 * Describes the message qdrant.cloud.cluster.v1.ClusterConfiguration.
 * Use `create(ClusterConfigurationSchema)` to create a new message.
 */
export declare const ClusterConfigurationSchema: GenMessage<ClusterConfiguration, {validType: ClusterConfigurationValid}>;

/**
 * Configuration to setup a Qdrant database.
 * The settings apply to managed and/or hybrid cloud, see documentation on each message for more details.
 *
 * @generated from message qdrant.cloud.cluster.v1.DatabaseConfiguration
 */
export declare type DatabaseConfiguration = Message<"qdrant.cloud.cluster.v1.DatabaseConfiguration"> & {
  /**
   * The default Qdrant database collection configuration.
   * This setting is for both managed and hybrid cloud clusters, see sub-messages for more details.
   * This is an optional field.
   *
   * @generated from field: optional qdrant.cloud.cluster.v1.DatabaseConfigurationCollection collection = 1;
   */
  collection?: DatabaseConfigurationCollection;

  /**
   * The default Qdrant database storage configuration.
   * This setting is for both managed and hybrid cloud clusters.
   * This is an optional field.
   *
   * @generated from field: optional qdrant.cloud.cluster.v1.DatabaseConfigurationStorage storage = 2;
   */
  storage?: DatabaseConfigurationStorage;

  /**
   * The Qdrant database service configuration
   * This setting is for both managed and hybrid cloud clusters, see sub-messages for more details.
   * This is an optional field
   *
   * @generated from field: optional qdrant.cloud.cluster.v1.DatabaseConfigurationService service = 3;
   */
  service?: DatabaseConfigurationService;

  /**
   * The log level for the database.
   * Qdrant is written in Rust and is using: https://docs.rs/log/latest/log/enum.LevelFilter.html
   * This setting is for hybrid cloud clusters only, it is ignored for managed cloud clusters.
   * This is an optional field, default is Info.
   *
   * @generated from field: optional qdrant.cloud.cluster.v1.DatabaseConfigurationLogLevel log_level = 4;
   */
  logLevel?: DatabaseConfigurationLogLevel;

  /**
   * The Qdrant database TLS configuration.
   * This setting is for hybrid cloud clusters only, it is ignored for managed cloud clusters.
   * This is an optional field, if not set an unsecure connection is provided.
   *
   * @generated from field: optional qdrant.cloud.cluster.v1.DatabaseConfigurationTls tls = 5;
   */
  tls?: DatabaseConfigurationTls;

  /**
   * The Qdrant database inference configuration.
   * This setting is for managed cloud clusters only, it is ignored for hybrid cloud clusters.
   * This is an optional field, if unset, the database is not configured for cloud inferencing
   *
   * @generated from field: optional qdrant.cloud.cluster.v1.DatabaseConfigurationInference inference = 6;
   */
  inference?: DatabaseConfigurationInference;
};

export declare type DatabaseConfigurationValid = DatabaseConfiguration;

/**
 * Describes the message qdrant.cloud.cluster.v1.DatabaseConfiguration.
 * Use `create(DatabaseConfigurationSchema)` to create a new message.
 */
export declare const DatabaseConfigurationSchema: GenMessage<DatabaseConfiguration, {validType: DatabaseConfigurationValid}>;

/**
 * The default Qdrant database collection configuration
 *
 * @generated from message qdrant.cloud.cluster.v1.DatabaseConfigurationCollection
 */
export declare type DatabaseConfigurationCollection = Message<"qdrant.cloud.cluster.v1.DatabaseConfigurationCollection"> & {
  /**
   * Number of replicas of each shard that network tries to maintain
   * This is an optional, the default is 1
   *
   * @generated from field: optional uint32 replication_factor = 1;
   */
  replicationFactor?: number;

  /**
   * How many replicas should apply the operation for us to consider it successful
   * This is an optional, the default is 1
   *
   * @generated from field: int32 write_consistency_factor = 2;
   */
  writeConsistencyFactor: number;

  /**
   * The default parameters for vectors.
   *
   * @generated from field: qdrant.cloud.cluster.v1.DatabaseConfigurationCollectionVectors vectors = 3;
   */
  vectors?: DatabaseConfigurationCollectionVectors;
};

/**
 * The default Qdrant database collection configuration
 *
 * @generated from message qdrant.cloud.cluster.v1.DatabaseConfigurationCollection
 */
export declare type DatabaseConfigurationCollectionValid = Message<"qdrant.cloud.cluster.v1.DatabaseConfigurationCollection"> & {
  /**
   * Number of replicas of each shard that network tries to maintain
   * This is an optional, the default is 1
   *
   * @generated from field: optional uint32 replication_factor = 1;
   */
  replicationFactor?: number;

  /**
   * How many replicas should apply the operation for us to consider it successful
   * This is an optional, the default is 1
   *
   * @generated from field: int32 write_consistency_factor = 2;
   */
  writeConsistencyFactor: number;

  /**
   * The default parameters for vectors.
   *
   * @generated from field: qdrant.cloud.cluster.v1.DatabaseConfigurationCollectionVectors vectors = 3;
   */
  vectors: DatabaseConfigurationCollectionVectorsValid;
};

/**
 * Describes the message qdrant.cloud.cluster.v1.DatabaseConfigurationCollection.
 * Use `create(DatabaseConfigurationCollectionSchema)` to create a new message.
 */
export declare const DatabaseConfigurationCollectionSchema: GenMessage<DatabaseConfigurationCollection, {validType: DatabaseConfigurationCollectionValid}>;

/**
 * The default Qdrant database collection vectors configuration
 *
 * @generated from message qdrant.cloud.cluster.v1.DatabaseConfigurationCollectionVectors
 */
export declare type DatabaseConfigurationCollectionVectors = Message<"qdrant.cloud.cluster.v1.DatabaseConfigurationCollectionVectors"> & {
  /**
   * If set, this will create a collection with all vectors immediately stored in memmap storage.
   * This is the recommended way, in case your Qdrant instance operates with fast disks and you are working with large collections.
   * For more info see: https://qdrant.tech/documentation/concepts/storage/#configuring-memmap-storage
   * This is an optional field, the default value will be true.
   *
   * @generated from field: optional bool on_disk = 1;
   */
  onDisk?: boolean;
};

export declare type DatabaseConfigurationCollectionVectorsValid = DatabaseConfigurationCollectionVectors;

/**
 * Describes the message qdrant.cloud.cluster.v1.DatabaseConfigurationCollectionVectors.
 * Use `create(DatabaseConfigurationCollectionVectorsSchema)` to create a new message.
 */
export declare const DatabaseConfigurationCollectionVectorsSchema: GenMessage<DatabaseConfigurationCollectionVectors, {validType: DatabaseConfigurationCollectionVectorsValid}>;

/**
 * The Qdrant storage configuration
 *
 * @generated from message qdrant.cloud.cluster.v1.DatabaseConfigurationStorage
 */
export declare type DatabaseConfigurationStorage = Message<"qdrant.cloud.cluster.v1.DatabaseConfigurationStorage"> & {
  /**
   * The performance related Qdrant database storage configuration
   *
   * @generated from field: qdrant.cloud.cluster.v1.DatabaseConfigurationStoragePerformance performance = 1;
   */
  performance?: DatabaseConfigurationStoragePerformance;
};

export declare type DatabaseConfigurationStorageValid = DatabaseConfigurationStorage;

/**
 * Describes the message qdrant.cloud.cluster.v1.DatabaseConfigurationStorage.
 * Use `create(DatabaseConfigurationStorageSchema)` to create a new message.
 */
export declare const DatabaseConfigurationStorageSchema: GenMessage<DatabaseConfigurationStorage, {validType: DatabaseConfigurationStorageValid}>;

/**
 * The performance related Qdrant database storage configuration
 *
 * @generated from message qdrant.cloud.cluster.v1.DatabaseConfigurationStoragePerformance
 */
export declare type DatabaseConfigurationStoragePerformance = Message<"qdrant.cloud.cluster.v1.DatabaseConfigurationStoragePerformance"> & {
  /**
   * CPU budget, how many CPUs (threads) to allocate for an optimization job.
   * If 0 - auto selection, keep 1 or more CPUs unallocated depending on CPU size
   * If negative - subtract this number of CPUs from the available CPUs.
   * If positive - use this exact number of CPUs.
   *
   * @generated from field: int32 optimizer_cpu_budget = 1;
   */
  optimizerCpuBudget: number;

  /**
   * Enable async scorer which uses io_uring when rescoring.
   * Only supported on Linux, must be enabled in your kernel.
   * See: https://qdrant.tech/articles/io_uring/#and-what-about-qdrant
   *
   * @generated from field: bool async_scorer = 2;
   */
  asyncScorer: boolean;
};

export declare type DatabaseConfigurationStoragePerformanceValid = DatabaseConfigurationStoragePerformance;

/**
 * Describes the message qdrant.cloud.cluster.v1.DatabaseConfigurationStoragePerformance.
 * Use `create(DatabaseConfigurationStoragePerformanceSchema)` to create a new message.
 */
export declare const DatabaseConfigurationStoragePerformanceSchema: GenMessage<DatabaseConfigurationStoragePerformance, {validType: DatabaseConfigurationStoragePerformanceValid}>;

/**
 * The Qdrant database service configuration
 *
 * @generated from message qdrant.cloud.cluster.v1.DatabaseConfigurationService
 */
export declare type DatabaseConfigurationService = Message<"qdrant.cloud.cluster.v1.DatabaseConfigurationService"> & {
  /**
   * Set an api-key.
   * This setting is for hybrid cloud clusters only, for managed cloud please use qdrant.cloud.cluster.auth.[v1|v2].DatabaseApiKeyService to configure keys.
   * If set, all requests must include a header with the api-key.
   * example header: `api-key: <API-KEY>`
   *
   * @generated from field: optional qdrant.cloud.common.v1.SecretKeyRef api_key = 1;
   */
  apiKey?: SecretKeyRef;

  /**
   * Set an api-key for read-only operations.
   * This setting is for hybrid cloud clusters only, for managed cloud please use qdrant.cloud.cluster.auth.[v1|v2].DatabaseApiKeyService to configure keys.
   * If set, all requests must include a header with the api-key.
   * example header: `api-key: <API-KEY>`
   *
   * @generated from field: optional qdrant.cloud.common.v1.SecretKeyRef read_only_api_key = 2;
   */
  readOnlyApiKey?: SecretKeyRef;

  /**
   * Enable JWT Role Based Access Control (RBAC).
   * This setting is for both managed and hybrid cloud clusters.
   * If enabled, you can generate JWT tokens with fine-grained rules for access control.
   * Use generated token instead of API key.
   *
   * @generated from field: bool jwt_rbac = 3;
   */
  jwtRbac: boolean;

  /**
   * Enable HTTPS for the REST and gRPC API
   * This setting is for hybrid cloud clusters only, for managed cloud clusters the platform controls it (and clients need to use a secure connection).
   *
   * @generated from field: bool enable_tls = 4;
   */
  enableTls: boolean;
};

export declare type DatabaseConfigurationServiceValid = DatabaseConfigurationService;

/**
 * Describes the message qdrant.cloud.cluster.v1.DatabaseConfigurationService.
 * Use `create(DatabaseConfigurationServiceSchema)` to create a new message.
 */
export declare const DatabaseConfigurationServiceSchema: GenMessage<DatabaseConfigurationService, {validType: DatabaseConfigurationServiceValid}>;

/**
 * DatabaseConfigurationTls contains the information to setup a TLS connection to the database endpoint
 *
 * @generated from message qdrant.cloud.cluster.v1.DatabaseConfigurationTls
 */
export declare type DatabaseConfigurationTls = Message<"qdrant.cloud.cluster.v1.DatabaseConfigurationTls"> & {
  /**
   * Secret to use for the certificate
   *
   * @generated from field: qdrant.cloud.common.v1.SecretKeyRef cert = 1;
   */
  cert?: SecretKeyRef;

  /**
   * Secret to use for the private key
   *
   * @generated from field: qdrant.cloud.common.v1.SecretKeyRef key = 2;
   */
  key?: SecretKeyRef;
};

/**
 * DatabaseConfigurationTls contains the information to setup a TLS connection to the database endpoint
 *
 * @generated from message qdrant.cloud.cluster.v1.DatabaseConfigurationTls
 */
export declare type DatabaseConfigurationTlsValid = Message<"qdrant.cloud.cluster.v1.DatabaseConfigurationTls"> & {
  /**
   * Secret to use for the certificate
   *
   * @generated from field: qdrant.cloud.common.v1.SecretKeyRef cert = 1;
   */
  cert: SecretKeyRefValid;

  /**
   * Secret to use for the private key
   *
   * @generated from field: qdrant.cloud.common.v1.SecretKeyRef key = 2;
   */
  key: SecretKeyRefValid;
};

/**
 * Describes the message qdrant.cloud.cluster.v1.DatabaseConfigurationTls.
 * Use `create(DatabaseConfigurationTlsSchema)` to create a new message.
 */
export declare const DatabaseConfigurationTlsSchema: GenMessage<DatabaseConfigurationTls, {validType: DatabaseConfigurationTlsValid}>;

/**
 * DatabaseConfigurationInference contains cloud inferencing configuration
 *
 * @generated from message qdrant.cloud.cluster.v1.DatabaseConfigurationInference
 */
export declare type DatabaseConfigurationInference = Message<"qdrant.cloud.cluster.v1.DatabaseConfigurationInference"> & {
  /**
   * If true, the database is configured to use cloud inferencing
   *
   * @generated from field: bool enabled = 1;
   */
  enabled: boolean;
};

export declare type DatabaseConfigurationInferenceValid = DatabaseConfigurationInference;

/**
 * Describes the message qdrant.cloud.cluster.v1.DatabaseConfigurationInference.
 * Use `create(DatabaseConfigurationInferenceSchema)` to create a new message.
 */
export declare const DatabaseConfigurationInferenceSchema: GenMessage<DatabaseConfigurationInference, {validType: DatabaseConfigurationInferenceValid}>;

/**
 * AdditionalResources contains the information about additional resources
 *
 * @generated from message qdrant.cloud.cluster.v1.AdditionalResources
 */
export declare type AdditionalResources = Message<"qdrant.cloud.cluster.v1.AdditionalResources"> & {
  /**
   * Additional Disk (expressed in Gib)
   *
   * @generated from field: uint32 disk = 3;
   */
  disk: number;
};

export declare type AdditionalResourcesValid = AdditionalResources;

/**
 * Describes the message qdrant.cloud.cluster.v1.AdditionalResources.
 * Use `create(AdditionalResourcesSchema)` to create a new message.
 */
export declare const AdditionalResourcesSchema: GenMessage<AdditionalResources, {validType: AdditionalResourcesValid}>;

/**
 * The Toleration message represents a toleration object for Kubernetes.
 *
 * @generated from message qdrant.cloud.cluster.v1.Toleration
 */
export declare type Toleration = Message<"qdrant.cloud.cluster.v1.Toleration"> & {
  /**
   * The key to match against the key of a node label.
   *
   * @generated from field: string key = 1;
   */
  key: string;

  /**
   * The operator represents a key's relationship to the value.
   * The default is TOLERATION_OPERATOR_EXISTS.
   *
   * @generated from field: optional qdrant.cloud.cluster.v1.TolerationOperator operator = 2;
   */
  operator?: TolerationOperator;

  /**
   * The value to match against the value of a node label.
   *
   * @generated from field: string value = 3;
   */
  value: string;

  /**
   * The effect indicates the taint effect to match.
   * The default is TOLERATION_EFFECT_NO_SCHEDULE.
   *
   * @generated from field: optional qdrant.cloud.cluster.v1.TolerationEffect effect = 4;
   */
  effect?: TolerationEffect;

  /**
   * The toleration seconds indicates the duration to tolerate the taint.
   *
   * @generated from field: optional uint64 toleration_seconds = 5;
   */
  tolerationSeconds?: bigint;
};

export declare type TolerationValid = Toleration;

/**
 * Describes the message qdrant.cloud.cluster.v1.Toleration.
 * Use `create(TolerationSchema)` to create a new message.
 */
export declare const TolerationSchema: GenMessage<Toleration, {validType: TolerationValid}>;

/**
 * ClusterState represents the current state of a cluster
 * All fields in this message are read-only.
 *
 * @generated from message qdrant.cloud.cluster.v1.ClusterState
 */
export declare type ClusterState = Message<"qdrant.cloud.cluster.v1.ClusterState"> & {
  /**
   * Version of the cluster software.
   *
   * @generated from field: string version = 1;
   */
  version: string;

  /**
   * Number of cluster nodes that are up and running.
   *
   * @generated from field: uint32 nodes_up = 2;
   */
  nodesUp: number;

  /**
   * The date and time when the cluster was restarted.
   *
   * @generated from field: google.protobuf.Timestamp restarted_at = 3;
   */
  restartedAt?: Timestamp;

  /**
   * Current phase of the cluster.
   *
   * @generated from field: qdrant.cloud.cluster.v1.ClusterPhase phase = 4;
   */
  phase: ClusterPhase;

  /**
   * Reason for the current phase of the cluster.
   *
   * @generated from field: string reason = 5;
   */
  reason: string;

  /**
   * Endpoint information to access the qdrant cluster (aka database).
   *
   * @generated from field: qdrant.cloud.cluster.v1.ClusterEndpoint endpoint = 6;
   */
  endpoint?: ClusterEndpoint;

  /**
   * The resources used by the cluster per node.
   * For the complete cluster you have to multiply by cluster.configuration.number_of_nodes
   *
   * @generated from field: qdrant.cloud.cluster.v1.ClusterNodeResourcesSummary resources = 7;
   */
  resources?: ClusterNodeResourcesSummary;

  /**
   * Whether the cluster can be scaled up or down.
   *
   * @generated from field: qdrant.cloud.cluster.v1.ClusterScalabilityInfo scalability_info = 8;
   */
  scalabilityInfo?: ClusterScalabilityInfo;

  /**
   * List of nodes in the cluster.
   *
   * @generated from field: repeated qdrant.cloud.cluster.v1.ClusterNodeInfo nodes = 9;
   */
  nodes: ClusterNodeInfo[];
};

/**
 * ClusterState represents the current state of a cluster
 * All fields in this message are read-only.
 *
 * @generated from message qdrant.cloud.cluster.v1.ClusterState
 */
export declare type ClusterStateValid = Message<"qdrant.cloud.cluster.v1.ClusterState"> & {
  /**
   * Version of the cluster software.
   *
   * @generated from field: string version = 1;
   */
  version: string;

  /**
   * Number of cluster nodes that are up and running.
   *
   * @generated from field: uint32 nodes_up = 2;
   */
  nodesUp: number;

  /**
   * The date and time when the cluster was restarted.
   *
   * @generated from field: google.protobuf.Timestamp restarted_at = 3;
   */
  restartedAt?: Timestamp;

  /**
   * Current phase of the cluster.
   *
   * @generated from field: qdrant.cloud.cluster.v1.ClusterPhase phase = 4;
   */
  phase: ClusterPhase;

  /**
   * Reason for the current phase of the cluster.
   *
   * @generated from field: string reason = 5;
   */
  reason: string;

  /**
   * Endpoint information to access the qdrant cluster (aka database).
   *
   * @generated from field: qdrant.cloud.cluster.v1.ClusterEndpoint endpoint = 6;
   */
  endpoint: ClusterEndpointValid;

  /**
   * The resources used by the cluster per node.
   * For the complete cluster you have to multiply by cluster.configuration.number_of_nodes
   *
   * @generated from field: qdrant.cloud.cluster.v1.ClusterNodeResourcesSummary resources = 7;
   */
  resources: ClusterNodeResourcesSummaryValid;

  /**
   * Whether the cluster can be scaled up or down.
   *
   * @generated from field: qdrant.cloud.cluster.v1.ClusterScalabilityInfo scalability_info = 8;
   */
  scalabilityInfo: ClusterScalabilityInfoValid;

  /**
   * List of nodes in the cluster.
   *
   * @generated from field: repeated qdrant.cloud.cluster.v1.ClusterNodeInfo nodes = 9;
   */
  nodes: ClusterNodeInfoValid[];
};

/**
 * Describes the message qdrant.cloud.cluster.v1.ClusterState.
 * Use `create(ClusterStateSchema)` to create a new message.
 */
export declare const ClusterStateSchema: GenMessage<ClusterState, {validType: ClusterStateValid}>;

/**
 * ClusterNodeInfo represents a node in a cluster.
 * All fields in this message are read-only.
 *
 * @generated from message qdrant.cloud.cluster.v1.ClusterNodeInfo
 */
export declare type ClusterNodeInfo = Message<"qdrant.cloud.cluster.v1.ClusterNodeInfo"> & {
  /**
   * Name specifies the name of the node.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * StartedAt specifies the time when the node started.
   *
   * @generated from field: google.protobuf.Timestamp started_at = 2;
   */
  startedAt?: Timestamp;

  /**
   * Version specifies the version of Qdrant running on the node.
   *
   * @generated from field: string version = 3;
   */
  version: string;

  /**
   * Endpoint specific to this node.
   *
   * @generated from field: qdrant.cloud.cluster.v1.ClusterEndpoint endpoint = 4;
   */
  endpoint?: ClusterEndpoint;

  /**
   * State of the node.
   *
   * @generated from field: qdrant.cloud.cluster.v1.ClusterNodeState state = 10;
   */
  state: ClusterNodeState;
};

export declare type ClusterNodeInfoValid = ClusterNodeInfo;

/**
 * Describes the message qdrant.cloud.cluster.v1.ClusterNodeInfo.
 * Use `create(ClusterNodeInfoSchema)` to create a new message.
 */
export declare const ClusterNodeInfoSchema: GenMessage<ClusterNodeInfo, {validType: ClusterNodeInfoValid}>;

/**
 * Endpoint information to access the qdrant cluster (aka database) or a specific node in the cluster.
 * All fields in this message are a read-only field.
 *
 * @generated from message qdrant.cloud.cluster.v1.ClusterEndpoint
 */
export declare type ClusterEndpoint = Message<"qdrant.cloud.cluster.v1.ClusterEndpoint"> & {
  /**
   * URL to access the qdrant cluster (aka database) without port
   *
   * @generated from field: string url = 1;
   */
  url: string;

  /**
   * The port to use for HTTP REST calls (6333)
   *
   * @generated from field: int32 rest_port = 2;
   */
  restPort: number;

  /**
   * The port to use for gRPC calls (6334)
   *
   * @generated from field: int32 grpc_port = 3;
   */
  grpcPort: number;
};

export declare type ClusterEndpointValid = ClusterEndpoint;

/**
 * Describes the message qdrant.cloud.cluster.v1.ClusterEndpoint.
 * Use `create(ClusterEndpointSchema)` to create a new message.
 */
export declare const ClusterEndpointSchema: GenMessage<ClusterEndpoint, {validType: ClusterEndpointValid}>;

/**
 * ClusterNodeResourcesSummary represents the resources used in this cluster per node.
 *
 * @generated from message qdrant.cloud.cluster.v1.ClusterNodeResourcesSummary
 */
export declare type ClusterNodeResourcesSummary = Message<"qdrant.cloud.cluster.v1.ClusterNodeResourcesSummary"> & {
  /**
   * Disk resources
   *
   * @generated from field: qdrant.cloud.cluster.v1.ClusterNodeResources disk = 1;
   */
  disk?: ClusterNodeResources;

  /**
   * Memory resources
   *
   * @generated from field: qdrant.cloud.cluster.v1.ClusterNodeResources ram = 2;
   */
  ram?: ClusterNodeResources;

  /**
   * CPU resources
   *
   * @generated from field: qdrant.cloud.cluster.v1.ClusterNodeResources cpu = 3;
   */
  cpu?: ClusterNodeResources;
};

/**
 * ClusterNodeResourcesSummary represents the resources used in this cluster per node.
 *
 * @generated from message qdrant.cloud.cluster.v1.ClusterNodeResourcesSummary
 */
export declare type ClusterNodeResourcesSummaryValid = Message<"qdrant.cloud.cluster.v1.ClusterNodeResourcesSummary"> & {
  /**
   * Disk resources
   *
   * @generated from field: qdrant.cloud.cluster.v1.ClusterNodeResources disk = 1;
   */
  disk: ClusterNodeResourcesValid;

  /**
   * Memory resources
   *
   * @generated from field: qdrant.cloud.cluster.v1.ClusterNodeResources ram = 2;
   */
  ram: ClusterNodeResourcesValid;

  /**
   * CPU resources
   *
   * @generated from field: qdrant.cloud.cluster.v1.ClusterNodeResources cpu = 3;
   */
  cpu: ClusterNodeResourcesValid;
};

/**
 * Describes the message qdrant.cloud.cluster.v1.ClusterNodeResourcesSummary.
 * Use `create(ClusterNodeResourcesSummarySchema)` to create a new message.
 */
export declare const ClusterNodeResourcesSummarySchema: GenMessage<ClusterNodeResourcesSummary, {validType: ClusterNodeResourcesSummaryValid}>;

/**
 * ClusterNodeResources represents the allocation of various resources for a cluster per node.
 *
 * @generated from message qdrant.cloud.cluster.v1.ClusterNodeResources
 */
export declare type ClusterNodeResources = Message<"qdrant.cloud.cluster.v1.ClusterNodeResources"> & {
  /**
   * Base resources that are part of the standard allocation for the cluster per node.
   * This includes default CPU, memory, storage, etc.
   *
   * @generated from field: double base = 1;
   */
  base: number;

  /**
   * Complimentary resources provided to the cluster at no additional cost.
   * This might include complimentary network bandwidth, credits, etc.
   *
   * @generated from field: double complimentary = 2;
   */
  complimentary: number;

  /**
   * Additional resources allocated to the cluster.
   * This could include additional storage, compute power, etc.
   *
   * @generated from field: double additional = 3;
   */
  additional: number;

  /**
   * The reserved is the amount used by the system, which cannot be used by the database itself.
   *
   * @generated from field: double reserved = 4;
   */
  reserved: number;

  /**
   * The available is the total (base+complimentary+additional) - reserved
   *
   * @generated from field: double available = 5;
   */
  available: number;
};

export declare type ClusterNodeResourcesValid = ClusterNodeResources;

/**
 * Describes the message qdrant.cloud.cluster.v1.ClusterNodeResources.
 * Use `create(ClusterNodeResourcesSchema)` to create a new message.
 */
export declare const ClusterNodeResourcesSchema: GenMessage<ClusterNodeResources, {validType: ClusterNodeResourcesValid}>;

/**
 * ClusterScalabilityInfo provides information about the
 *
 * @generated from message qdrant.cloud.cluster.v1.ClusterScalabilityInfo
 */
export declare type ClusterScalabilityInfo = Message<"qdrant.cloud.cluster.v1.ClusterScalabilityInfo"> & {
  /**
   * The current scalability status of the cluster.
   *
   * @generated from field: qdrant.cloud.cluster.v1.ClusterScalabilityStatus status = 1;
   */
  status: ClusterScalabilityStatus;

  /**
   * Optional human-readable reason providing more context about the scalability status.
   * When a cluster is not scalable, this field explains why.
   *
   * @generated from field: optional string reason = 2;
   */
  reason?: string;
};

export declare type ClusterScalabilityInfoValid = ClusterScalabilityInfo;

/**
 * Describes the message qdrant.cloud.cluster.v1.ClusterScalabilityInfo.
 * Use `create(ClusterScalabilityInfoSchema)` to create a new message.
 */
export declare const ClusterScalabilityInfoSchema: GenMessage<ClusterScalabilityInfo, {validType: ClusterScalabilityInfoValid}>;

/**
 * QdrantRelease represent a single Qdrant release
 *
 * @generated from message qdrant.cloud.cluster.v1.QdrantRelease
 */
export declare type QdrantRelease = Message<"qdrant.cloud.cluster.v1.QdrantRelease"> & {
  /**
   * Version of the Qdrant release
   *
   * @generated from field: string version = 1;
   */
  version: string;

  /**
   * Flag to indicate if this is the default release
   * There can be at most a single item in the list that have this property set.
   *
   * @generated from field: bool default = 2;
   */
  default: boolean;

  /**
   * URL to the release notes
   *
   * @generated from field: optional string release_notes_url = 3;
   */
  releaseNotesUrl?: string;

  /**
   * Additional message regarding this release that might be useful to the client"
   *
   * @generated from field: optional string remarks = 4;
   */
  remarks?: string;

  /**
   * True, if the release version is end of life and not supported anymore
   *
   * @generated from field: bool end_of_life = 5;
   */
  endOfLife: boolean;

  /**
   * True, if the release is not available for the cluster creation or updates
   *
   * @generated from field: bool unavailable = 6;
   */
  unavailable: boolean;
};

export declare type QdrantReleaseValid = QdrantRelease;

/**
 * Describes the message qdrant.cloud.cluster.v1.QdrantRelease.
 * Use `create(QdrantReleaseSchema)` to create a new message.
 */
export declare const QdrantReleaseSchema: GenMessage<QdrantRelease, {validType: QdrantReleaseValid}>;

/**
 * CreateClusterFromBackupRequest is the request for the CreateCluster function.
 *
 * @generated from message qdrant.cloud.cluster.v1.CreateClusterFromBackupRequest
 */
export declare type CreateClusterFromBackupRequest = Message<"qdrant.cloud.cluster.v1.CreateClusterFromBackupRequest"> & {
  /**
   * The identifier of the account (in GUID format).
   * This is a required field.
   *
   * @generated from field: string account_id = 1;
   */
  accountId: string;

  /**
   * The identifier of the backup (in GUID format).
   * This is a required field.
   *
   * @generated from field: string backup_id = 2;
   */
  backupId: string;

  /**
   * Name of the new cluster
   *
   * @generated from field: string cluster_name = 3;
   */
  clusterName: string;
};

export declare type CreateClusterFromBackupRequestValid = CreateClusterFromBackupRequest;

/**
 * Describes the message qdrant.cloud.cluster.v1.CreateClusterFromBackupRequest.
 * Use `create(CreateClusterFromBackupRequestSchema)` to create a new message.
 */
export declare const CreateClusterFromBackupRequestSchema: GenMessage<CreateClusterFromBackupRequest, {validType: CreateClusterFromBackupRequestValid}>;

/**
 * CreateClusterFromBackupResponse is the response for the CreateCluster function.
 *
 * @generated from message qdrant.cloud.cluster.v1.CreateClusterFromBackupResponse
 */
export declare type CreateClusterFromBackupResponse = Message<"qdrant.cloud.cluster.v1.CreateClusterFromBackupResponse"> & {
  /**
   * Cluster created from the backup
   *
   * @generated from field: qdrant.cloud.cluster.v1.Cluster cluster = 1;
   */
  cluster?: Cluster;
};

/**
 * CreateClusterFromBackupResponse is the response for the CreateCluster function.
 *
 * @generated from message qdrant.cloud.cluster.v1.CreateClusterFromBackupResponse
 */
export declare type CreateClusterFromBackupResponseValid = Message<"qdrant.cloud.cluster.v1.CreateClusterFromBackupResponse"> & {
  /**
   * Cluster created from the backup
   *
   * @generated from field: qdrant.cloud.cluster.v1.Cluster cluster = 1;
   */
  cluster: ClusterValid;
};

/**
 * Describes the message qdrant.cloud.cluster.v1.CreateClusterFromBackupResponse.
 * Use `create(CreateClusterFromBackupResponseSchema)` to create a new message.
 */
export declare const CreateClusterFromBackupResponseSchema: GenMessage<CreateClusterFromBackupResponse, {validType: CreateClusterFromBackupResponseValid}>;

/**
 * ClusterServiceType defines the type of service to use for the cluster.
 * See: https://kubernetes.io/docs/reference/kubernetes-api/service-resources/service-v1/#ServiceSpec
 *
 * @generated from enum qdrant.cloud.cluster.v1.ClusterServiceType
 */
export enum ClusterServiceType {
  /**
   * Service type is unspecified.
   *
   * @generated from enum value: CLUSTER_SERVICE_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Use a service configured with type ClusterIP.
   *
   * @generated from enum value: CLUSTER_SERVICE_TYPE_CLUSTER_IP = 1;
   */
  CLUSTER_IP = 1,

  /**
   * Use a service configured with type NodePort.
   *
   * @generated from enum value: CLUSTER_SERVICE_TYPE_NODE_PORT = 2;
   */
  NODE_PORT = 2,

  /**
   * Use a service configured with type LoadBalancer.
   *
   * @generated from enum value: CLUSTER_SERVICE_TYPE_LOAD_BALANCER = 3;
   */
  LOAD_BALANCER = 3,
}

/**
 * Describes the enum qdrant.cloud.cluster.v1.ClusterServiceType.
 */
export declare const ClusterServiceTypeSchema: GenEnum<ClusterServiceType>;

/**
 * ClusterConfigurationGpuType defines GPU types available for clusters.
 *
 * @generated from enum qdrant.cloud.cluster.v1.ClusterConfigurationGpuType
 */
export enum ClusterConfigurationGpuType {
  /**
   * No GPU is configured.
   *
   * @generated from enum value: CLUSTER_CONFIGURATION_GPU_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Use an NVIDIA GPU.
   *
   * @generated from enum value: CLUSTER_CONFIGURATION_GPU_TYPE_NVIDIA = 1;
   */
  NVIDIA = 1,

  /**
   * Use an AMD GPU.
   *
   * @generated from enum value: CLUSTER_CONFIGURATION_GPU_TYPE_AMD = 2;
   */
  AMD = 2,
}

/**
 * Describes the enum qdrant.cloud.cluster.v1.ClusterConfigurationGpuType.
 */
export declare const ClusterConfigurationGpuTypeSchema: GenEnum<ClusterConfigurationGpuType>;

/**
 * ClusterConfigurationRestartPolicy defines restart strategies for the cluster's database.
 *
 * @generated from enum qdrant.cloud.cluster.v1.ClusterConfigurationRestartPolicy
 */
export enum ClusterConfigurationRestartPolicy {
  /**
   * Restart policy is unspecified.
   *
   * @generated from enum value: CLUSTER_CONFIGURATION_RESTART_POLICY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Rolling restart policy (one by one).
   *
   * @generated from enum value: CLUSTER_CONFIGURATION_RESTART_POLICY_ROLLING = 1;
   */
  ROLLING = 1,

  /**
   * Parallel restart policy (restart all at once).
   *
   * @generated from enum value: CLUSTER_CONFIGURATION_RESTART_POLICY_PARALLEL = 2;
   */
  PARALLEL = 2,

  /**
   * Automatic restart policy.
   *
   * @generated from enum value: CLUSTER_CONFIGURATION_RESTART_POLICY_AUTOMATIC = 3;
   */
  AUTOMATIC = 3,
}

/**
 * Describes the enum qdrant.cloud.cluster.v1.ClusterConfigurationRestartPolicy.
 */
export declare const ClusterConfigurationRestartPolicySchema: GenEnum<ClusterConfigurationRestartPolicy>;

/**
 * ClusterConfigurationRebalanceStrategy defines shard rebalancing strategies.
 *
 * @generated from enum qdrant.cloud.cluster.v1.ClusterConfigurationRebalanceStrategy
 */
export enum ClusterConfigurationRebalanceStrategy {
  /**
   * No rebalancing strategy is configured.
   *
   * @generated from enum value: CLUSTER_CONFIGURATION_REBALANCE_STRATEGY_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Rebalance shards by count.
   *
   * @generated from enum value: CLUSTER_CONFIGURATION_REBALANCE_STRATEGY_BY_COUNT = 1;
   */
  BY_COUNT = 1,

  /**
   * Rebalance shards by size.
   *
   * @generated from enum value: CLUSTER_CONFIGURATION_REBALANCE_STRATEGY_BY_SIZE = 2;
   */
  BY_SIZE = 2,

  /**
   * Rebalance shards by both count and size.
   *
   * @generated from enum value: CLUSTER_CONFIGURATION_REBALANCE_STRATEGY_BY_COUNT_AND_SIZE = 3;
   */
  BY_COUNT_AND_SIZE = 3,
}

/**
 * Describes the enum qdrant.cloud.cluster.v1.ClusterConfigurationRebalanceStrategy.
 */
export declare const ClusterConfigurationRebalanceStrategySchema: GenEnum<ClusterConfigurationRebalanceStrategy>;

/**
 * DatabaseConfigurationLogLevel defines the supported logging levels for the
 * Qdrant database. See: https://docs.rs/log/latest/log/enum.LevelFilter.html
 *
 * @generated from enum qdrant.cloud.cluster.v1.DatabaseConfigurationLogLevel
 */
export enum DatabaseConfigurationLogLevel {
  /**
   * Unspecified log level.
   *
   * @generated from enum value: DATABASE_CONFIGURATION_LOG_LEVEL_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Trace log level.
   *
   * @generated from enum value: DATABASE_CONFIGURATION_LOG_LEVEL_TRACE = 1;
   */
  TRACE = 1,

  /**
   * Debug log level.
   *
   * @generated from enum value: DATABASE_CONFIGURATION_LOG_LEVEL_DEBUG = 2;
   */
  DEBUG = 2,

  /**
   * Info log level.
   *
   * @generated from enum value: DATABASE_CONFIGURATION_LOG_LEVEL_INFO = 3;
   */
  INFO = 3,

  /**
   * Warn log level.
   *
   * @generated from enum value: DATABASE_CONFIGURATION_LOG_LEVEL_WARN = 4;
   */
  WARN = 4,

  /**
   * Error log level.
   *
   * @generated from enum value: DATABASE_CONFIGURATION_LOG_LEVEL_ERROR = 5;
   */
  ERROR = 5,

  /**
   * Off log level.
   *
   * @generated from enum value: DATABASE_CONFIGURATION_LOG_LEVEL_OFF = 6;
   */
  OFF = 6,
}

/**
 * Describes the enum qdrant.cloud.cluster.v1.DatabaseConfigurationLogLevel.
 */
export declare const DatabaseConfigurationLogLevelSchema: GenEnum<DatabaseConfigurationLogLevel>;

/**
 * TolerationOperator defines the valid operators for tolerations.
 * See: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
 *
 * @generated from enum qdrant.cloud.cluster.v1.TolerationOperator
 */
export enum TolerationOperator {
  /**
   * Unspecified operator.
   *
   * @generated from enum value: TOLERATION_OPERATOR_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The operator means the key exists.
   *
   * @generated from enum value: TOLERATION_OPERATOR_EXISTS = 1;
   */
  EXISTS = 1,

  /**
   * The operator means the key equals the given value.
   *
   * @generated from enum value: TOLERATION_OPERATOR_EQUAL = 2;
   */
  EQUAL = 2,
}

/**
 * Describes the enum qdrant.cloud.cluster.v1.TolerationOperator.
 */
export declare const TolerationOperatorSchema: GenEnum<TolerationOperator>;

/**
 * TolerationEffect represents the effects a taint has on pod scheduling and eviction.
 * See: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
 *
 * @generated from enum qdrant.cloud.cluster.v1.TolerationEffect
 */
export enum TolerationEffect {
  /**
   * Unspecified effect.
   *
   * @generated from enum value: TOLERATION_EFFECT_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * NoSchedule taint effect.
   *
   * @generated from enum value: TOLERATION_EFFECT_NO_SCHEDULE = 1;
   */
  NO_SCHEDULE = 1,

  /**
   * PreferNoSchedule taint effect.
   *
   * @generated from enum value: TOLERATION_EFFECT_PREFER_NO_SCHEDULE = 2;
   */
  PREFER_NO_SCHEDULE = 2,

  /**
   * NoExecute taint effect.
   *
   * @generated from enum value: TOLERATION_EFFECT_NO_EXECUTE = 3;
   */
  NO_EXECUTE = 3,
}

/**
 * Describes the enum qdrant.cloud.cluster.v1.TolerationEffect.
 */
export declare const TolerationEffectSchema: GenEnum<TolerationEffect>;

/**
 * Defines the operational or transitional state of the Qdrant cluster.
 *
 * @generated from enum qdrant.cloud.cluster.v1.ClusterPhase
 */
export enum ClusterPhase {
  /**
   * The phase is unknown or not specified. Should not normally be used.
   *
   * @generated from enum value: CLUSTER_PHASE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The cluster is currently being created.
   *
   * @generated from enum value: CLUSTER_PHASE_CREATING = 1;
   */
  CREATING = 1,

  /**
   * The cluster creation process failed.
   *
   * @generated from enum value: CLUSTER_PHASE_FAILED_TO_CREATE = 2;
   */
  FAILED_TO_CREATE = 2,

  /**
   * The cluster configuration is being updated.
   *
   * @generated from enum value: CLUSTER_PHASE_UPDATING = 3;
   */
  UPDATING = 3,

  /**
   * The cluster update process failed.
   *
   * @generated from enum value: CLUSTER_PHASE_FAILED_TO_UPDATE = 4;
   */
  FAILED_TO_UPDATE = 4,

  /**
   * The cluster is undergoing scaling (up or down).
   *
   * @generated from enum value: CLUSTER_PHASE_SCALING = 5;
   */
  SCALING = 5,

  /**
   * The Qdrant version in the cluster is being upgraded.
   *
   * @generated from enum value: CLUSTER_PHASE_UPGRADING = 6;
   */
  UPGRADING = 6,

  /**
   * The cluster is in the process of being suspended.
   *
   * @generated from enum value: CLUSTER_PHASE_SUSPENDING = 7;
   */
  SUSPENDING = 7,

  /**
   * The cluster is currently suspended (inactive).
   *
   * @generated from enum value: CLUSTER_PHASE_SUSPENDED = 8;
   */
  SUSPENDED = 8,

  /**
   * The cluster suspension process failed.
   *
   * @generated from enum value: CLUSTER_PHASE_FAILED_TO_SUSPEND = 9;
   */
  FAILED_TO_SUSPEND = 9,

  /**
   * The cluster is resuming from a suspended state.
   *
   * @generated from enum value: CLUSTER_PHASE_RESUMING = 10;
   */
  RESUMING = 10,

  /**
   * The cluster resumption process failed.
   *
   * @generated from enum value: CLUSTER_PHASE_FAILED_TO_RESUME = 11;
   */
  FAILED_TO_RESUME = 11,

  /**
   * The cluster is operational and healthy.
   *
   * @generated from enum value: CLUSTER_PHASE_HEALTHY = 12;
   */
  HEALTHY = 12,

  /**
   * The cluster is operational but not all components are ready or healthy.
   *
   * @generated from enum value: CLUSTER_PHASE_NOT_READY = 13;
   */
  NOT_READY = 13,

  /**
   * The cluster is in recovery mode, potentially after a failure.
   *
   * @generated from enum value: CLUSTER_PHASE_RECOVERY_MODE = 14;
   */
  RECOVERY_MODE = 14,

  /**
   * The cluster is under manual maintenance.
   *
   * @generated from enum value: CLUSTER_PHASE_MANUAL_MAINTENANCE = 15;
   */
  MANUAL_MAINTENANCE = 15,

  /**
   * There was an error syncing the cluster in the cloud provider region.
   *
   * @generated from enum value: CLUSTER_PHASE_FAILED_TO_SYNC = 16;
   */
  FAILED_TO_SYNC = 16,

  /**
   * The cluster was expected but not found in the cloud provider region.
   *
   * @generated from enum value: CLUSTER_PHASE_NOT_FOUND = 17;
   */
  NOT_FOUND = 17,
}

/**
 * Describes the enum qdrant.cloud.cluster.v1.ClusterPhase.
 */
export declare const ClusterPhaseSchema: GenEnum<ClusterPhase>;

/**
 * ClusterNodeState represents the state of a cluster node.
 *
 * @generated from enum qdrant.cloud.cluster.v1.ClusterNodeState
 */
export enum ClusterNodeState {
  /**
   * The state is unspecified.
   *
   * @generated from enum value: CLUSTER_NODE_STATE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The node is starting.
   *
   * @generated from enum value: CLUSTER_NODE_STATE_STARTING = 1;
   */
  STARTING = 1,

  /**
   * The node is healthy.
   *
   * @generated from enum value: CLUSTER_NODE_STATE_HEALTHY = 2;
   */
  HEALTHY = 2,

  /**
   * The node is unhealthy.
   *
   * @generated from enum value: CLUSTER_NODE_STATE_UNHEALTHY = 3;
   */
  UNHEALTHY = 3,

  /**
   * The node is suspended.
   *
   * @generated from enum value: CLUSTER_NODE_STATE_SUSPENDED = 4;
   */
  SUSPENDED = 4,
}

/**
 * Describes the enum qdrant.cloud.cluster.v1.ClusterNodeState.
 */
export declare const ClusterNodeStateSchema: GenEnum<ClusterNodeState>;

/**
 * ClusterScalabilityStatus defines the scalability states of a cluster.
 *
 * @generated from enum qdrant.cloud.cluster.v1.ClusterScalabilityStatus
 */
export enum ClusterScalabilityStatus {
  /**
   * Scalability status is unspecified.
   *
   * @generated from enum value: CLUSTER_SCALABILITY_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * The cluster is not scalable.
   *
   * @generated from enum value: CLUSTER_SCALABILITY_STATUS_NOT_SCALABLE = 1;
   */
  NOT_SCALABLE = 1,

  /**
   * The cluster supports scaling operations.
   *
   * @generated from enum value: CLUSTER_SCALABILITY_STATUS_SCALABLE = 2;
   */
  SCALABLE = 2,
}

/**
 * Describes the enum qdrant.cloud.cluster.v1.ClusterScalabilityStatus.
 */
export declare const ClusterScalabilityStatusSchema: GenEnum<ClusterScalabilityStatus>;

/**
 * ClusterService is the API used to configure cluster objects.
 *
 * @generated from service qdrant.cloud.cluster.v1.ClusterService
 */
export declare const ClusterService: GenService<{
  /**
   * Lists all clusters in the account identified by the given ID.
   * Required permissions:
   * - read:clusters
   *
   * @generated from rpc qdrant.cloud.cluster.v1.ClusterService.ListClusters
   */
  listClusters: {
    methodKind: "unary";
    input: typeof ListClustersRequestSchema;
    output: typeof ListClustersResponseSchema;
  },
  /**
   * Gets a cluster in the account identified by the given ID.
   * Required permissions:
   * - read:clusters
   *
   * @generated from rpc qdrant.cloud.cluster.v1.ClusterService.GetCluster
   */
  getCluster: {
    methodKind: "unary";
    input: typeof GetClusterRequestSchema;
    output: typeof GetClusterResponseSchema;
  },
  /**
   * Creates a cluster in the account identified by the given ID.
   * Required permissions:
   * - write:clusters
   *
   * @generated from rpc qdrant.cloud.cluster.v1.ClusterService.CreateCluster
   */
  createCluster: {
    methodKind: "unary";
    input: typeof CreateClusterRequestSchema;
    output: typeof CreateClusterResponseSchema;
  },
  /**
   * Create a new cluster from an existing backup
   * Required permissions (both):
   * - admin:backups
   * - write:clusters
   *
   * @generated from rpc qdrant.cloud.cluster.v1.ClusterService.CreateClusterFromBackup
   */
  createClusterFromBackup: {
    methodKind: "unary";
    input: typeof CreateClusterFromBackupRequestSchema;
    output: typeof CreateClusterFromBackupResponseSchema;
  },
  /**
   * Updates a cluster in the account identified by the given ID.
   * Required permissions:
   * - write:clusters
   *
   * @generated from rpc qdrant.cloud.cluster.v1.ClusterService.UpdateCluster
   */
  updateCluster: {
    methodKind: "unary";
    input: typeof UpdateClusterRequestSchema;
    output: typeof UpdateClusterResponseSchema;
  },
  /**
   * Deletes a cluster in the account identified by the given ID.
   * Required permissions:
   * - delete:clusters
   *
   * @generated from rpc qdrant.cloud.cluster.v1.ClusterService.DeleteCluster
   */
  deleteCluster: {
    methodKind: "unary";
    input: typeof DeleteClusterRequestSchema;
    output: typeof DeleteClusterResponseSchema;
  },
  /**
   * Restarts a cluster in the account identified by the given ID.
   * Required permissions:
   * - write:clusters
   *
   * @generated from rpc qdrant.cloud.cluster.v1.ClusterService.RestartCluster
   */
  restartCluster: {
    methodKind: "unary";
    input: typeof RestartClusterRequestSchema;
    output: typeof RestartClusterResponseSchema;
  },
  /**
   * Suspends a cluster in the account identified by the given ID.
   * Required permissions:
   * - write:clusters
   *
   * @generated from rpc qdrant.cloud.cluster.v1.ClusterService.SuspendCluster
   */
  suspendCluster: {
    methodKind: "unary";
    input: typeof SuspendClusterRequestSchema;
    output: typeof SuspendClusterResponseSchema;
  },
  /**
   * Suggests a unique and human-friendly name for a new cluster in the specified account.
   * This can be used by clients to pre-fill the name field when creating a new cluster.
   * Required permissions:
   * - None (authenticated only)
   *
   * @generated from rpc qdrant.cloud.cluster.v1.ClusterService.SuggestClusterName
   */
  suggestClusterName: {
    methodKind: "unary";
    input: typeof SuggestClusterNameRequestSchema;
    output: typeof SuggestClusterNameResponseSchema;
  },
  /**
   * Lists all qdrant releases in the account identified by the given ID.
   * Optional a cluster ID can be provided, the list will return the options to update to only.
   * Required permissions:
   * - read:clusters
   *
   * @generated from rpc qdrant.cloud.cluster.v1.ClusterService.ListQdrantReleases
   */
  listQdrantReleases: {
    methodKind: "unary";
    input: typeof ListQdrantReleasesRequestSchema;
    output: typeof ListQdrantReleasesResponseSchema;
  },
}>;

