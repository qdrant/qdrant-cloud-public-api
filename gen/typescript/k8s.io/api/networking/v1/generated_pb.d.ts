//
//Copyright The Kubernetes Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// This file was autogenerated by go-to-protobuf. Do not edit it manually!

// @generated by protoc-gen-es v2.7.0 with parameter "target=js+dts,import_extension=js,valid_types=protovalidate_required"
// @generated from file k8s.io/api/networking/v1/generated.proto (package k8s.io.api.networking.v1, syntax proto2)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { LabelSelector, ListMeta, ObjectMeta } from "../../../apimachinery/pkg/apis/meta/v1/generated_pb.js";
import type { LoadBalancerStatus, TypedLocalObjectReference } from "../../core/v1/generated_pb.js";
import type { IntOrString } from "../../../apimachinery/pkg/util/intstr/generated_pb.js";

/**
 * Describes the file k8s.io/api/networking/v1/generated.proto.
 */
export declare const file_k8s_io_api_networking_v1_generated: GenFile;

/**
 * HTTPIngressPath associates a path with a backend. Incoming urls matching the
 * path are forwarded to the backend.
 *
 * @generated from message k8s.io.api.networking.v1.HTTPIngressPath
 */
export declare type HTTPIngressPath = Message<"k8s.io.api.networking.v1.HTTPIngressPath"> & {
  /**
   * Path is matched against the path of an incoming request. Currently it can
   * contain characters disallowed from the conventional "path" part of a URL
   * as defined by RFC 3986. Paths must begin with a '/' and must be present
   * when using PathType with value "Exact" or "Prefix".
   * +optional
   *
   * @generated from field: optional string path = 1;
   */
  path: string;

  /**
   * PathType determines the interpretation of the Path matching. PathType can
   * be one of the following values:
   * * Exact: Matches the URL path exactly.
   * * Prefix: Matches based on a URL path prefix split by '/'. Matching is
   *   done on a path element by element basis. A path element refers is the
   *   list of labels in the path split by the '/' separator. A request is a
   *   match for path p if every p is an element-wise prefix of p of the
   *   request path. Note that if the last element of the path is a substring
   *   of the last element in request path, it is not a match (e.g. /foo/bar
   *   matches /foo/bar/baz, but does not match /foo/barbaz).
   * * ImplementationSpecific: Interpretation of the Path matching is up to
   *   the IngressClass. Implementations can treat this as a separate PathType
   *   or treat it identically to Prefix or Exact path types.
   * Implementations are required to support all path types.
   *
   * @generated from field: optional string pathType = 3;
   */
  pathType: string;

  /**
   * Backend defines the referenced service endpoint to which the traffic
   * will be forwarded to.
   *
   * @generated from field: optional k8s.io.api.networking.v1.IngressBackend backend = 2;
   */
  backend?: IngressBackend;
};

export declare type HTTPIngressPathValid = HTTPIngressPath;

/**
 * Describes the message k8s.io.api.networking.v1.HTTPIngressPath.
 * Use `create(HTTPIngressPathSchema)` to create a new message.
 */
export declare const HTTPIngressPathSchema: GenMessage<HTTPIngressPath, {validType: HTTPIngressPathValid}>;

/**
 * HTTPIngressRuleValue is a list of http selectors pointing to backends.
 * In the example: http://<host>/<path>?<searchpart> -> backend where
 * where parts of the url correspond to RFC 3986, this resource will be used
 * to match against everything after the last '/' and before the first '?'
 * or '#'.
 *
 * @generated from message k8s.io.api.networking.v1.HTTPIngressRuleValue
 */
export declare type HTTPIngressRuleValue = Message<"k8s.io.api.networking.v1.HTTPIngressRuleValue"> & {
  /**
   * A collection of paths that map requests to backends.
   * +listType=atomic
   *
   * @generated from field: repeated k8s.io.api.networking.v1.HTTPIngressPath paths = 1;
   */
  paths: HTTPIngressPath[];
};

export declare type HTTPIngressRuleValueValid = HTTPIngressRuleValue;

/**
 * Describes the message k8s.io.api.networking.v1.HTTPIngressRuleValue.
 * Use `create(HTTPIngressRuleValueSchema)` to create a new message.
 */
export declare const HTTPIngressRuleValueSchema: GenMessage<HTTPIngressRuleValue, {validType: HTTPIngressRuleValueValid}>;

/**
 * IPBlock describes a particular CIDR (Ex. "192.168.1.1/24","2001:db9::/64") that is allowed
 * to the pods matched by a NetworkPolicySpec's podSelector. The except entry describes CIDRs
 * that should not be included within this rule.
 *
 * @generated from message k8s.io.api.networking.v1.IPBlock
 */
export declare type IPBlock = Message<"k8s.io.api.networking.v1.IPBlock"> & {
  /**
   * CIDR is a string representing the IP Block
   * Valid examples are "192.168.1.1/24" or "2001:db9::/64"
   *
   * @generated from field: optional string cidr = 1;
   */
  cidr: string;

  /**
   * Except is a slice of CIDRs that should not be included within an IP Block
   * Valid examples are "192.168.1.1/24" or "2001:db9::/64"
   * Except values will be rejected if they are outside the CIDR range
   * +optional
   *
   * @generated from field: repeated string except = 2;
   */
  except: string[];
};

export declare type IPBlockValid = IPBlock;

/**
 * Describes the message k8s.io.api.networking.v1.IPBlock.
 * Use `create(IPBlockSchema)` to create a new message.
 */
export declare const IPBlockSchema: GenMessage<IPBlock, {validType: IPBlockValid}>;

/**
 * Ingress is a collection of rules that allow inbound connections to reach the
 * endpoints defined by a backend. An Ingress can be configured to give services
 * externally-reachable urls, load balance traffic, terminate SSL, offer name
 * based virtual hosting etc.
 *
 * @generated from message k8s.io.api.networking.v1.Ingress
 */
export declare type Ingress = Message<"k8s.io.api.networking.v1.Ingress"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMeta;

  /**
   * Spec is the desired state of the Ingress.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   * +optional
   *
   * @generated from field: optional k8s.io.api.networking.v1.IngressSpec spec = 2;
   */
  spec?: IngressSpec;

  /**
   * Status is the current state of the Ingress.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   * +optional
   *
   * @generated from field: optional k8s.io.api.networking.v1.IngressStatus status = 3;
   */
  status?: IngressStatus;
};

export declare type IngressValid = Ingress;

/**
 * Describes the message k8s.io.api.networking.v1.Ingress.
 * Use `create(IngressSchema)` to create a new message.
 */
export declare const IngressSchema: GenMessage<Ingress, {validType: IngressValid}>;

/**
 * IngressBackend describes all endpoints for a given service and port.
 *
 * @generated from message k8s.io.api.networking.v1.IngressBackend
 */
export declare type IngressBackend = Message<"k8s.io.api.networking.v1.IngressBackend"> & {
  /**
   * Service references a Service as a Backend.
   * This is a mutually exclusive setting with "Resource".
   * +optional
   *
   * @generated from field: optional k8s.io.api.networking.v1.IngressServiceBackend service = 4;
   */
  service?: IngressServiceBackend;

  /**
   * Resource is an ObjectRef to another Kubernetes resource in the namespace
   * of the Ingress object. If resource is specified, a service.Name and
   * service.Port must not be specified.
   * This is a mutually exclusive setting with "Service".
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.TypedLocalObjectReference resource = 3;
   */
  resource?: TypedLocalObjectReference;
};

export declare type IngressBackendValid = IngressBackend;

/**
 * Describes the message k8s.io.api.networking.v1.IngressBackend.
 * Use `create(IngressBackendSchema)` to create a new message.
 */
export declare const IngressBackendSchema: GenMessage<IngressBackend, {validType: IngressBackendValid}>;

/**
 * IngressClass represents the class of the Ingress, referenced by the Ingress
 * Spec. The `ingressclass.kubernetes.io/is-default-class` annotation can be
 * used to indicate that an IngressClass should be considered default. When a
 * single IngressClass resource has this annotation set to true, new Ingress
 * resources without a class specified will be assigned this default class.
 *
 * @generated from message k8s.io.api.networking.v1.IngressClass
 */
export declare type IngressClass = Message<"k8s.io.api.networking.v1.IngressClass"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMeta;

  /**
   * Spec is the desired state of the IngressClass.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   * +optional
   *
   * @generated from field: optional k8s.io.api.networking.v1.IngressClassSpec spec = 2;
   */
  spec?: IngressClassSpec;
};

export declare type IngressClassValid = IngressClass;

/**
 * Describes the message k8s.io.api.networking.v1.IngressClass.
 * Use `create(IngressClassSchema)` to create a new message.
 */
export declare const IngressClassSchema: GenMessage<IngressClass, {validType: IngressClassValid}>;

/**
 * IngressClassList is a collection of IngressClasses.
 *
 * @generated from message k8s.io.api.networking.v1.IngressClassList
 */
export declare type IngressClassList = Message<"k8s.io.api.networking.v1.IngressClassList"> & {
  /**
   * Standard list metadata.
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMeta;

  /**
   * Items is the list of IngressClasses.
   *
   * @generated from field: repeated k8s.io.api.networking.v1.IngressClass items = 2;
   */
  items: IngressClass[];
};

export declare type IngressClassListValid = IngressClassList;

/**
 * Describes the message k8s.io.api.networking.v1.IngressClassList.
 * Use `create(IngressClassListSchema)` to create a new message.
 */
export declare const IngressClassListSchema: GenMessage<IngressClassList, {validType: IngressClassListValid}>;

/**
 * IngressClassParametersReference identifies an API object. This can be used
 * to specify a cluster or namespace-scoped resource.
 *
 * @generated from message k8s.io.api.networking.v1.IngressClassParametersReference
 */
export declare type IngressClassParametersReference = Message<"k8s.io.api.networking.v1.IngressClassParametersReference"> & {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is
   * not specified, the specified Kind must be in the core API group. For any
   * other third-party types, APIGroup is required.
   * +optional
   *
   * @generated from field: optional string aPIGroup = 1;
   */
  aPIGroup: string;

  /**
   * Kind is the type of resource being referenced.
   *
   * @generated from field: optional string kind = 2;
   */
  kind: string;

  /**
   * Name is the name of resource being referenced.
   *
   * @generated from field: optional string name = 3;
   */
  name: string;

  /**
   * Scope represents if this refers to a cluster or namespace scoped resource.
   * This may be set to "Cluster" (default) or "Namespace".
   * +optional
   *
   * @generated from field: optional string scope = 4;
   */
  scope: string;

  /**
   * Namespace is the namespace of the resource being referenced. This field is
   * required when scope is set to "Namespace" and must be unset when scope is set to
   * "Cluster".
   * +optional
   *
   * @generated from field: optional string namespace = 5;
   */
  namespace: string;
};

export declare type IngressClassParametersReferenceValid = IngressClassParametersReference;

/**
 * Describes the message k8s.io.api.networking.v1.IngressClassParametersReference.
 * Use `create(IngressClassParametersReferenceSchema)` to create a new message.
 */
export declare const IngressClassParametersReferenceSchema: GenMessage<IngressClassParametersReference, {validType: IngressClassParametersReferenceValid}>;

/**
 * IngressClassSpec provides information about the class of an Ingress.
 *
 * @generated from message k8s.io.api.networking.v1.IngressClassSpec
 */
export declare type IngressClassSpec = Message<"k8s.io.api.networking.v1.IngressClassSpec"> & {
  /**
   * Controller refers to the name of the controller that should handle this
   * class. This allows for different "flavors" that are controlled by the
   * same controller. For example, you may have different Parameters for the
   * same implementing controller. This should be specified as a
   * domain-prefixed path no more than 250 characters in length, e.g.
   * "acme.io/ingress-controller". This field is immutable.
   *
   * @generated from field: optional string controller = 1;
   */
  controller: string;

  /**
   * Parameters is a link to a custom resource containing additional
   * configuration for the controller. This is optional if the controller does
   * not require extra parameters.
   * +optional
   *
   * @generated from field: optional k8s.io.api.networking.v1.IngressClassParametersReference parameters = 2;
   */
  parameters?: IngressClassParametersReference;
};

export declare type IngressClassSpecValid = IngressClassSpec;

/**
 * Describes the message k8s.io.api.networking.v1.IngressClassSpec.
 * Use `create(IngressClassSpecSchema)` to create a new message.
 */
export declare const IngressClassSpecSchema: GenMessage<IngressClassSpec, {validType: IngressClassSpecValid}>;

/**
 * IngressList is a collection of Ingress.
 *
 * @generated from message k8s.io.api.networking.v1.IngressList
 */
export declare type IngressList = Message<"k8s.io.api.networking.v1.IngressList"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMeta;

  /**
   * Items is the list of Ingress.
   *
   * @generated from field: repeated k8s.io.api.networking.v1.Ingress items = 2;
   */
  items: Ingress[];
};

export declare type IngressListValid = IngressList;

/**
 * Describes the message k8s.io.api.networking.v1.IngressList.
 * Use `create(IngressListSchema)` to create a new message.
 */
export declare const IngressListSchema: GenMessage<IngressList, {validType: IngressListValid}>;

/**
 * IngressRule represents the rules mapping the paths under a specified host to
 * the related backend services. Incoming requests are first evaluated for a host
 * match, then routed to the backend associated with the matching IngressRuleValue.
 *
 * @generated from message k8s.io.api.networking.v1.IngressRule
 */
export declare type IngressRule = Message<"k8s.io.api.networking.v1.IngressRule"> & {
  /**
   * Host is the fully qualified domain name of a network host, as defined by RFC 3986.
   * Note the following deviations from the "host" part of the
   * URI as defined in RFC 3986:
   * 1. IPs are not allowed. Currently an IngressRuleValue can only apply to
   *    the IP in the Spec of the parent Ingress.
   * 2. The `:` delimiter is not respected because ports are not allowed.
   * 	  Currently the port of an Ingress is implicitly :80 for http and
   * 	  :443 for https.
   * Both these may change in the future.
   * Incoming requests are matched against the host before the
   * IngressRuleValue. If the host is unspecified, the Ingress routes all
   * traffic based on the specified IngressRuleValue.
   *
   * Host can be "precise" which is a domain name without the terminating dot of
   * a network host (e.g. "foo.bar.com") or "wildcard", which is a domain name
   * prefixed with a single wildcard label (e.g. "*.foo.com").
   * The wildcard character '*' must appear by itself as the first DNS label and
   * matches only a single label. You cannot have a wildcard label by itself (e.g. Host == "*").
   * Requests will be matched against the Host field in the following way:
   * 1. If Host is precise, the request matches this rule if the http host header is equal to Host.
   * 2. If Host is a wildcard, then the request matches this rule if the http host header
   * is to equal to the suffix (removing the first label) of the wildcard rule.
   * +optional
   *
   * @generated from field: optional string host = 1;
   */
  host: string;

  /**
   * IngressRuleValue represents a rule to route requests for this IngressRule.
   * If unspecified, the rule defaults to a http catch-all. Whether that sends
   * just traffic matching the host to the default backend or all traffic to the
   * default backend, is left to the controller fulfilling the Ingress. Http is
   * currently the only supported IngressRuleValue.
   * +optional
   *
   * @generated from field: optional k8s.io.api.networking.v1.IngressRuleValue ingressRuleValue = 2;
   */
  ingressRuleValue?: IngressRuleValue;
};

export declare type IngressRuleValid = IngressRule;

/**
 * Describes the message k8s.io.api.networking.v1.IngressRule.
 * Use `create(IngressRuleSchema)` to create a new message.
 */
export declare const IngressRuleSchema: GenMessage<IngressRule, {validType: IngressRuleValid}>;

/**
 * IngressRuleValue represents a rule to apply against incoming requests. If the
 * rule is satisfied, the request is routed to the specified backend. Currently
 * mixing different types of rules in a single Ingress is disallowed, so exactly
 * one of the following must be set.
 *
 * @generated from message k8s.io.api.networking.v1.IngressRuleValue
 */
export declare type IngressRuleValue = Message<"k8s.io.api.networking.v1.IngressRuleValue"> & {
  /**
   * +optional
   *
   * @generated from field: optional k8s.io.api.networking.v1.HTTPIngressRuleValue http = 1;
   */
  http?: HTTPIngressRuleValue;
};

export declare type IngressRuleValueValid = IngressRuleValue;

/**
 * Describes the message k8s.io.api.networking.v1.IngressRuleValue.
 * Use `create(IngressRuleValueSchema)` to create a new message.
 */
export declare const IngressRuleValueSchema: GenMessage<IngressRuleValue, {validType: IngressRuleValueValid}>;

/**
 * IngressServiceBackend references a Kubernetes Service as a Backend.
 *
 * @generated from message k8s.io.api.networking.v1.IngressServiceBackend
 */
export declare type IngressServiceBackend = Message<"k8s.io.api.networking.v1.IngressServiceBackend"> & {
  /**
   * Name is the referenced service. The service must exist in
   * the same namespace as the Ingress object.
   *
   * @generated from field: optional string name = 1;
   */
  name: string;

  /**
   * Port of the referenced service. A port name or port number
   * is required for a IngressServiceBackend.
   *
   * @generated from field: optional k8s.io.api.networking.v1.ServiceBackendPort port = 2;
   */
  port?: ServiceBackendPort;
};

export declare type IngressServiceBackendValid = IngressServiceBackend;

/**
 * Describes the message k8s.io.api.networking.v1.IngressServiceBackend.
 * Use `create(IngressServiceBackendSchema)` to create a new message.
 */
export declare const IngressServiceBackendSchema: GenMessage<IngressServiceBackend, {validType: IngressServiceBackendValid}>;

/**
 * IngressSpec describes the Ingress the user wishes to exist.
 *
 * @generated from message k8s.io.api.networking.v1.IngressSpec
 */
export declare type IngressSpec = Message<"k8s.io.api.networking.v1.IngressSpec"> & {
  /**
   * IngressClassName is the name of the IngressClass cluster resource. The
   * associated IngressClass defines which controller will implement the
   * resource. This replaces the deprecated `kubernetes.io/ingress.class`
   * annotation. For backwards compatibility, when that annotation is set, it
   * must be given precedence over this field. The controller may emit a
   * warning if the field and annotation have different values.
   * Implementations of this API should ignore Ingresses without a class
   * specified. An IngressClass resource may be marked as default, which can
   * be used to set a default value for this field. For more information,
   * refer to the IngressClass documentation.
   * +optional
   *
   * @generated from field: optional string ingressClassName = 4;
   */
  ingressClassName: string;

  /**
   * DefaultBackend is the backend that should handle requests that don't
   * match any rule. If Rules are not specified, DefaultBackend must be specified.
   * If DefaultBackend is not set, the handling of requests that do not match any
   * of the rules will be up to the Ingress controller.
   * +optional
   *
   * @generated from field: optional k8s.io.api.networking.v1.IngressBackend defaultBackend = 1;
   */
  defaultBackend?: IngressBackend;

  /**
   * TLS configuration. Currently the Ingress only supports a single TLS
   * port, 443. If multiple members of this list specify different hosts, they
   * will be multiplexed on the same port according to the hostname specified
   * through the SNI TLS extension, if the ingress controller fulfilling the
   * ingress supports SNI.
   * +listType=atomic
   * +optional
   *
   * @generated from field: repeated k8s.io.api.networking.v1.IngressTLS tls = 2;
   */
  tls: IngressTLS[];

  /**
   * A list of host rules used to configure the Ingress. If unspecified, or
   * no rule matches, all traffic is sent to the default backend.
   * +listType=atomic
   * +optional
   *
   * @generated from field: repeated k8s.io.api.networking.v1.IngressRule rules = 3;
   */
  rules: IngressRule[];
};

export declare type IngressSpecValid = IngressSpec;

/**
 * Describes the message k8s.io.api.networking.v1.IngressSpec.
 * Use `create(IngressSpecSchema)` to create a new message.
 */
export declare const IngressSpecSchema: GenMessage<IngressSpec, {validType: IngressSpecValid}>;

/**
 * IngressStatus describe the current state of the Ingress.
 *
 * @generated from message k8s.io.api.networking.v1.IngressStatus
 */
export declare type IngressStatus = Message<"k8s.io.api.networking.v1.IngressStatus"> & {
  /**
   * LoadBalancer contains the current status of the load-balancer.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.LoadBalancerStatus loadBalancer = 1;
   */
  loadBalancer?: LoadBalancerStatus;
};

export declare type IngressStatusValid = IngressStatus;

/**
 * Describes the message k8s.io.api.networking.v1.IngressStatus.
 * Use `create(IngressStatusSchema)` to create a new message.
 */
export declare const IngressStatusSchema: GenMessage<IngressStatus, {validType: IngressStatusValid}>;

/**
 * IngressTLS describes the transport layer security associated with an Ingress.
 *
 * @generated from message k8s.io.api.networking.v1.IngressTLS
 */
export declare type IngressTLS = Message<"k8s.io.api.networking.v1.IngressTLS"> & {
  /**
   * Hosts are a list of hosts included in the TLS certificate. The values in
   * this list must match the name/s used in the tlsSecret. Defaults to the
   * wildcard host setting for the loadbalancer controller fulfilling this
   * Ingress, if left unspecified.
   * +listType=atomic
   * +optional
   *
   * @generated from field: repeated string hosts = 1;
   */
  hosts: string[];

  /**
   * SecretName is the name of the secret used to terminate TLS traffic on
   * port 443. Field is left optional to allow TLS routing based on SNI
   * hostname alone. If the SNI host in a listener conflicts with the "Host"
   * header field used by an IngressRule, the SNI host is used for termination
   * and value of the Host header is used for routing.
   * +optional
   *
   * @generated from field: optional string secretName = 2;
   */
  secretName: string;
};

export declare type IngressTLSValid = IngressTLS;

/**
 * Describes the message k8s.io.api.networking.v1.IngressTLS.
 * Use `create(IngressTLSSchema)` to create a new message.
 */
export declare const IngressTLSSchema: GenMessage<IngressTLS, {validType: IngressTLSValid}>;

/**
 * NetworkPolicy describes what network traffic is allowed for a set of Pods
 *
 * @generated from message k8s.io.api.networking.v1.NetworkPolicy
 */
export declare type NetworkPolicy = Message<"k8s.io.api.networking.v1.NetworkPolicy"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMeta;

  /**
   * Specification of the desired behavior for this NetworkPolicy.
   * +optional
   *
   * @generated from field: optional k8s.io.api.networking.v1.NetworkPolicySpec spec = 2;
   */
  spec?: NetworkPolicySpec;
};

export declare type NetworkPolicyValid = NetworkPolicy;

/**
 * Describes the message k8s.io.api.networking.v1.NetworkPolicy.
 * Use `create(NetworkPolicySchema)` to create a new message.
 */
export declare const NetworkPolicySchema: GenMessage<NetworkPolicy, {validType: NetworkPolicyValid}>;

/**
 * NetworkPolicyEgressRule describes a particular set of traffic that is allowed out of pods
 * matched by a NetworkPolicySpec's podSelector. The traffic must match both ports and to.
 * This type is beta-level in 1.8
 *
 * @generated from message k8s.io.api.networking.v1.NetworkPolicyEgressRule
 */
export declare type NetworkPolicyEgressRule = Message<"k8s.io.api.networking.v1.NetworkPolicyEgressRule"> & {
  /**
   * List of destination ports for outgoing traffic.
   * Each item in this list is combined using a logical OR. If this field is
   * empty or missing, this rule matches all ports (traffic not restricted by port).
   * If this field is present and contains at least one item, then this rule allows
   * traffic only if the traffic matches at least one port in the list.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.networking.v1.NetworkPolicyPort ports = 1;
   */
  ports: NetworkPolicyPort[];

  /**
   * List of destinations for outgoing traffic of pods selected for this rule.
   * Items in this list are combined using a logical OR operation. If this field is
   * empty or missing, this rule matches all destinations (traffic not restricted by
   * destination). If this field is present and contains at least one item, this rule
   * allows traffic only if the traffic matches at least one item in the to list.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.networking.v1.NetworkPolicyPeer to = 2;
   */
  to: NetworkPolicyPeer[];
};

export declare type NetworkPolicyEgressRuleValid = NetworkPolicyEgressRule;

/**
 * Describes the message k8s.io.api.networking.v1.NetworkPolicyEgressRule.
 * Use `create(NetworkPolicyEgressRuleSchema)` to create a new message.
 */
export declare const NetworkPolicyEgressRuleSchema: GenMessage<NetworkPolicyEgressRule, {validType: NetworkPolicyEgressRuleValid}>;

/**
 * NetworkPolicyIngressRule describes a particular set of traffic that is allowed to the pods
 * matched by a NetworkPolicySpec's podSelector. The traffic must match both ports and from.
 *
 * @generated from message k8s.io.api.networking.v1.NetworkPolicyIngressRule
 */
export declare type NetworkPolicyIngressRule = Message<"k8s.io.api.networking.v1.NetworkPolicyIngressRule"> & {
  /**
   * List of ports which should be made accessible on the pods selected for this
   * rule. Each item in this list is combined using a logical OR. If this field is
   * empty or missing, this rule matches all ports (traffic not restricted by port).
   * If this field is present and contains at least one item, then this rule allows
   * traffic only if the traffic matches at least one port in the list.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.networking.v1.NetworkPolicyPort ports = 1;
   */
  ports: NetworkPolicyPort[];

  /**
   * List of sources which should be able to access the pods selected for this rule.
   * Items in this list are combined using a logical OR operation. If this field is
   * empty or missing, this rule matches all sources (traffic not restricted by
   * source). If this field is present and contains at least one item, this rule
   * allows traffic only if the traffic matches at least one item in the from list.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.networking.v1.NetworkPolicyPeer from = 2;
   */
  from: NetworkPolicyPeer[];
};

export declare type NetworkPolicyIngressRuleValid = NetworkPolicyIngressRule;

/**
 * Describes the message k8s.io.api.networking.v1.NetworkPolicyIngressRule.
 * Use `create(NetworkPolicyIngressRuleSchema)` to create a new message.
 */
export declare const NetworkPolicyIngressRuleSchema: GenMessage<NetworkPolicyIngressRule, {validType: NetworkPolicyIngressRuleValid}>;

/**
 * NetworkPolicyList is a list of NetworkPolicy objects.
 *
 * @generated from message k8s.io.api.networking.v1.NetworkPolicyList
 */
export declare type NetworkPolicyList = Message<"k8s.io.api.networking.v1.NetworkPolicyList"> & {
  /**
   * Standard list metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMeta;

  /**
   * Items is a list of schema objects.
   *
   * @generated from field: repeated k8s.io.api.networking.v1.NetworkPolicy items = 2;
   */
  items: NetworkPolicy[];
};

export declare type NetworkPolicyListValid = NetworkPolicyList;

/**
 * Describes the message k8s.io.api.networking.v1.NetworkPolicyList.
 * Use `create(NetworkPolicyListSchema)` to create a new message.
 */
export declare const NetworkPolicyListSchema: GenMessage<NetworkPolicyList, {validType: NetworkPolicyListValid}>;

/**
 * NetworkPolicyPeer describes a peer to allow traffic to/from. Only certain combinations of
 * fields are allowed
 *
 * @generated from message k8s.io.api.networking.v1.NetworkPolicyPeer
 */
export declare type NetworkPolicyPeer = Message<"k8s.io.api.networking.v1.NetworkPolicyPeer"> & {
  /**
   * This is a label selector which selects Pods. This field follows standard label
   * selector semantics; if present but empty, it selects all pods.
   *
   * If NamespaceSelector is also set, then the NetworkPolicyPeer as a whole selects
   * the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
   * Otherwise it selects the Pods matching PodSelector in the policy's own Namespace.
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector podSelector = 1;
   */
  podSelector?: LabelSelector;

  /**
   * Selects Namespaces using cluster-scoped labels. This field follows standard label
   * selector semantics; if present but empty, it selects all namespaces.
   *
   * If PodSelector is also set, then the NetworkPolicyPeer as a whole selects
   * the Pods matching PodSelector in the Namespaces selected by NamespaceSelector.
   * Otherwise it selects all Pods in the Namespaces selected by NamespaceSelector.
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 2;
   */
  namespaceSelector?: LabelSelector;

  /**
   * IPBlock defines policy on a particular IPBlock. If this field is set then
   * neither of the other fields can be.
   * +optional
   *
   * @generated from field: optional k8s.io.api.networking.v1.IPBlock ipBlock = 3;
   */
  ipBlock?: IPBlock;
};

export declare type NetworkPolicyPeerValid = NetworkPolicyPeer;

/**
 * Describes the message k8s.io.api.networking.v1.NetworkPolicyPeer.
 * Use `create(NetworkPolicyPeerSchema)` to create a new message.
 */
export declare const NetworkPolicyPeerSchema: GenMessage<NetworkPolicyPeer, {validType: NetworkPolicyPeerValid}>;

/**
 * NetworkPolicyPort describes a port to allow traffic on
 *
 * @generated from message k8s.io.api.networking.v1.NetworkPolicyPort
 */
export declare type NetworkPolicyPort = Message<"k8s.io.api.networking.v1.NetworkPolicyPort"> & {
  /**
   * The protocol (TCP, UDP, or SCTP) which traffic must match. If not specified, this
   * field defaults to TCP.
   * +optional
   *
   * @generated from field: optional string protocol = 1;
   */
  protocol: string;

  /**
   * The port on the given protocol. This can either be a numerical or named
   * port on a pod. If this field is not provided, this matches all port names and
   * numbers.
   * If present, only traffic on the specified protocol AND port will be matched.
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 2;
   */
  port?: IntOrString;

  /**
   * If set, indicates that the range of ports from port to endPort, inclusive,
   * should be allowed by the policy. This field cannot be defined if the port field
   * is not defined or if the port field is defined as a named (string) port.
   * The endPort must be equal or greater than port.
   * This feature is in Beta state and is enabled by default.
   * It can be disabled using the Feature Gate "NetworkPolicyEndPort".
   * +optional
   *
   * @generated from field: optional int32 endPort = 3;
   */
  endPort: number;
};

export declare type NetworkPolicyPortValid = NetworkPolicyPort;

/**
 * Describes the message k8s.io.api.networking.v1.NetworkPolicyPort.
 * Use `create(NetworkPolicyPortSchema)` to create a new message.
 */
export declare const NetworkPolicyPortSchema: GenMessage<NetworkPolicyPort, {validType: NetworkPolicyPortValid}>;

/**
 * NetworkPolicySpec provides the specification of a NetworkPolicy
 *
 * @generated from message k8s.io.api.networking.v1.NetworkPolicySpec
 */
export declare type NetworkPolicySpec = Message<"k8s.io.api.networking.v1.NetworkPolicySpec"> & {
  /**
   * Selects the pods to which this NetworkPolicy object applies. The array of
   * ingress rules is applied to any pods selected by this field. Multiple network
   * policies can select the same set of pods. In this case, the ingress rules for
   * each are combined additively. This field is NOT optional and follows standard
   * label selector semantics. An empty podSelector matches all pods in this
   * namespace.
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector podSelector = 1;
   */
  podSelector?: LabelSelector;

  /**
   * List of ingress rules to be applied to the selected pods. Traffic is allowed to
   * a pod if there are no NetworkPolicies selecting the pod
   * (and cluster policy otherwise allows the traffic), OR if the traffic source is
   * the pod's local node, OR if the traffic matches at least one ingress rule
   * across all of the NetworkPolicy objects whose podSelector matches the pod. If
   * this field is empty then this NetworkPolicy does not allow any traffic (and serves
   * solely to ensure that the pods it selects are isolated by default)
   * +optional
   *
   * @generated from field: repeated k8s.io.api.networking.v1.NetworkPolicyIngressRule ingress = 2;
   */
  ingress: NetworkPolicyIngressRule[];

  /**
   * List of egress rules to be applied to the selected pods. Outgoing traffic is
   * allowed if there are no NetworkPolicies selecting the pod (and cluster policy
   * otherwise allows the traffic), OR if the traffic matches at least one egress rule
   * across all of the NetworkPolicy objects whose podSelector matches the pod. If
   * this field is empty then this NetworkPolicy limits all outgoing traffic (and serves
   * solely to ensure that the pods it selects are isolated by default).
   * This field is beta-level in 1.8
   * +optional
   *
   * @generated from field: repeated k8s.io.api.networking.v1.NetworkPolicyEgressRule egress = 3;
   */
  egress: NetworkPolicyEgressRule[];

  /**
   * List of rule types that the NetworkPolicy relates to.
   * Valid options are ["Ingress"], ["Egress"], or ["Ingress", "Egress"].
   * If this field is not specified, it will default based on the existence of Ingress or Egress rules;
   * policies that contain an Egress section are assumed to affect Egress, and all policies
   * (whether or not they contain an Ingress section) are assumed to affect Ingress.
   * If you want to write an egress-only policy, you must explicitly specify policyTypes [ "Egress" ].
   * Likewise, if you want to write a policy that specifies that no egress is allowed,
   * you must specify a policyTypes value that include "Egress" (since such a policy would not include
   * an Egress section and would otherwise default to just [ "Ingress" ]).
   * This field is beta-level in 1.8
   * +optional
   *
   * @generated from field: repeated string policyTypes = 4;
   */
  policyTypes: string[];
};

export declare type NetworkPolicySpecValid = NetworkPolicySpec;

/**
 * Describes the message k8s.io.api.networking.v1.NetworkPolicySpec.
 * Use `create(NetworkPolicySpecSchema)` to create a new message.
 */
export declare const NetworkPolicySpecSchema: GenMessage<NetworkPolicySpec, {validType: NetworkPolicySpecValid}>;

/**
 * ServiceBackendPort is the service port being referenced.
 *
 * @generated from message k8s.io.api.networking.v1.ServiceBackendPort
 */
export declare type ServiceBackendPort = Message<"k8s.io.api.networking.v1.ServiceBackendPort"> & {
  /**
   * Name is the name of the port on the Service.
   * This is a mutually exclusive setting with "Number".
   * +optional
   *
   * @generated from field: optional string name = 1;
   */
  name: string;

  /**
   * Number is the numerical port number (e.g. 80) on the Service.
   * This is a mutually exclusive setting with "Name".
   * +optional
   *
   * @generated from field: optional int32 number = 2;
   */
  number: number;
};

export declare type ServiceBackendPortValid = ServiceBackendPort;

/**
 * Describes the message k8s.io.api.networking.v1.ServiceBackendPort.
 * Use `create(ServiceBackendPortSchema)` to create a new message.
 */
export declare const ServiceBackendPortSchema: GenMessage<ServiceBackendPort, {validType: ServiceBackendPortValid}>;

