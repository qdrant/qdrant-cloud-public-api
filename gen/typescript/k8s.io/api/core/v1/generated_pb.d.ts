//
//Copyright The Kubernetes Authors.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.

// This file was autogenerated by go-to-protobuf. Do not edit it manually!

// @generated by protoc-gen-es v2.10.0 with parameter "target=js+dts,import_extension=js,valid_types=protovalidate_required,buf_validate=true"
// @generated from file k8s.io/api/core/v1/generated.proto (package k8s.io.api.core.v1, syntax proto2)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";
import type { Condition, ConditionValid, LabelSelector, LabelSelectorValid, ListMeta, ListMetaValid, MicroTime, MicroTimeValid, ObjectMeta, ObjectMetaValid, OwnerReference, OwnerReferenceValid, Time, TimeValid } from "../../../apimachinery/pkg/apis/meta/v1/generated_pb.js";
import type { Quantity, QuantityValid } from "../../../apimachinery/pkg/api/resource/generated_pb.js";
import type { IntOrString, IntOrStringValid } from "../../../apimachinery/pkg/util/intstr/generated_pb.js";
import type { RawExtension, RawExtensionValid } from "../../../apimachinery/pkg/runtime/generated_pb.js";

/**
 * Describes the file k8s.io/api/core/v1/generated.proto.
 */
export declare const file_k8s_io_api_core_v1_generated: GenFile;

/**
 * Represents a Persistent Disk resource in AWS.
 *
 * An AWS EBS disk must exist before mounting to a container. The disk
 * must also be in the same AWS zone as the kubelet. An AWS EBS disk
 * can only be mounted as read/write once. AWS EBS volumes support
 * ownership management and SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.AWSElasticBlockStoreVolumeSource
 */
export declare type AWSElasticBlockStoreVolumeSource = Message<"k8s.io.api.core.v1.AWSElasticBlockStoreVolumeSource"> & {
  /**
   * volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume).
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @generated from field: optional string volumeID = 1;
   */
  volumeID: string;

  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   * +optional
   *
   * @generated from field: optional string fsType = 2;
   */
  fsType: string;

  /**
   * partition is the partition in the volume that you want to mount.
   * If omitted, the default is to mount by volume name.
   * Examples: For volume /dev/sda1, you specify the partition as "1".
   * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   * +optional
   *
   * @generated from field: optional int32 partition = 3;
   */
  partition: number;

  /**
   * readOnly value true will force the readOnly setting in VolumeMounts.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   * +optional
   *
   * @generated from field: optional bool readOnly = 4;
   */
  readOnly: boolean;
};

/**
 * Represents a Persistent Disk resource in AWS.
 *
 * An AWS EBS disk must exist before mounting to a container. The disk
 * must also be in the same AWS zone as the kubelet. An AWS EBS disk
 * can only be mounted as read/write once. AWS EBS volumes support
 * ownership management and SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.AWSElasticBlockStoreVolumeSource
 */
export declare type AWSElasticBlockStoreVolumeSourceValid = Message<"k8s.io.api.core.v1.AWSElasticBlockStoreVolumeSource"> & {
  /**
   * volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume).
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @generated from field: optional string volumeID = 1;
   */
  volumeID: string;

  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   * +optional
   *
   * @generated from field: optional string fsType = 2;
   */
  fsType: string;

  /**
   * partition is the partition in the volume that you want to mount.
   * If omitted, the default is to mount by volume name.
   * Examples: For volume /dev/sda1, you specify the partition as "1".
   * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   * +optional
   *
   * @generated from field: optional int32 partition = 3;
   */
  partition: number;

  /**
   * readOnly value true will force the readOnly setting in VolumeMounts.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   * +optional
   *
   * @generated from field: optional bool readOnly = 4;
   */
  readOnly: boolean;
};

/**
 * Describes the message k8s.io.api.core.v1.AWSElasticBlockStoreVolumeSource.
 * Use `create(AWSElasticBlockStoreVolumeSourceSchema)` to create a new message.
 */
export declare const AWSElasticBlockStoreVolumeSourceSchema: GenMessage<AWSElasticBlockStoreVolumeSource, {validType: AWSElasticBlockStoreVolumeSourceValid}>;

/**
 * Affinity is a group of affinity scheduling rules.
 *
 * @generated from message k8s.io.api.core.v1.Affinity
 */
export declare type Affinity = Message<"k8s.io.api.core.v1.Affinity"> & {
  /**
   * Describes node affinity scheduling rules for the pod.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.NodeAffinity nodeAffinity = 1;
   */
  nodeAffinity?: NodeAffinity;

  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.PodAffinity podAffinity = 2;
   */
  podAffinity?: PodAffinity;

  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.PodAntiAffinity podAntiAffinity = 3;
   */
  podAntiAffinity?: PodAntiAffinity;
};

/**
 * Affinity is a group of affinity scheduling rules.
 *
 * @generated from message k8s.io.api.core.v1.Affinity
 */
export declare type AffinityValid = Message<"k8s.io.api.core.v1.Affinity"> & {
  /**
   * Describes node affinity scheduling rules for the pod.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.NodeAffinity nodeAffinity = 1;
   */
  nodeAffinity?: NodeAffinityValid;

  /**
   * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.PodAffinity podAffinity = 2;
   */
  podAffinity?: PodAffinityValid;

  /**
   * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.PodAntiAffinity podAntiAffinity = 3;
   */
  podAntiAffinity?: PodAntiAffinityValid;
};

/**
 * Describes the message k8s.io.api.core.v1.Affinity.
 * Use `create(AffinitySchema)` to create a new message.
 */
export declare const AffinitySchema: GenMessage<Affinity, {validType: AffinityValid}>;

/**
 * AttachedVolume describes a volume attached to a node
 *
 * @generated from message k8s.io.api.core.v1.AttachedVolume
 */
export declare type AttachedVolume = Message<"k8s.io.api.core.v1.AttachedVolume"> & {
  /**
   * Name of the attached volume
   *
   * @generated from field: optional string name = 1;
   */
  name: string;

  /**
   * DevicePath represents the device path where the volume should be available
   *
   * @generated from field: optional string devicePath = 2;
   */
  devicePath: string;
};

/**
 * AttachedVolume describes a volume attached to a node
 *
 * @generated from message k8s.io.api.core.v1.AttachedVolume
 */
export declare type AttachedVolumeValid = Message<"k8s.io.api.core.v1.AttachedVolume"> & {
  /**
   * Name of the attached volume
   *
   * @generated from field: optional string name = 1;
   */
  name: string;

  /**
   * DevicePath represents the device path where the volume should be available
   *
   * @generated from field: optional string devicePath = 2;
   */
  devicePath: string;
};

/**
 * Describes the message k8s.io.api.core.v1.AttachedVolume.
 * Use `create(AttachedVolumeSchema)` to create a new message.
 */
export declare const AttachedVolumeSchema: GenMessage<AttachedVolume, {validType: AttachedVolumeValid}>;

/**
 * AvoidPods describes pods that should avoid this node. This is the value for a
 * Node annotation with key scheduler.alpha.kubernetes.io/preferAvoidPods and
 * will eventually become a field of NodeStatus.
 *
 * @generated from message k8s.io.api.core.v1.AvoidPods
 */
export declare type AvoidPods = Message<"k8s.io.api.core.v1.AvoidPods"> & {
  /**
   * Bounded-sized list of signatures of pods that should avoid this node, sorted
   * in timestamp order from oldest to newest. Size of the slice is unspecified.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.PreferAvoidPodsEntry preferAvoidPods = 1;
   */
  preferAvoidPods: PreferAvoidPodsEntry[];
};

/**
 * AvoidPods describes pods that should avoid this node. This is the value for a
 * Node annotation with key scheduler.alpha.kubernetes.io/preferAvoidPods and
 * will eventually become a field of NodeStatus.
 *
 * @generated from message k8s.io.api.core.v1.AvoidPods
 */
export declare type AvoidPodsValid = Message<"k8s.io.api.core.v1.AvoidPods"> & {
  /**
   * Bounded-sized list of signatures of pods that should avoid this node, sorted
   * in timestamp order from oldest to newest. Size of the slice is unspecified.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.PreferAvoidPodsEntry preferAvoidPods = 1;
   */
  preferAvoidPods: PreferAvoidPodsEntryValid[];
};

/**
 * Describes the message k8s.io.api.core.v1.AvoidPods.
 * Use `create(AvoidPodsSchema)` to create a new message.
 */
export declare const AvoidPodsSchema: GenMessage<AvoidPods, {validType: AvoidPodsValid}>;

/**
 * AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 *
 * @generated from message k8s.io.api.core.v1.AzureDiskVolumeSource
 */
export declare type AzureDiskVolumeSource = Message<"k8s.io.api.core.v1.AzureDiskVolumeSource"> & {
  /**
   * diskName is the Name of the data disk in the blob storage
   *
   * @generated from field: optional string diskName = 1;
   */
  diskName: string;

  /**
   * diskURI is the URI of data disk in the blob storage
   *
   * @generated from field: optional string diskURI = 2;
   */
  diskURI: string;

  /**
   * cachingMode is the Host Caching mode: None, Read Only, Read Write.
   * +optional
   *
   * @generated from field: optional string cachingMode = 3;
   */
  cachingMode: string;

  /**
   * fsType is Filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * +optional
   *
   * @generated from field: optional string fsType = 4;
   */
  fsType: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * +optional
   *
   * @generated from field: optional bool readOnly = 5;
   */
  readOnly: boolean;

  /**
   * kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
   *
   * @generated from field: optional string kind = 6;
   */
  kind: string;
};

/**
 * AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 *
 * @generated from message k8s.io.api.core.v1.AzureDiskVolumeSource
 */
export declare type AzureDiskVolumeSourceValid = Message<"k8s.io.api.core.v1.AzureDiskVolumeSource"> & {
  /**
   * diskName is the Name of the data disk in the blob storage
   *
   * @generated from field: optional string diskName = 1;
   */
  diskName: string;

  /**
   * diskURI is the URI of data disk in the blob storage
   *
   * @generated from field: optional string diskURI = 2;
   */
  diskURI: string;

  /**
   * cachingMode is the Host Caching mode: None, Read Only, Read Write.
   * +optional
   *
   * @generated from field: optional string cachingMode = 3;
   */
  cachingMode: string;

  /**
   * fsType is Filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * +optional
   *
   * @generated from field: optional string fsType = 4;
   */
  fsType: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * +optional
   *
   * @generated from field: optional bool readOnly = 5;
   */
  readOnly: boolean;

  /**
   * kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
   *
   * @generated from field: optional string kind = 6;
   */
  kind: string;
};

/**
 * Describes the message k8s.io.api.core.v1.AzureDiskVolumeSource.
 * Use `create(AzureDiskVolumeSourceSchema)` to create a new message.
 */
export declare const AzureDiskVolumeSourceSchema: GenMessage<AzureDiskVolumeSource, {validType: AzureDiskVolumeSourceValid}>;

/**
 * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
 *
 * @generated from message k8s.io.api.core.v1.AzureFilePersistentVolumeSource
 */
export declare type AzureFilePersistentVolumeSource = Message<"k8s.io.api.core.v1.AzureFilePersistentVolumeSource"> & {
  /**
   * secretName is the name of secret that contains Azure Storage Account Name and Key
   *
   * @generated from field: optional string secretName = 1;
   */
  secretName: string;

  /**
   * shareName is the azure Share Name
   *
   * @generated from field: optional string shareName = 2;
   */
  shareName: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * +optional
   *
   * @generated from field: optional bool readOnly = 3;
   */
  readOnly: boolean;

  /**
   * secretNamespace is the namespace of the secret that contains Azure Storage Account Name and Key
   * default is the same as the Pod
   * +optional
   *
   * @generated from field: optional string secretNamespace = 4;
   */
  secretNamespace: string;
};

/**
 * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
 *
 * @generated from message k8s.io.api.core.v1.AzureFilePersistentVolumeSource
 */
export declare type AzureFilePersistentVolumeSourceValid = Message<"k8s.io.api.core.v1.AzureFilePersistentVolumeSource"> & {
  /**
   * secretName is the name of secret that contains Azure Storage Account Name and Key
   *
   * @generated from field: optional string secretName = 1;
   */
  secretName: string;

  /**
   * shareName is the azure Share Name
   *
   * @generated from field: optional string shareName = 2;
   */
  shareName: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * +optional
   *
   * @generated from field: optional bool readOnly = 3;
   */
  readOnly: boolean;

  /**
   * secretNamespace is the namespace of the secret that contains Azure Storage Account Name and Key
   * default is the same as the Pod
   * +optional
   *
   * @generated from field: optional string secretNamespace = 4;
   */
  secretNamespace: string;
};

/**
 * Describes the message k8s.io.api.core.v1.AzureFilePersistentVolumeSource.
 * Use `create(AzureFilePersistentVolumeSourceSchema)` to create a new message.
 */
export declare const AzureFilePersistentVolumeSourceSchema: GenMessage<AzureFilePersistentVolumeSource, {validType: AzureFilePersistentVolumeSourceValid}>;

/**
 * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
 *
 * @generated from message k8s.io.api.core.v1.AzureFileVolumeSource
 */
export declare type AzureFileVolumeSource = Message<"k8s.io.api.core.v1.AzureFileVolumeSource"> & {
  /**
   * secretName is the  name of secret that contains Azure Storage Account Name and Key
   *
   * @generated from field: optional string secretName = 1;
   */
  secretName: string;

  /**
   * shareName is the azure share Name
   *
   * @generated from field: optional string shareName = 2;
   */
  shareName: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * +optional
   *
   * @generated from field: optional bool readOnly = 3;
   */
  readOnly: boolean;
};

/**
 * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
 *
 * @generated from message k8s.io.api.core.v1.AzureFileVolumeSource
 */
export declare type AzureFileVolumeSourceValid = Message<"k8s.io.api.core.v1.AzureFileVolumeSource"> & {
  /**
   * secretName is the  name of secret that contains Azure Storage Account Name and Key
   *
   * @generated from field: optional string secretName = 1;
   */
  secretName: string;

  /**
   * shareName is the azure share Name
   *
   * @generated from field: optional string shareName = 2;
   */
  shareName: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * +optional
   *
   * @generated from field: optional bool readOnly = 3;
   */
  readOnly: boolean;
};

/**
 * Describes the message k8s.io.api.core.v1.AzureFileVolumeSource.
 * Use `create(AzureFileVolumeSourceSchema)` to create a new message.
 */
export declare const AzureFileVolumeSourceSchema: GenMessage<AzureFileVolumeSource, {validType: AzureFileVolumeSourceValid}>;

/**
 * Binding ties one object to another; for example, a pod is bound to a node by a scheduler.
 * Deprecated in 1.7, please use the bindings subresource of pods instead.
 *
 * @generated from message k8s.io.api.core.v1.Binding
 */
export declare type Binding = Message<"k8s.io.api.core.v1.Binding"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMeta;

  /**
   * The target object that you want to bind to the standard object.
   *
   * @generated from field: optional k8s.io.api.core.v1.ObjectReference target = 2;
   */
  target?: ObjectReference;
};

/**
 * Binding ties one object to another; for example, a pod is bound to a node by a scheduler.
 * Deprecated in 1.7, please use the bindings subresource of pods instead.
 *
 * @generated from message k8s.io.api.core.v1.Binding
 */
export declare type BindingValid = Message<"k8s.io.api.core.v1.Binding"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMetaValid;

  /**
   * The target object that you want to bind to the standard object.
   *
   * @generated from field: optional k8s.io.api.core.v1.ObjectReference target = 2;
   */
  target?: ObjectReferenceValid;
};

/**
 * Describes the message k8s.io.api.core.v1.Binding.
 * Use `create(BindingSchema)` to create a new message.
 */
export declare const BindingSchema: GenMessage<Binding, {validType: BindingValid}>;

/**
 * Represents storage that is managed by an external CSI volume driver (Beta feature)
 *
 * @generated from message k8s.io.api.core.v1.CSIPersistentVolumeSource
 */
export declare type CSIPersistentVolumeSource = Message<"k8s.io.api.core.v1.CSIPersistentVolumeSource"> & {
  /**
   * driver is the name of the driver to use for this volume.
   * Required.
   *
   * @generated from field: optional string driver = 1;
   */
  driver: string;

  /**
   * volumeHandle is the unique volume name returned by the CSI volume
   * plugin’s CreateVolume to refer to the volume on all subsequent calls.
   * Required.
   *
   * @generated from field: optional string volumeHandle = 2;
   */
  volumeHandle: string;

  /**
   * readOnly value to pass to ControllerPublishVolumeRequest.
   * Defaults to false (read/write).
   * +optional
   *
   * @generated from field: optional bool readOnly = 3;
   */
  readOnly: boolean;

  /**
   * fsType to mount. Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs".
   * +optional
   *
   * @generated from field: optional string fsType = 4;
   */
  fsType: string;

  /**
   * volumeAttributes of the volume to publish.
   * +optional
   *
   * @generated from field: map<string, string> volumeAttributes = 5;
   */
  volumeAttributes: { [key: string]: string };

  /**
   * controllerPublishSecretRef is a reference to the secret object containing
   * sensitive information to pass to the CSI driver to complete the CSI
   * ControllerPublishVolume and ControllerUnpublishVolume calls.
   * This field is optional, and may be empty if no secret is required. If the
   * secret object contains more than one secret, all secrets are passed.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.SecretReference controllerPublishSecretRef = 6;
   */
  controllerPublishSecretRef?: SecretReference;

  /**
   * nodeStageSecretRef is a reference to the secret object containing sensitive
   * information to pass to the CSI driver to complete the CSI NodeStageVolume
   * and NodeStageVolume and NodeUnstageVolume calls.
   * This field is optional, and may be empty if no secret is required. If the
   * secret object contains more than one secret, all secrets are passed.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.SecretReference nodeStageSecretRef = 7;
   */
  nodeStageSecretRef?: SecretReference;

  /**
   * nodePublishSecretRef is a reference to the secret object containing
   * sensitive information to pass to the CSI driver to complete the CSI
   * NodePublishVolume and NodeUnpublishVolume calls.
   * This field is optional, and may be empty if no secret is required. If the
   * secret object contains more than one secret, all secrets are passed.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.SecretReference nodePublishSecretRef = 8;
   */
  nodePublishSecretRef?: SecretReference;

  /**
   * controllerExpandSecretRef is a reference to the secret object containing
   * sensitive information to pass to the CSI driver to complete the CSI
   * ControllerExpandVolume call.
   * This is an alpha field and requires enabling ExpandCSIVolumes feature gate.
   * This field is optional, and may be empty if no secret is required. If the
   * secret object contains more than one secret, all secrets are passed.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.SecretReference controllerExpandSecretRef = 9;
   */
  controllerExpandSecretRef?: SecretReference;
};

/**
 * Represents storage that is managed by an external CSI volume driver (Beta feature)
 *
 * @generated from message k8s.io.api.core.v1.CSIPersistentVolumeSource
 */
export declare type CSIPersistentVolumeSourceValid = Message<"k8s.io.api.core.v1.CSIPersistentVolumeSource"> & {
  /**
   * driver is the name of the driver to use for this volume.
   * Required.
   *
   * @generated from field: optional string driver = 1;
   */
  driver: string;

  /**
   * volumeHandle is the unique volume name returned by the CSI volume
   * plugin’s CreateVolume to refer to the volume on all subsequent calls.
   * Required.
   *
   * @generated from field: optional string volumeHandle = 2;
   */
  volumeHandle: string;

  /**
   * readOnly value to pass to ControllerPublishVolumeRequest.
   * Defaults to false (read/write).
   * +optional
   *
   * @generated from field: optional bool readOnly = 3;
   */
  readOnly: boolean;

  /**
   * fsType to mount. Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs".
   * +optional
   *
   * @generated from field: optional string fsType = 4;
   */
  fsType: string;

  /**
   * volumeAttributes of the volume to publish.
   * +optional
   *
   * @generated from field: map<string, string> volumeAttributes = 5;
   */
  volumeAttributes: { [key: string]: string };

  /**
   * controllerPublishSecretRef is a reference to the secret object containing
   * sensitive information to pass to the CSI driver to complete the CSI
   * ControllerPublishVolume and ControllerUnpublishVolume calls.
   * This field is optional, and may be empty if no secret is required. If the
   * secret object contains more than one secret, all secrets are passed.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.SecretReference controllerPublishSecretRef = 6;
   */
  controllerPublishSecretRef?: SecretReferenceValid;

  /**
   * nodeStageSecretRef is a reference to the secret object containing sensitive
   * information to pass to the CSI driver to complete the CSI NodeStageVolume
   * and NodeStageVolume and NodeUnstageVolume calls.
   * This field is optional, and may be empty if no secret is required. If the
   * secret object contains more than one secret, all secrets are passed.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.SecretReference nodeStageSecretRef = 7;
   */
  nodeStageSecretRef?: SecretReferenceValid;

  /**
   * nodePublishSecretRef is a reference to the secret object containing
   * sensitive information to pass to the CSI driver to complete the CSI
   * NodePublishVolume and NodeUnpublishVolume calls.
   * This field is optional, and may be empty if no secret is required. If the
   * secret object contains more than one secret, all secrets are passed.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.SecretReference nodePublishSecretRef = 8;
   */
  nodePublishSecretRef?: SecretReferenceValid;

  /**
   * controllerExpandSecretRef is a reference to the secret object containing
   * sensitive information to pass to the CSI driver to complete the CSI
   * ControllerExpandVolume call.
   * This is an alpha field and requires enabling ExpandCSIVolumes feature gate.
   * This field is optional, and may be empty if no secret is required. If the
   * secret object contains more than one secret, all secrets are passed.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.SecretReference controllerExpandSecretRef = 9;
   */
  controllerExpandSecretRef?: SecretReferenceValid;
};

/**
 * Describes the message k8s.io.api.core.v1.CSIPersistentVolumeSource.
 * Use `create(CSIPersistentVolumeSourceSchema)` to create a new message.
 */
export declare const CSIPersistentVolumeSourceSchema: GenMessage<CSIPersistentVolumeSource, {validType: CSIPersistentVolumeSourceValid}>;

/**
 * Represents a source location of a volume to mount, managed by an external CSI driver
 *
 * @generated from message k8s.io.api.core.v1.CSIVolumeSource
 */
export declare type CSIVolumeSource = Message<"k8s.io.api.core.v1.CSIVolumeSource"> & {
  /**
   * driver is the name of the CSI driver that handles this volume.
   * Consult with your admin for the correct name as registered in the cluster.
   *
   * @generated from field: optional string driver = 1;
   */
  driver: string;

  /**
   * readOnly specifies a read-only configuration for the volume.
   * Defaults to false (read/write).
   * +optional
   *
   * @generated from field: optional bool readOnly = 2;
   */
  readOnly: boolean;

  /**
   * fsType to mount. Ex. "ext4", "xfs", "ntfs".
   * If not provided, the empty value is passed to the associated CSI driver
   * which will determine the default filesystem to apply.
   * +optional
   *
   * @generated from field: optional string fsType = 3;
   */
  fsType: string;

  /**
   * volumeAttributes stores driver-specific properties that are passed to the CSI
   * driver. Consult your driver's documentation for supported values.
   * +optional
   *
   * @generated from field: map<string, string> volumeAttributes = 4;
   */
  volumeAttributes: { [key: string]: string };

  /**
   * nodePublishSecretRef is a reference to the secret object containing
   * sensitive information to pass to the CSI driver to complete the CSI
   * NodePublishVolume and NodeUnpublishVolume calls.
   * This field is optional, and  may be empty if no secret is required. If the
   * secret object contains more than one secret, all secret references are passed.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.LocalObjectReference nodePublishSecretRef = 5;
   */
  nodePublishSecretRef?: LocalObjectReference;
};

/**
 * Represents a source location of a volume to mount, managed by an external CSI driver
 *
 * @generated from message k8s.io.api.core.v1.CSIVolumeSource
 */
export declare type CSIVolumeSourceValid = Message<"k8s.io.api.core.v1.CSIVolumeSource"> & {
  /**
   * driver is the name of the CSI driver that handles this volume.
   * Consult with your admin for the correct name as registered in the cluster.
   *
   * @generated from field: optional string driver = 1;
   */
  driver: string;

  /**
   * readOnly specifies a read-only configuration for the volume.
   * Defaults to false (read/write).
   * +optional
   *
   * @generated from field: optional bool readOnly = 2;
   */
  readOnly: boolean;

  /**
   * fsType to mount. Ex. "ext4", "xfs", "ntfs".
   * If not provided, the empty value is passed to the associated CSI driver
   * which will determine the default filesystem to apply.
   * +optional
   *
   * @generated from field: optional string fsType = 3;
   */
  fsType: string;

  /**
   * volumeAttributes stores driver-specific properties that are passed to the CSI
   * driver. Consult your driver's documentation for supported values.
   * +optional
   *
   * @generated from field: map<string, string> volumeAttributes = 4;
   */
  volumeAttributes: { [key: string]: string };

  /**
   * nodePublishSecretRef is a reference to the secret object containing
   * sensitive information to pass to the CSI driver to complete the CSI
   * NodePublishVolume and NodeUnpublishVolume calls.
   * This field is optional, and  may be empty if no secret is required. If the
   * secret object contains more than one secret, all secret references are passed.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.LocalObjectReference nodePublishSecretRef = 5;
   */
  nodePublishSecretRef?: LocalObjectReferenceValid;
};

/**
 * Describes the message k8s.io.api.core.v1.CSIVolumeSource.
 * Use `create(CSIVolumeSourceSchema)` to create a new message.
 */
export declare const CSIVolumeSourceSchema: GenMessage<CSIVolumeSource, {validType: CSIVolumeSourceValid}>;

/**
 * Adds and removes POSIX capabilities from running containers.
 *
 * @generated from message k8s.io.api.core.v1.Capabilities
 */
export declare type Capabilities = Message<"k8s.io.api.core.v1.Capabilities"> & {
  /**
   * Added capabilities
   * +optional
   *
   * @generated from field: repeated string add = 1;
   */
  add: string[];

  /**
   * Removed capabilities
   * +optional
   *
   * @generated from field: repeated string drop = 2;
   */
  drop: string[];
};

/**
 * Adds and removes POSIX capabilities from running containers.
 *
 * @generated from message k8s.io.api.core.v1.Capabilities
 */
export declare type CapabilitiesValid = Message<"k8s.io.api.core.v1.Capabilities"> & {
  /**
   * Added capabilities
   * +optional
   *
   * @generated from field: repeated string add = 1;
   */
  add: string[];

  /**
   * Removed capabilities
   * +optional
   *
   * @generated from field: repeated string drop = 2;
   */
  drop: string[];
};

/**
 * Describes the message k8s.io.api.core.v1.Capabilities.
 * Use `create(CapabilitiesSchema)` to create a new message.
 */
export declare const CapabilitiesSchema: GenMessage<Capabilities, {validType: CapabilitiesValid}>;

/**
 * Represents a Ceph Filesystem mount that lasts the lifetime of a pod
 * Cephfs volumes do not support ownership management or SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.CephFSPersistentVolumeSource
 */
export declare type CephFSPersistentVolumeSource = Message<"k8s.io.api.core.v1.CephFSPersistentVolumeSource"> & {
  /**
   * monitors is Required: Monitors is a collection of Ceph monitors
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @generated from field: repeated string monitors = 1;
   */
  monitors: string[];

  /**
   * path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   * +optional
   *
   * @generated from field: optional string path = 2;
   */
  path: string;

  /**
   * user is Optional: User is the rados user name, default is admin
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   * +optional
   *
   * @generated from field: optional string user = 3;
   */
  user: string;

  /**
   * secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   * +optional
   *
   * @generated from field: optional string secretFile = 4;
   */
  secretFile: string;

  /**
   * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.SecretReference secretRef = 5;
   */
  secretRef?: SecretReference;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   * +optional
   *
   * @generated from field: optional bool readOnly = 6;
   */
  readOnly: boolean;
};

/**
 * Represents a Ceph Filesystem mount that lasts the lifetime of a pod
 * Cephfs volumes do not support ownership management or SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.CephFSPersistentVolumeSource
 */
export declare type CephFSPersistentVolumeSourceValid = Message<"k8s.io.api.core.v1.CephFSPersistentVolumeSource"> & {
  /**
   * monitors is Required: Monitors is a collection of Ceph monitors
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @generated from field: repeated string monitors = 1;
   */
  monitors: string[];

  /**
   * path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   * +optional
   *
   * @generated from field: optional string path = 2;
   */
  path: string;

  /**
   * user is Optional: User is the rados user name, default is admin
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   * +optional
   *
   * @generated from field: optional string user = 3;
   */
  user: string;

  /**
   * secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   * +optional
   *
   * @generated from field: optional string secretFile = 4;
   */
  secretFile: string;

  /**
   * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.SecretReference secretRef = 5;
   */
  secretRef?: SecretReferenceValid;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   * +optional
   *
   * @generated from field: optional bool readOnly = 6;
   */
  readOnly: boolean;
};

/**
 * Describes the message k8s.io.api.core.v1.CephFSPersistentVolumeSource.
 * Use `create(CephFSPersistentVolumeSourceSchema)` to create a new message.
 */
export declare const CephFSPersistentVolumeSourceSchema: GenMessage<CephFSPersistentVolumeSource, {validType: CephFSPersistentVolumeSourceValid}>;

/**
 * Represents a Ceph Filesystem mount that lasts the lifetime of a pod
 * Cephfs volumes do not support ownership management or SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.CephFSVolumeSource
 */
export declare type CephFSVolumeSource = Message<"k8s.io.api.core.v1.CephFSVolumeSource"> & {
  /**
   * monitors is Required: Monitors is a collection of Ceph monitors
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @generated from field: repeated string monitors = 1;
   */
  monitors: string[];

  /**
   * path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   * +optional
   *
   * @generated from field: optional string path = 2;
   */
  path: string;

  /**
   * user is optional: User is the rados user name, default is admin
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   * +optional
   *
   * @generated from field: optional string user = 3;
   */
  user: string;

  /**
   * secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   * +optional
   *
   * @generated from field: optional string secretFile = 4;
   */
  secretFile: string;

  /**
   * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.LocalObjectReference secretRef = 5;
   */
  secretRef?: LocalObjectReference;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   * +optional
   *
   * @generated from field: optional bool readOnly = 6;
   */
  readOnly: boolean;
};

/**
 * Represents a Ceph Filesystem mount that lasts the lifetime of a pod
 * Cephfs volumes do not support ownership management or SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.CephFSVolumeSource
 */
export declare type CephFSVolumeSourceValid = Message<"k8s.io.api.core.v1.CephFSVolumeSource"> & {
  /**
   * monitors is Required: Monitors is a collection of Ceph monitors
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   *
   * @generated from field: repeated string monitors = 1;
   */
  monitors: string[];

  /**
   * path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   * +optional
   *
   * @generated from field: optional string path = 2;
   */
  path: string;

  /**
   * user is optional: User is the rados user name, default is admin
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   * +optional
   *
   * @generated from field: optional string user = 3;
   */
  user: string;

  /**
   * secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   * +optional
   *
   * @generated from field: optional string secretFile = 4;
   */
  secretFile: string;

  /**
   * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.LocalObjectReference secretRef = 5;
   */
  secretRef?: LocalObjectReferenceValid;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
   * +optional
   *
   * @generated from field: optional bool readOnly = 6;
   */
  readOnly: boolean;
};

/**
 * Describes the message k8s.io.api.core.v1.CephFSVolumeSource.
 * Use `create(CephFSVolumeSourceSchema)` to create a new message.
 */
export declare const CephFSVolumeSourceSchema: GenMessage<CephFSVolumeSource, {validType: CephFSVolumeSourceValid}>;

/**
 * Represents a cinder volume resource in Openstack.
 * A Cinder volume must exist before mounting to a container.
 * The volume must also be in the same region as the kubelet.
 * Cinder volumes support ownership management and SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.CinderPersistentVolumeSource
 */
export declare type CinderPersistentVolumeSource = Message<"k8s.io.api.core.v1.CinderPersistentVolumeSource"> & {
  /**
   * volumeID used to identify the volume in cinder.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @generated from field: optional string volumeID = 1;
   */
  volumeID: string;

  /**
   * fsType Filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   * +optional
   *
   * @generated from field: optional string fsType = 2;
   */
  fsType: string;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   * +optional
   *
   * @generated from field: optional bool readOnly = 3;
   */
  readOnly: boolean;

  /**
   * secretRef is Optional: points to a secret object containing parameters used to connect
   * to OpenStack.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.SecretReference secretRef = 4;
   */
  secretRef?: SecretReference;
};

/**
 * Represents a cinder volume resource in Openstack.
 * A Cinder volume must exist before mounting to a container.
 * The volume must also be in the same region as the kubelet.
 * Cinder volumes support ownership management and SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.CinderPersistentVolumeSource
 */
export declare type CinderPersistentVolumeSourceValid = Message<"k8s.io.api.core.v1.CinderPersistentVolumeSource"> & {
  /**
   * volumeID used to identify the volume in cinder.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @generated from field: optional string volumeID = 1;
   */
  volumeID: string;

  /**
   * fsType Filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   * +optional
   *
   * @generated from field: optional string fsType = 2;
   */
  fsType: string;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   * +optional
   *
   * @generated from field: optional bool readOnly = 3;
   */
  readOnly: boolean;

  /**
   * secretRef is Optional: points to a secret object containing parameters used to connect
   * to OpenStack.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.SecretReference secretRef = 4;
   */
  secretRef?: SecretReferenceValid;
};

/**
 * Describes the message k8s.io.api.core.v1.CinderPersistentVolumeSource.
 * Use `create(CinderPersistentVolumeSourceSchema)` to create a new message.
 */
export declare const CinderPersistentVolumeSourceSchema: GenMessage<CinderPersistentVolumeSource, {validType: CinderPersistentVolumeSourceValid}>;

/**
 * Represents a cinder volume resource in Openstack.
 * A Cinder volume must exist before mounting to a container.
 * The volume must also be in the same region as the kubelet.
 * Cinder volumes support ownership management and SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.CinderVolumeSource
 */
export declare type CinderVolumeSource = Message<"k8s.io.api.core.v1.CinderVolumeSource"> & {
  /**
   * volumeID used to identify the volume in cinder.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @generated from field: optional string volumeID = 1;
   */
  volumeID: string;

  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   * +optional
   *
   * @generated from field: optional string fsType = 2;
   */
  fsType: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   * +optional
   *
   * @generated from field: optional bool readOnly = 3;
   */
  readOnly: boolean;

  /**
   * secretRef is optional: points to a secret object containing parameters used to connect
   * to OpenStack.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.LocalObjectReference secretRef = 4;
   */
  secretRef?: LocalObjectReference;
};

/**
 * Represents a cinder volume resource in Openstack.
 * A Cinder volume must exist before mounting to a container.
 * The volume must also be in the same region as the kubelet.
 * Cinder volumes support ownership management and SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.CinderVolumeSource
 */
export declare type CinderVolumeSourceValid = Message<"k8s.io.api.core.v1.CinderVolumeSource"> & {
  /**
   * volumeID used to identify the volume in cinder.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   *
   * @generated from field: optional string volumeID = 1;
   */
  volumeID: string;

  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   * +optional
   *
   * @generated from field: optional string fsType = 2;
   */
  fsType: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   * +optional
   *
   * @generated from field: optional bool readOnly = 3;
   */
  readOnly: boolean;

  /**
   * secretRef is optional: points to a secret object containing parameters used to connect
   * to OpenStack.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.LocalObjectReference secretRef = 4;
   */
  secretRef?: LocalObjectReferenceValid;
};

/**
 * Describes the message k8s.io.api.core.v1.CinderVolumeSource.
 * Use `create(CinderVolumeSourceSchema)` to create a new message.
 */
export declare const CinderVolumeSourceSchema: GenMessage<CinderVolumeSource, {validType: CinderVolumeSourceValid}>;

/**
 * ClientIPConfig represents the configurations of Client IP based session affinity.
 *
 * @generated from message k8s.io.api.core.v1.ClientIPConfig
 */
export declare type ClientIPConfig = Message<"k8s.io.api.core.v1.ClientIPConfig"> & {
  /**
   * timeoutSeconds specifies the seconds of ClientIP type session sticky time.
   * The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
   * Default value is 10800(for 3 hours).
   * +optional
   *
   * @generated from field: optional int32 timeoutSeconds = 1;
   */
  timeoutSeconds: number;
};

/**
 * ClientIPConfig represents the configurations of Client IP based session affinity.
 *
 * @generated from message k8s.io.api.core.v1.ClientIPConfig
 */
export declare type ClientIPConfigValid = Message<"k8s.io.api.core.v1.ClientIPConfig"> & {
  /**
   * timeoutSeconds specifies the seconds of ClientIP type session sticky time.
   * The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
   * Default value is 10800(for 3 hours).
   * +optional
   *
   * @generated from field: optional int32 timeoutSeconds = 1;
   */
  timeoutSeconds: number;
};

/**
 * Describes the message k8s.io.api.core.v1.ClientIPConfig.
 * Use `create(ClientIPConfigSchema)` to create a new message.
 */
export declare const ClientIPConfigSchema: GenMessage<ClientIPConfig, {validType: ClientIPConfigValid}>;

/**
 * Information about the condition of a component.
 *
 * @generated from message k8s.io.api.core.v1.ComponentCondition
 */
export declare type ComponentCondition = Message<"k8s.io.api.core.v1.ComponentCondition"> & {
  /**
   * Type of condition for a component.
   * Valid value: "Healthy"
   *
   * @generated from field: optional string type = 1;
   */
  type: string;

  /**
   * Status of the condition for a component.
   * Valid values for "Healthy": "True", "False", or "Unknown".
   *
   * @generated from field: optional string status = 2;
   */
  status: string;

  /**
   * Message about the condition for a component.
   * For example, information about a health check.
   * +optional
   *
   * @generated from field: optional string message = 3;
   */
  message: string;

  /**
   * Condition error code for a component.
   * For example, a health check error code.
   * +optional
   *
   * @generated from field: optional string error = 4;
   */
  error: string;
};

/**
 * Information about the condition of a component.
 *
 * @generated from message k8s.io.api.core.v1.ComponentCondition
 */
export declare type ComponentConditionValid = Message<"k8s.io.api.core.v1.ComponentCondition"> & {
  /**
   * Type of condition for a component.
   * Valid value: "Healthy"
   *
   * @generated from field: optional string type = 1;
   */
  type: string;

  /**
   * Status of the condition for a component.
   * Valid values for "Healthy": "True", "False", or "Unknown".
   *
   * @generated from field: optional string status = 2;
   */
  status: string;

  /**
   * Message about the condition for a component.
   * For example, information about a health check.
   * +optional
   *
   * @generated from field: optional string message = 3;
   */
  message: string;

  /**
   * Condition error code for a component.
   * For example, a health check error code.
   * +optional
   *
   * @generated from field: optional string error = 4;
   */
  error: string;
};

/**
 * Describes the message k8s.io.api.core.v1.ComponentCondition.
 * Use `create(ComponentConditionSchema)` to create a new message.
 */
export declare const ComponentConditionSchema: GenMessage<ComponentCondition, {validType: ComponentConditionValid}>;

/**
 * ComponentStatus (and ComponentStatusList) holds the cluster validation info.
 * Deprecated: This API is deprecated in v1.19+
 *
 * @generated from message k8s.io.api.core.v1.ComponentStatus
 */
export declare type ComponentStatus = Message<"k8s.io.api.core.v1.ComponentStatus"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMeta;

  /**
   * List of component conditions observed
   * +optional
   * +patchMergeKey=type
   * +patchStrategy=merge
   *
   * @generated from field: repeated k8s.io.api.core.v1.ComponentCondition conditions = 2;
   */
  conditions: ComponentCondition[];
};

/**
 * ComponentStatus (and ComponentStatusList) holds the cluster validation info.
 * Deprecated: This API is deprecated in v1.19+
 *
 * @generated from message k8s.io.api.core.v1.ComponentStatus
 */
export declare type ComponentStatusValid = Message<"k8s.io.api.core.v1.ComponentStatus"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMetaValid;

  /**
   * List of component conditions observed
   * +optional
   * +patchMergeKey=type
   * +patchStrategy=merge
   *
   * @generated from field: repeated k8s.io.api.core.v1.ComponentCondition conditions = 2;
   */
  conditions: ComponentConditionValid[];
};

/**
 * Describes the message k8s.io.api.core.v1.ComponentStatus.
 * Use `create(ComponentStatusSchema)` to create a new message.
 */
export declare const ComponentStatusSchema: GenMessage<ComponentStatus, {validType: ComponentStatusValid}>;

/**
 * Status of all the conditions for the component as a list of ComponentStatus objects.
 * Deprecated: This API is deprecated in v1.19+
 *
 * @generated from message k8s.io.api.core.v1.ComponentStatusList
 */
export declare type ComponentStatusList = Message<"k8s.io.api.core.v1.ComponentStatusList"> & {
  /**
   * Standard list metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMeta;

  /**
   * List of ComponentStatus objects.
   *
   * @generated from field: repeated k8s.io.api.core.v1.ComponentStatus items = 2;
   */
  items: ComponentStatus[];
};

/**
 * Status of all the conditions for the component as a list of ComponentStatus objects.
 * Deprecated: This API is deprecated in v1.19+
 *
 * @generated from message k8s.io.api.core.v1.ComponentStatusList
 */
export declare type ComponentStatusListValid = Message<"k8s.io.api.core.v1.ComponentStatusList"> & {
  /**
   * Standard list metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMetaValid;

  /**
   * List of ComponentStatus objects.
   *
   * @generated from field: repeated k8s.io.api.core.v1.ComponentStatus items = 2;
   */
  items: ComponentStatusValid[];
};

/**
 * Describes the message k8s.io.api.core.v1.ComponentStatusList.
 * Use `create(ComponentStatusListSchema)` to create a new message.
 */
export declare const ComponentStatusListSchema: GenMessage<ComponentStatusList, {validType: ComponentStatusListValid}>;

/**
 * ConfigMap holds configuration data for pods to consume.
 *
 * @generated from message k8s.io.api.core.v1.ConfigMap
 */
export declare type ConfigMap = Message<"k8s.io.api.core.v1.ConfigMap"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMeta;

  /**
   * Immutable, if set to true, ensures that data stored in the ConfigMap cannot
   * be updated (only object metadata can be modified).
   * If not set to true, the field can be modified at any time.
   * Defaulted to nil.
   * +optional
   *
   * @generated from field: optional bool immutable = 4;
   */
  immutable: boolean;

  /**
   * Data contains the configuration data.
   * Each key must consist of alphanumeric characters, '-', '_' or '.'.
   * Values with non-UTF-8 byte sequences must use the BinaryData field.
   * The keys stored in Data must not overlap with the keys in
   * the BinaryData field, this is enforced during validation process.
   * +optional
   *
   * @generated from field: map<string, string> data = 2;
   */
  data: { [key: string]: string };

  /**
   * BinaryData contains the binary data.
   * Each key must consist of alphanumeric characters, '-', '_' or '.'.
   * BinaryData can contain byte sequences that are not in the UTF-8 range.
   * The keys stored in BinaryData must not overlap with the ones in
   * the Data field, this is enforced during validation process.
   * Using this field will require 1.10+ apiserver and
   * kubelet.
   * +optional
   *
   * @generated from field: map<string, bytes> binaryData = 3;
   */
  binaryData: { [key: string]: Uint8Array };
};

/**
 * ConfigMap holds configuration data for pods to consume.
 *
 * @generated from message k8s.io.api.core.v1.ConfigMap
 */
export declare type ConfigMapValid = Message<"k8s.io.api.core.v1.ConfigMap"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMetaValid;

  /**
   * Immutable, if set to true, ensures that data stored in the ConfigMap cannot
   * be updated (only object metadata can be modified).
   * If not set to true, the field can be modified at any time.
   * Defaulted to nil.
   * +optional
   *
   * @generated from field: optional bool immutable = 4;
   */
  immutable: boolean;

  /**
   * Data contains the configuration data.
   * Each key must consist of alphanumeric characters, '-', '_' or '.'.
   * Values with non-UTF-8 byte sequences must use the BinaryData field.
   * The keys stored in Data must not overlap with the keys in
   * the BinaryData field, this is enforced during validation process.
   * +optional
   *
   * @generated from field: map<string, string> data = 2;
   */
  data: { [key: string]: string };

  /**
   * BinaryData contains the binary data.
   * Each key must consist of alphanumeric characters, '-', '_' or '.'.
   * BinaryData can contain byte sequences that are not in the UTF-8 range.
   * The keys stored in BinaryData must not overlap with the ones in
   * the Data field, this is enforced during validation process.
   * Using this field will require 1.10+ apiserver and
   * kubelet.
   * +optional
   *
   * @generated from field: map<string, bytes> binaryData = 3;
   */
  binaryData: { [key: string]: Uint8Array };
};

/**
 * Describes the message k8s.io.api.core.v1.ConfigMap.
 * Use `create(ConfigMapSchema)` to create a new message.
 */
export declare const ConfigMapSchema: GenMessage<ConfigMap, {validType: ConfigMapValid}>;

/**
 * ConfigMapEnvSource selects a ConfigMap to populate the environment
 * variables with.
 *
 * The contents of the target ConfigMap's Data field will represent the
 * key-value pairs as environment variables.
 *
 * @generated from message k8s.io.api.core.v1.ConfigMapEnvSource
 */
export declare type ConfigMapEnvSource = Message<"k8s.io.api.core.v1.ConfigMapEnvSource"> & {
  /**
   * The ConfigMap to select from.
   *
   * @generated from field: optional k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;
   */
  localObjectReference?: LocalObjectReference;

  /**
   * Specify whether the ConfigMap must be defined
   * +optional
   *
   * @generated from field: optional bool optional = 2;
   */
  optional: boolean;
};

/**
 * ConfigMapEnvSource selects a ConfigMap to populate the environment
 * variables with.
 *
 * The contents of the target ConfigMap's Data field will represent the
 * key-value pairs as environment variables.
 *
 * @generated from message k8s.io.api.core.v1.ConfigMapEnvSource
 */
export declare type ConfigMapEnvSourceValid = Message<"k8s.io.api.core.v1.ConfigMapEnvSource"> & {
  /**
   * The ConfigMap to select from.
   *
   * @generated from field: optional k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;
   */
  localObjectReference?: LocalObjectReferenceValid;

  /**
   * Specify whether the ConfigMap must be defined
   * +optional
   *
   * @generated from field: optional bool optional = 2;
   */
  optional: boolean;
};

/**
 * Describes the message k8s.io.api.core.v1.ConfigMapEnvSource.
 * Use `create(ConfigMapEnvSourceSchema)` to create a new message.
 */
export declare const ConfigMapEnvSourceSchema: GenMessage<ConfigMapEnvSource, {validType: ConfigMapEnvSourceValid}>;

/**
 * Selects a key from a ConfigMap.
 * +structType=atomic
 *
 * @generated from message k8s.io.api.core.v1.ConfigMapKeySelector
 */
export declare type ConfigMapKeySelector = Message<"k8s.io.api.core.v1.ConfigMapKeySelector"> & {
  /**
   * The ConfigMap to select from.
   *
   * @generated from field: optional k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;
   */
  localObjectReference?: LocalObjectReference;

  /**
   * The key to select.
   *
   * @generated from field: optional string key = 2;
   */
  key: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   * +optional
   *
   * @generated from field: optional bool optional = 3;
   */
  optional: boolean;
};

/**
 * Selects a key from a ConfigMap.
 * +structType=atomic
 *
 * @generated from message k8s.io.api.core.v1.ConfigMapKeySelector
 */
export declare type ConfigMapKeySelectorValid = Message<"k8s.io.api.core.v1.ConfigMapKeySelector"> & {
  /**
   * The ConfigMap to select from.
   *
   * @generated from field: optional k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;
   */
  localObjectReference?: LocalObjectReferenceValid;

  /**
   * The key to select.
   *
   * @generated from field: optional string key = 2;
   */
  key: string;

  /**
   * Specify whether the ConfigMap or its key must be defined
   * +optional
   *
   * @generated from field: optional bool optional = 3;
   */
  optional: boolean;
};

/**
 * Describes the message k8s.io.api.core.v1.ConfigMapKeySelector.
 * Use `create(ConfigMapKeySelectorSchema)` to create a new message.
 */
export declare const ConfigMapKeySelectorSchema: GenMessage<ConfigMapKeySelector, {validType: ConfigMapKeySelectorValid}>;

/**
 * ConfigMapList is a resource containing a list of ConfigMap objects.
 *
 * @generated from message k8s.io.api.core.v1.ConfigMapList
 */
export declare type ConfigMapList = Message<"k8s.io.api.core.v1.ConfigMapList"> & {
  /**
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMeta;

  /**
   * Items is the list of ConfigMaps.
   *
   * @generated from field: repeated k8s.io.api.core.v1.ConfigMap items = 2;
   */
  items: ConfigMap[];
};

/**
 * ConfigMapList is a resource containing a list of ConfigMap objects.
 *
 * @generated from message k8s.io.api.core.v1.ConfigMapList
 */
export declare type ConfigMapListValid = Message<"k8s.io.api.core.v1.ConfigMapList"> & {
  /**
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMetaValid;

  /**
   * Items is the list of ConfigMaps.
   *
   * @generated from field: repeated k8s.io.api.core.v1.ConfigMap items = 2;
   */
  items: ConfigMapValid[];
};

/**
 * Describes the message k8s.io.api.core.v1.ConfigMapList.
 * Use `create(ConfigMapListSchema)` to create a new message.
 */
export declare const ConfigMapListSchema: GenMessage<ConfigMapList, {validType: ConfigMapListValid}>;

/**
 * ConfigMapNodeConfigSource contains the information to reference a ConfigMap as a config source for the Node.
 * This API is deprecated since 1.22: https://git.k8s.io/enhancements/keps/sig-node/281-dynamic-kubelet-configuration
 *
 * @generated from message k8s.io.api.core.v1.ConfigMapNodeConfigSource
 */
export declare type ConfigMapNodeConfigSource = Message<"k8s.io.api.core.v1.ConfigMapNodeConfigSource"> & {
  /**
   * Namespace is the metadata.namespace of the referenced ConfigMap.
   * This field is required in all cases.
   *
   * @generated from field: optional string namespace = 1;
   */
  namespace: string;

  /**
   * Name is the metadata.name of the referenced ConfigMap.
   * This field is required in all cases.
   *
   * @generated from field: optional string name = 2;
   */
  name: string;

  /**
   * UID is the metadata.UID of the referenced ConfigMap.
   * This field is forbidden in Node.Spec, and required in Node.Status.
   * +optional
   *
   * @generated from field: optional string uid = 3;
   */
  uid: string;

  /**
   * ResourceVersion is the metadata.ResourceVersion of the referenced ConfigMap.
   * This field is forbidden in Node.Spec, and required in Node.Status.
   * +optional
   *
   * @generated from field: optional string resourceVersion = 4;
   */
  resourceVersion: string;

  /**
   * KubeletConfigKey declares which key of the referenced ConfigMap corresponds to the KubeletConfiguration structure
   * This field is required in all cases.
   *
   * @generated from field: optional string kubeletConfigKey = 5;
   */
  kubeletConfigKey: string;
};

/**
 * ConfigMapNodeConfigSource contains the information to reference a ConfigMap as a config source for the Node.
 * This API is deprecated since 1.22: https://git.k8s.io/enhancements/keps/sig-node/281-dynamic-kubelet-configuration
 *
 * @generated from message k8s.io.api.core.v1.ConfigMapNodeConfigSource
 */
export declare type ConfigMapNodeConfigSourceValid = Message<"k8s.io.api.core.v1.ConfigMapNodeConfigSource"> & {
  /**
   * Namespace is the metadata.namespace of the referenced ConfigMap.
   * This field is required in all cases.
   *
   * @generated from field: optional string namespace = 1;
   */
  namespace: string;

  /**
   * Name is the metadata.name of the referenced ConfigMap.
   * This field is required in all cases.
   *
   * @generated from field: optional string name = 2;
   */
  name: string;

  /**
   * UID is the metadata.UID of the referenced ConfigMap.
   * This field is forbidden in Node.Spec, and required in Node.Status.
   * +optional
   *
   * @generated from field: optional string uid = 3;
   */
  uid: string;

  /**
   * ResourceVersion is the metadata.ResourceVersion of the referenced ConfigMap.
   * This field is forbidden in Node.Spec, and required in Node.Status.
   * +optional
   *
   * @generated from field: optional string resourceVersion = 4;
   */
  resourceVersion: string;

  /**
   * KubeletConfigKey declares which key of the referenced ConfigMap corresponds to the KubeletConfiguration structure
   * This field is required in all cases.
   *
   * @generated from field: optional string kubeletConfigKey = 5;
   */
  kubeletConfigKey: string;
};

/**
 * Describes the message k8s.io.api.core.v1.ConfigMapNodeConfigSource.
 * Use `create(ConfigMapNodeConfigSourceSchema)` to create a new message.
 */
export declare const ConfigMapNodeConfigSourceSchema: GenMessage<ConfigMapNodeConfigSource, {validType: ConfigMapNodeConfigSourceValid}>;

/**
 * Adapts a ConfigMap into a projected volume.
 *
 * The contents of the target ConfigMap's Data field will be presented in a
 * projected volume as files using the keys in the Data field as the file names,
 * unless the items element is populated with specific mappings of keys to paths.
 * Note that this is identical to a configmap volume source without the default
 * mode.
 *
 * @generated from message k8s.io.api.core.v1.ConfigMapProjection
 */
export declare type ConfigMapProjection = Message<"k8s.io.api.core.v1.ConfigMapProjection"> & {
  /**
   * @generated from field: optional k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;
   */
  localObjectReference?: LocalObjectReference;

  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.KeyToPath items = 2;
   */
  items: KeyToPath[];

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   * +optional
   *
   * @generated from field: optional bool optional = 4;
   */
  optional: boolean;
};

/**
 * Adapts a ConfigMap into a projected volume.
 *
 * The contents of the target ConfigMap's Data field will be presented in a
 * projected volume as files using the keys in the Data field as the file names,
 * unless the items element is populated with specific mappings of keys to paths.
 * Note that this is identical to a configmap volume source without the default
 * mode.
 *
 * @generated from message k8s.io.api.core.v1.ConfigMapProjection
 */
export declare type ConfigMapProjectionValid = Message<"k8s.io.api.core.v1.ConfigMapProjection"> & {
  /**
   * @generated from field: optional k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;
   */
  localObjectReference?: LocalObjectReferenceValid;

  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.KeyToPath items = 2;
   */
  items: KeyToPathValid[];

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   * +optional
   *
   * @generated from field: optional bool optional = 4;
   */
  optional: boolean;
};

/**
 * Describes the message k8s.io.api.core.v1.ConfigMapProjection.
 * Use `create(ConfigMapProjectionSchema)` to create a new message.
 */
export declare const ConfigMapProjectionSchema: GenMessage<ConfigMapProjection, {validType: ConfigMapProjectionValid}>;

/**
 * Adapts a ConfigMap into a volume.
 *
 * The contents of the target ConfigMap's Data field will be presented in a
 * volume as files using the keys in the Data field as the file names, unless
 * the items element is populated with specific mappings of keys to paths.
 * ConfigMap volumes support ownership management and SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.ConfigMapVolumeSource
 */
export declare type ConfigMapVolumeSource = Message<"k8s.io.api.core.v1.ConfigMapVolumeSource"> & {
  /**
   * @generated from field: optional k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;
   */
  localObjectReference?: LocalObjectReference;

  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.KeyToPath items = 2;
   */
  items: KeyToPath[];

  /**
   * defaultMode is optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   * +optional
   *
   * @generated from field: optional int32 defaultMode = 3;
   */
  defaultMode: number;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   * +optional
   *
   * @generated from field: optional bool optional = 4;
   */
  optional: boolean;
};

/**
 * Adapts a ConfigMap into a volume.
 *
 * The contents of the target ConfigMap's Data field will be presented in a
 * volume as files using the keys in the Data field as the file names, unless
 * the items element is populated with specific mappings of keys to paths.
 * ConfigMap volumes support ownership management and SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.ConfigMapVolumeSource
 */
export declare type ConfigMapVolumeSourceValid = Message<"k8s.io.api.core.v1.ConfigMapVolumeSource"> & {
  /**
   * @generated from field: optional k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;
   */
  localObjectReference?: LocalObjectReferenceValid;

  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * ConfigMap will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the ConfigMap,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.KeyToPath items = 2;
   */
  items: KeyToPathValid[];

  /**
   * defaultMode is optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   * +optional
   *
   * @generated from field: optional int32 defaultMode = 3;
   */
  defaultMode: number;

  /**
   * optional specify whether the ConfigMap or its keys must be defined
   * +optional
   *
   * @generated from field: optional bool optional = 4;
   */
  optional: boolean;
};

/**
 * Describes the message k8s.io.api.core.v1.ConfigMapVolumeSource.
 * Use `create(ConfigMapVolumeSourceSchema)` to create a new message.
 */
export declare const ConfigMapVolumeSourceSchema: GenMessage<ConfigMapVolumeSource, {validType: ConfigMapVolumeSourceValid}>;

/**
 * A single application container that you want to run within a pod.
 *
 * @generated from message k8s.io.api.core.v1.Container
 */
export declare type Container = Message<"k8s.io.api.core.v1.Container"> & {
  /**
   * Name of the container specified as a DNS_LABEL.
   * Each container in a pod must have a unique name (DNS_LABEL).
   * Cannot be updated.
   *
   * @generated from field: optional string name = 1;
   */
  name: string;

  /**
   * Container image name.
   * More info: https://kubernetes.io/docs/concepts/containers/images
   * This field is optional to allow higher level config management to default or override
   * container images in workload controllers like Deployments and StatefulSets.
   * +optional
   *
   * @generated from field: optional string image = 2;
   */
  image: string;

  /**
   * Entrypoint array. Not executed within a shell.
   * The container image's ENTRYPOINT is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   * +optional
   *
   * @generated from field: repeated string command = 3;
   */
  command: string[];

  /**
   * Arguments to the entrypoint.
   * The container image's CMD is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   * +optional
   *
   * @generated from field: repeated string args = 4;
   */
  args: string[];

  /**
   * Container's working directory.
   * If not specified, the container runtime's default will be used, which
   * might be configured in the container image.
   * Cannot be updated.
   * +optional
   *
   * @generated from field: optional string workingDir = 5;
   */
  workingDir: string;

  /**
   * List of ports to expose from the container. Exposing a port here gives
   * the system additional information about the network connections a
   * container uses, but is primarily informational. Not specifying a port here
   * DOES NOT prevent that port from being exposed. Any port which is
   * listening on the default "0.0.0.0" address inside a container will be
   * accessible from the network.
   * Cannot be updated.
   * +optional
   * +patchMergeKey=containerPort
   * +patchStrategy=merge
   * +listType=map
   * +listMapKey=containerPort
   * +listMapKey=protocol
   *
   * @generated from field: repeated k8s.io.api.core.v1.ContainerPort ports = 6;
   */
  ports: ContainerPort[];

  /**
   * List of sources to populate environment variables in the container.
   * The keys defined within a source must be a C_IDENTIFIER. All invalid keys
   * will be reported as an event when the container is starting. When a key exists in multiple
   * sources, the value associated with the last source will take precedence.
   * Values defined by an Env with a duplicate key will take precedence.
   * Cannot be updated.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.EnvFromSource envFrom = 19;
   */
  envFrom: EnvFromSource[];

  /**
   * List of environment variables to set in the container.
   * Cannot be updated.
   * +optional
   * +patchMergeKey=name
   * +patchStrategy=merge
   *
   * @generated from field: repeated k8s.io.api.core.v1.EnvVar env = 7;
   */
  env: EnvVar[];

  /**
   * Compute Resources required by this container.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ResourceRequirements resources = 8;
   */
  resources?: ResourceRequirements;

  /**
   * Pod volumes to mount into the container's filesystem.
   * Cannot be updated.
   * +optional
   * +patchMergeKey=mountPath
   * +patchStrategy=merge
   *
   * @generated from field: repeated k8s.io.api.core.v1.VolumeMount volumeMounts = 9;
   */
  volumeMounts: VolumeMount[];

  /**
   * volumeDevices is the list of block devices to be used by the container.
   * +patchMergeKey=devicePath
   * +patchStrategy=merge
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.VolumeDevice volumeDevices = 21;
   */
  volumeDevices: VolumeDevice[];

  /**
   * Periodic probe of container liveness.
   * Container will be restarted if the probe fails.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.Probe livenessProbe = 10;
   */
  livenessProbe?: Probe;

  /**
   * Periodic probe of container service readiness.
   * Container will be removed from service endpoints if the probe fails.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.Probe readinessProbe = 11;
   */
  readinessProbe?: Probe;

  /**
   * StartupProbe indicates that the Pod has successfully initialized.
   * If specified, no other probes are executed until this completes successfully.
   * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
   * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
   * when it might take a long time to load data or warm a cache, than during steady-state operation.
   * This cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.Probe startupProbe = 22;
   */
  startupProbe?: Probe;

  /**
   * Actions that the management system should take in response to container lifecycle events.
   * Cannot be updated.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.Lifecycle lifecycle = 12;
   */
  lifecycle?: Lifecycle;

  /**
   * Optional: Path at which the file to which the container's termination message
   * will be written is mounted into the container's filesystem.
   * Message written is intended to be brief final status, such as an assertion failure message.
   * Will be truncated by the node if greater than 4096 bytes. The total message length across
   * all containers will be limited to 12kb.
   * Defaults to /dev/termination-log.
   * Cannot be updated.
   * +optional
   *
   * @generated from field: optional string terminationMessagePath = 13;
   */
  terminationMessagePath: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of
   * terminationMessagePath to populate the container status message on both success and failure.
   * FallbackToLogsOnError will use the last chunk of container log output if the termination
   * message file is empty and the container exited with an error.
   * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
   * Defaults to File.
   * Cannot be updated.
   * +optional
   *
   * @generated from field: optional string terminationMessagePolicy = 20;
   */
  terminationMessagePolicy: string;

  /**
   * Image pull policy.
   * One of Always, Never, IfNotPresent.
   * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   * +optional
   *
   * @generated from field: optional string imagePullPolicy = 14;
   */
  imagePullPolicy: string;

  /**
   * SecurityContext defines the security options the container should be run with.
   * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
   * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.SecurityContext securityContext = 15;
   */
  securityContext?: SecurityContext;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this
   * is not set, reads from stdin in the container will always result in EOF.
   * Default is false.
   * +optional
   *
   * @generated from field: optional bool stdin = 16;
   */
  stdin: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by
   * a single attach. When stdin is true the stdin stream will remain open across multiple attach
   * sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
   * first client attaches to stdin, and then remains open and accepts data until the client disconnects,
   * at which time stdin is closed and remains closed until the container is restarted. If this
   * flag is false, a container processes that reads from stdin will never receive an EOF.
   * Default is false
   * +optional
   *
   * @generated from field: optional bool stdinOnce = 17;
   */
  stdinOnce: boolean;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
   * Default is false.
   * +optional
   *
   * @generated from field: optional bool tty = 18;
   */
  tty: boolean;
};

/**
 * A single application container that you want to run within a pod.
 *
 * @generated from message k8s.io.api.core.v1.Container
 */
export declare type ContainerValid = Message<"k8s.io.api.core.v1.Container"> & {
  /**
   * Name of the container specified as a DNS_LABEL.
   * Each container in a pod must have a unique name (DNS_LABEL).
   * Cannot be updated.
   *
   * @generated from field: optional string name = 1;
   */
  name: string;

  /**
   * Container image name.
   * More info: https://kubernetes.io/docs/concepts/containers/images
   * This field is optional to allow higher level config management to default or override
   * container images in workload controllers like Deployments and StatefulSets.
   * +optional
   *
   * @generated from field: optional string image = 2;
   */
  image: string;

  /**
   * Entrypoint array. Not executed within a shell.
   * The container image's ENTRYPOINT is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   * +optional
   *
   * @generated from field: repeated string command = 3;
   */
  command: string[];

  /**
   * Arguments to the entrypoint.
   * The container image's CMD is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   * +optional
   *
   * @generated from field: repeated string args = 4;
   */
  args: string[];

  /**
   * Container's working directory.
   * If not specified, the container runtime's default will be used, which
   * might be configured in the container image.
   * Cannot be updated.
   * +optional
   *
   * @generated from field: optional string workingDir = 5;
   */
  workingDir: string;

  /**
   * List of ports to expose from the container. Exposing a port here gives
   * the system additional information about the network connections a
   * container uses, but is primarily informational. Not specifying a port here
   * DOES NOT prevent that port from being exposed. Any port which is
   * listening on the default "0.0.0.0" address inside a container will be
   * accessible from the network.
   * Cannot be updated.
   * +optional
   * +patchMergeKey=containerPort
   * +patchStrategy=merge
   * +listType=map
   * +listMapKey=containerPort
   * +listMapKey=protocol
   *
   * @generated from field: repeated k8s.io.api.core.v1.ContainerPort ports = 6;
   */
  ports: ContainerPortValid[];

  /**
   * List of sources to populate environment variables in the container.
   * The keys defined within a source must be a C_IDENTIFIER. All invalid keys
   * will be reported as an event when the container is starting. When a key exists in multiple
   * sources, the value associated with the last source will take precedence.
   * Values defined by an Env with a duplicate key will take precedence.
   * Cannot be updated.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.EnvFromSource envFrom = 19;
   */
  envFrom: EnvFromSourceValid[];

  /**
   * List of environment variables to set in the container.
   * Cannot be updated.
   * +optional
   * +patchMergeKey=name
   * +patchStrategy=merge
   *
   * @generated from field: repeated k8s.io.api.core.v1.EnvVar env = 7;
   */
  env: EnvVarValid[];

  /**
   * Compute Resources required by this container.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ResourceRequirements resources = 8;
   */
  resources?: ResourceRequirementsValid;

  /**
   * Pod volumes to mount into the container's filesystem.
   * Cannot be updated.
   * +optional
   * +patchMergeKey=mountPath
   * +patchStrategy=merge
   *
   * @generated from field: repeated k8s.io.api.core.v1.VolumeMount volumeMounts = 9;
   */
  volumeMounts: VolumeMountValid[];

  /**
   * volumeDevices is the list of block devices to be used by the container.
   * +patchMergeKey=devicePath
   * +patchStrategy=merge
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.VolumeDevice volumeDevices = 21;
   */
  volumeDevices: VolumeDeviceValid[];

  /**
   * Periodic probe of container liveness.
   * Container will be restarted if the probe fails.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.Probe livenessProbe = 10;
   */
  livenessProbe?: ProbeValid;

  /**
   * Periodic probe of container service readiness.
   * Container will be removed from service endpoints if the probe fails.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.Probe readinessProbe = 11;
   */
  readinessProbe?: ProbeValid;

  /**
   * StartupProbe indicates that the Pod has successfully initialized.
   * If specified, no other probes are executed until this completes successfully.
   * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
   * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
   * when it might take a long time to load data or warm a cache, than during steady-state operation.
   * This cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.Probe startupProbe = 22;
   */
  startupProbe?: ProbeValid;

  /**
   * Actions that the management system should take in response to container lifecycle events.
   * Cannot be updated.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.Lifecycle lifecycle = 12;
   */
  lifecycle?: LifecycleValid;

  /**
   * Optional: Path at which the file to which the container's termination message
   * will be written is mounted into the container's filesystem.
   * Message written is intended to be brief final status, such as an assertion failure message.
   * Will be truncated by the node if greater than 4096 bytes. The total message length across
   * all containers will be limited to 12kb.
   * Defaults to /dev/termination-log.
   * Cannot be updated.
   * +optional
   *
   * @generated from field: optional string terminationMessagePath = 13;
   */
  terminationMessagePath: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of
   * terminationMessagePath to populate the container status message on both success and failure.
   * FallbackToLogsOnError will use the last chunk of container log output if the termination
   * message file is empty and the container exited with an error.
   * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
   * Defaults to File.
   * Cannot be updated.
   * +optional
   *
   * @generated from field: optional string terminationMessagePolicy = 20;
   */
  terminationMessagePolicy: string;

  /**
   * Image pull policy.
   * One of Always, Never, IfNotPresent.
   * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   * +optional
   *
   * @generated from field: optional string imagePullPolicy = 14;
   */
  imagePullPolicy: string;

  /**
   * SecurityContext defines the security options the container should be run with.
   * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
   * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.SecurityContext securityContext = 15;
   */
  securityContext?: SecurityContextValid;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this
   * is not set, reads from stdin in the container will always result in EOF.
   * Default is false.
   * +optional
   *
   * @generated from field: optional bool stdin = 16;
   */
  stdin: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by
   * a single attach. When stdin is true the stdin stream will remain open across multiple attach
   * sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
   * first client attaches to stdin, and then remains open and accepts data until the client disconnects,
   * at which time stdin is closed and remains closed until the container is restarted. If this
   * flag is false, a container processes that reads from stdin will never receive an EOF.
   * Default is false
   * +optional
   *
   * @generated from field: optional bool stdinOnce = 17;
   */
  stdinOnce: boolean;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
   * Default is false.
   * +optional
   *
   * @generated from field: optional bool tty = 18;
   */
  tty: boolean;
};

/**
 * Describes the message k8s.io.api.core.v1.Container.
 * Use `create(ContainerSchema)` to create a new message.
 */
export declare const ContainerSchema: GenMessage<Container, {validType: ContainerValid}>;

/**
 * Describe a container image
 *
 * @generated from message k8s.io.api.core.v1.ContainerImage
 */
export declare type ContainerImage = Message<"k8s.io.api.core.v1.ContainerImage"> & {
  /**
   * Names by which this image is known.
   * e.g. ["k8s.gcr.io/hyperkube:v1.0.7", "dockerhub.io/google_containers/hyperkube:v1.0.7"]
   * +optional
   *
   * @generated from field: repeated string names = 1;
   */
  names: string[];

  /**
   * The size of the image in bytes.
   * +optional
   *
   * @generated from field: optional int64 sizeBytes = 2;
   */
  sizeBytes: bigint;
};

/**
 * Describe a container image
 *
 * @generated from message k8s.io.api.core.v1.ContainerImage
 */
export declare type ContainerImageValid = Message<"k8s.io.api.core.v1.ContainerImage"> & {
  /**
   * Names by which this image is known.
   * e.g. ["k8s.gcr.io/hyperkube:v1.0.7", "dockerhub.io/google_containers/hyperkube:v1.0.7"]
   * +optional
   *
   * @generated from field: repeated string names = 1;
   */
  names: string[];

  /**
   * The size of the image in bytes.
   * +optional
   *
   * @generated from field: optional int64 sizeBytes = 2;
   */
  sizeBytes: bigint;
};

/**
 * Describes the message k8s.io.api.core.v1.ContainerImage.
 * Use `create(ContainerImageSchema)` to create a new message.
 */
export declare const ContainerImageSchema: GenMessage<ContainerImage, {validType: ContainerImageValid}>;

/**
 * ContainerPort represents a network port in a single container.
 *
 * @generated from message k8s.io.api.core.v1.ContainerPort
 */
export declare type ContainerPort = Message<"k8s.io.api.core.v1.ContainerPort"> & {
  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
   * named port in a pod must have a unique name. Name for the port that can be
   * referred to by services.
   * +optional
   *
   * @generated from field: optional string name = 1;
   */
  name: string;

  /**
   * Number of port to expose on the host.
   * If specified, this must be a valid port number, 0 < x < 65536.
   * If HostNetwork is specified, this must match ContainerPort.
   * Most containers do not need this.
   * +optional
   *
   * @generated from field: optional int32 hostPort = 2;
   */
  hostPort: number;

  /**
   * Number of port to expose on the pod's IP address.
   * This must be a valid port number, 0 < x < 65536.
   *
   * @generated from field: optional int32 containerPort = 3;
   */
  containerPort: number;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP.
   * Defaults to "TCP".
   * +optional
   * +default="TCP"
   *
   * @generated from field: optional string protocol = 4;
   */
  protocol: string;

  /**
   * What host IP to bind the external port to.
   * +optional
   *
   * @generated from field: optional string hostIP = 5;
   */
  hostIP: string;
};

/**
 * ContainerPort represents a network port in a single container.
 *
 * @generated from message k8s.io.api.core.v1.ContainerPort
 */
export declare type ContainerPortValid = Message<"k8s.io.api.core.v1.ContainerPort"> & {
  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
   * named port in a pod must have a unique name. Name for the port that can be
   * referred to by services.
   * +optional
   *
   * @generated from field: optional string name = 1;
   */
  name: string;

  /**
   * Number of port to expose on the host.
   * If specified, this must be a valid port number, 0 < x < 65536.
   * If HostNetwork is specified, this must match ContainerPort.
   * Most containers do not need this.
   * +optional
   *
   * @generated from field: optional int32 hostPort = 2;
   */
  hostPort: number;

  /**
   * Number of port to expose on the pod's IP address.
   * This must be a valid port number, 0 < x < 65536.
   *
   * @generated from field: optional int32 containerPort = 3;
   */
  containerPort: number;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP.
   * Defaults to "TCP".
   * +optional
   * +default="TCP"
   *
   * @generated from field: optional string protocol = 4;
   */
  protocol: string;

  /**
   * What host IP to bind the external port to.
   * +optional
   *
   * @generated from field: optional string hostIP = 5;
   */
  hostIP: string;
};

/**
 * Describes the message k8s.io.api.core.v1.ContainerPort.
 * Use `create(ContainerPortSchema)` to create a new message.
 */
export declare const ContainerPortSchema: GenMessage<ContainerPort, {validType: ContainerPortValid}>;

/**
 * ContainerState holds a possible state of container.
 * Only one of its members may be specified.
 * If none of them is specified, the default one is ContainerStateWaiting.
 *
 * @generated from message k8s.io.api.core.v1.ContainerState
 */
export declare type ContainerState = Message<"k8s.io.api.core.v1.ContainerState"> & {
  /**
   * Details about a waiting container
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ContainerStateWaiting waiting = 1;
   */
  waiting?: ContainerStateWaiting;

  /**
   * Details about a running container
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ContainerStateRunning running = 2;
   */
  running?: ContainerStateRunning;

  /**
   * Details about a terminated container
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ContainerStateTerminated terminated = 3;
   */
  terminated?: ContainerStateTerminated;
};

/**
 * ContainerState holds a possible state of container.
 * Only one of its members may be specified.
 * If none of them is specified, the default one is ContainerStateWaiting.
 *
 * @generated from message k8s.io.api.core.v1.ContainerState
 */
export declare type ContainerStateValid = Message<"k8s.io.api.core.v1.ContainerState"> & {
  /**
   * Details about a waiting container
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ContainerStateWaiting waiting = 1;
   */
  waiting?: ContainerStateWaitingValid;

  /**
   * Details about a running container
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ContainerStateRunning running = 2;
   */
  running?: ContainerStateRunningValid;

  /**
   * Details about a terminated container
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ContainerStateTerminated terminated = 3;
   */
  terminated?: ContainerStateTerminatedValid;
};

/**
 * Describes the message k8s.io.api.core.v1.ContainerState.
 * Use `create(ContainerStateSchema)` to create a new message.
 */
export declare const ContainerStateSchema: GenMessage<ContainerState, {validType: ContainerStateValid}>;

/**
 * ContainerStateRunning is a running state of a container.
 *
 * @generated from message k8s.io.api.core.v1.ContainerStateRunning
 */
export declare type ContainerStateRunning = Message<"k8s.io.api.core.v1.ContainerStateRunning"> & {
  /**
   * Time at which the container was last (re-)started
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time startedAt = 1;
   */
  startedAt?: Time;
};

/**
 * ContainerStateRunning is a running state of a container.
 *
 * @generated from message k8s.io.api.core.v1.ContainerStateRunning
 */
export declare type ContainerStateRunningValid = Message<"k8s.io.api.core.v1.ContainerStateRunning"> & {
  /**
   * Time at which the container was last (re-)started
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time startedAt = 1;
   */
  startedAt?: TimeValid;
};

/**
 * Describes the message k8s.io.api.core.v1.ContainerStateRunning.
 * Use `create(ContainerStateRunningSchema)` to create a new message.
 */
export declare const ContainerStateRunningSchema: GenMessage<ContainerStateRunning, {validType: ContainerStateRunningValid}>;

/**
 * ContainerStateTerminated is a terminated state of a container.
 *
 * @generated from message k8s.io.api.core.v1.ContainerStateTerminated
 */
export declare type ContainerStateTerminated = Message<"k8s.io.api.core.v1.ContainerStateTerminated"> & {
  /**
   * Exit status from the last termination of the container
   *
   * @generated from field: optional int32 exitCode = 1;
   */
  exitCode: number;

  /**
   * Signal from the last termination of the container
   * +optional
   *
   * @generated from field: optional int32 signal = 2;
   */
  signal: number;

  /**
   * (brief) reason from the last termination of the container
   * +optional
   *
   * @generated from field: optional string reason = 3;
   */
  reason: string;

  /**
   * Message regarding the last termination of the container
   * +optional
   *
   * @generated from field: optional string message = 4;
   */
  message: string;

  /**
   * Time at which previous execution of the container started
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time startedAt = 5;
   */
  startedAt?: Time;

  /**
   * Time at which the container last terminated
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time finishedAt = 6;
   */
  finishedAt?: Time;

  /**
   * Container's ID in the format '<type>://<container_id>'
   * +optional
   *
   * @generated from field: optional string containerID = 7;
   */
  containerID: string;
};

/**
 * ContainerStateTerminated is a terminated state of a container.
 *
 * @generated from message k8s.io.api.core.v1.ContainerStateTerminated
 */
export declare type ContainerStateTerminatedValid = Message<"k8s.io.api.core.v1.ContainerStateTerminated"> & {
  /**
   * Exit status from the last termination of the container
   *
   * @generated from field: optional int32 exitCode = 1;
   */
  exitCode: number;

  /**
   * Signal from the last termination of the container
   * +optional
   *
   * @generated from field: optional int32 signal = 2;
   */
  signal: number;

  /**
   * (brief) reason from the last termination of the container
   * +optional
   *
   * @generated from field: optional string reason = 3;
   */
  reason: string;

  /**
   * Message regarding the last termination of the container
   * +optional
   *
   * @generated from field: optional string message = 4;
   */
  message: string;

  /**
   * Time at which previous execution of the container started
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time startedAt = 5;
   */
  startedAt?: TimeValid;

  /**
   * Time at which the container last terminated
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time finishedAt = 6;
   */
  finishedAt?: TimeValid;

  /**
   * Container's ID in the format '<type>://<container_id>'
   * +optional
   *
   * @generated from field: optional string containerID = 7;
   */
  containerID: string;
};

/**
 * Describes the message k8s.io.api.core.v1.ContainerStateTerminated.
 * Use `create(ContainerStateTerminatedSchema)` to create a new message.
 */
export declare const ContainerStateTerminatedSchema: GenMessage<ContainerStateTerminated, {validType: ContainerStateTerminatedValid}>;

/**
 * ContainerStateWaiting is a waiting state of a container.
 *
 * @generated from message k8s.io.api.core.v1.ContainerStateWaiting
 */
export declare type ContainerStateWaiting = Message<"k8s.io.api.core.v1.ContainerStateWaiting"> & {
  /**
   * (brief) reason the container is not yet running.
   * +optional
   *
   * @generated from field: optional string reason = 1;
   */
  reason: string;

  /**
   * Message regarding why the container is not yet running.
   * +optional
   *
   * @generated from field: optional string message = 2;
   */
  message: string;
};

/**
 * ContainerStateWaiting is a waiting state of a container.
 *
 * @generated from message k8s.io.api.core.v1.ContainerStateWaiting
 */
export declare type ContainerStateWaitingValid = Message<"k8s.io.api.core.v1.ContainerStateWaiting"> & {
  /**
   * (brief) reason the container is not yet running.
   * +optional
   *
   * @generated from field: optional string reason = 1;
   */
  reason: string;

  /**
   * Message regarding why the container is not yet running.
   * +optional
   *
   * @generated from field: optional string message = 2;
   */
  message: string;
};

/**
 * Describes the message k8s.io.api.core.v1.ContainerStateWaiting.
 * Use `create(ContainerStateWaitingSchema)` to create a new message.
 */
export declare const ContainerStateWaitingSchema: GenMessage<ContainerStateWaiting, {validType: ContainerStateWaitingValid}>;

/**
 * ContainerStatus contains details for the current status of this container.
 *
 * @generated from message k8s.io.api.core.v1.ContainerStatus
 */
export declare type ContainerStatus = Message<"k8s.io.api.core.v1.ContainerStatus"> & {
  /**
   * This must be a DNS_LABEL. Each container in a pod must have a unique name.
   * Cannot be updated.
   *
   * @generated from field: optional string name = 1;
   */
  name: string;

  /**
   * Details about the container's current condition.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ContainerState state = 2;
   */
  state?: ContainerState;

  /**
   * Details about the container's last termination condition.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ContainerState lastState = 3;
   */
  lastState?: ContainerState;

  /**
   * Specifies whether the container has passed its readiness probe.
   *
   * @generated from field: optional bool ready = 4;
   */
  ready: boolean;

  /**
   * The number of times the container has been restarted.
   *
   * @generated from field: optional int32 restartCount = 5;
   */
  restartCount: number;

  /**
   * The image the container is running.
   * More info: https://kubernetes.io/docs/concepts/containers/images.
   *
   * @generated from field: optional string image = 6;
   */
  image: string;

  /**
   * ImageID of the container's image.
   *
   * @generated from field: optional string imageID = 7;
   */
  imageID: string;

  /**
   * Container's ID in the format '<type>://<container_id>'.
   * +optional
   *
   * @generated from field: optional string containerID = 8;
   */
  containerID: string;

  /**
   * Specifies whether the container has passed its startup probe.
   * Initialized as false, becomes true after startupProbe is considered successful.
   * Resets to false when the container is restarted, or if kubelet loses state temporarily.
   * Is always true when no startupProbe is defined.
   * +optional
   *
   * @generated from field: optional bool started = 9;
   */
  started: boolean;
};

/**
 * ContainerStatus contains details for the current status of this container.
 *
 * @generated from message k8s.io.api.core.v1.ContainerStatus
 */
export declare type ContainerStatusValid = Message<"k8s.io.api.core.v1.ContainerStatus"> & {
  /**
   * This must be a DNS_LABEL. Each container in a pod must have a unique name.
   * Cannot be updated.
   *
   * @generated from field: optional string name = 1;
   */
  name: string;

  /**
   * Details about the container's current condition.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ContainerState state = 2;
   */
  state?: ContainerStateValid;

  /**
   * Details about the container's last termination condition.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ContainerState lastState = 3;
   */
  lastState?: ContainerStateValid;

  /**
   * Specifies whether the container has passed its readiness probe.
   *
   * @generated from field: optional bool ready = 4;
   */
  ready: boolean;

  /**
   * The number of times the container has been restarted.
   *
   * @generated from field: optional int32 restartCount = 5;
   */
  restartCount: number;

  /**
   * The image the container is running.
   * More info: https://kubernetes.io/docs/concepts/containers/images.
   *
   * @generated from field: optional string image = 6;
   */
  image: string;

  /**
   * ImageID of the container's image.
   *
   * @generated from field: optional string imageID = 7;
   */
  imageID: string;

  /**
   * Container's ID in the format '<type>://<container_id>'.
   * +optional
   *
   * @generated from field: optional string containerID = 8;
   */
  containerID: string;

  /**
   * Specifies whether the container has passed its startup probe.
   * Initialized as false, becomes true after startupProbe is considered successful.
   * Resets to false when the container is restarted, or if kubelet loses state temporarily.
   * Is always true when no startupProbe is defined.
   * +optional
   *
   * @generated from field: optional bool started = 9;
   */
  started: boolean;
};

/**
 * Describes the message k8s.io.api.core.v1.ContainerStatus.
 * Use `create(ContainerStatusSchema)` to create a new message.
 */
export declare const ContainerStatusSchema: GenMessage<ContainerStatus, {validType: ContainerStatusValid}>;

/**
 * DaemonEndpoint contains information about a single Daemon endpoint.
 *
 * @generated from message k8s.io.api.core.v1.DaemonEndpoint
 */
export declare type DaemonEndpoint = Message<"k8s.io.api.core.v1.DaemonEndpoint"> & {
  /**
   * Port number of the given endpoint.
   *
   * @generated from field: optional int32 Port = 1;
   */
  Port: number;
};

/**
 * DaemonEndpoint contains information about a single Daemon endpoint.
 *
 * @generated from message k8s.io.api.core.v1.DaemonEndpoint
 */
export declare type DaemonEndpointValid = Message<"k8s.io.api.core.v1.DaemonEndpoint"> & {
  /**
   * Port number of the given endpoint.
   *
   * @generated from field: optional int32 Port = 1;
   */
  Port: number;
};

/**
 * Describes the message k8s.io.api.core.v1.DaemonEndpoint.
 * Use `create(DaemonEndpointSchema)` to create a new message.
 */
export declare const DaemonEndpointSchema: GenMessage<DaemonEndpoint, {validType: DaemonEndpointValid}>;

/**
 * Represents downward API info for projecting into a projected volume.
 * Note that this is identical to a downwardAPI volume source without the default
 * mode.
 *
 * @generated from message k8s.io.api.core.v1.DownwardAPIProjection
 */
export declare type DownwardAPIProjection = Message<"k8s.io.api.core.v1.DownwardAPIProjection"> & {
  /**
   * Items is a list of DownwardAPIVolume file
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.DownwardAPIVolumeFile items = 1;
   */
  items: DownwardAPIVolumeFile[];
};

/**
 * Represents downward API info for projecting into a projected volume.
 * Note that this is identical to a downwardAPI volume source without the default
 * mode.
 *
 * @generated from message k8s.io.api.core.v1.DownwardAPIProjection
 */
export declare type DownwardAPIProjectionValid = Message<"k8s.io.api.core.v1.DownwardAPIProjection"> & {
  /**
   * Items is a list of DownwardAPIVolume file
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.DownwardAPIVolumeFile items = 1;
   */
  items: DownwardAPIVolumeFileValid[];
};

/**
 * Describes the message k8s.io.api.core.v1.DownwardAPIProjection.
 * Use `create(DownwardAPIProjectionSchema)` to create a new message.
 */
export declare const DownwardAPIProjectionSchema: GenMessage<DownwardAPIProjection, {validType: DownwardAPIProjectionValid}>;

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @generated from message k8s.io.api.core.v1.DownwardAPIVolumeFile
 */
export declare type DownwardAPIVolumeFile = Message<"k8s.io.api.core.v1.DownwardAPIVolumeFile"> & {
  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @generated from field: optional string path = 1;
   */
  path: string;

  /**
   * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ObjectFieldSelector fieldRef = 2;
   */
  fieldRef?: ObjectFieldSelector;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ResourceFieldSelector resourceFieldRef = 3;
   */
  resourceFieldRef?: ResourceFieldSelector;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value
   * between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   * +optional
   *
   * @generated from field: optional int32 mode = 4;
   */
  mode: number;
};

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @generated from message k8s.io.api.core.v1.DownwardAPIVolumeFile
 */
export declare type DownwardAPIVolumeFileValid = Message<"k8s.io.api.core.v1.DownwardAPIVolumeFile"> & {
  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @generated from field: optional string path = 1;
   */
  path: string;

  /**
   * Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ObjectFieldSelector fieldRef = 2;
   */
  fieldRef?: ObjectFieldSelectorValid;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ResourceFieldSelector resourceFieldRef = 3;
   */
  resourceFieldRef?: ResourceFieldSelectorValid;

  /**
   * Optional: mode bits used to set permissions on this file, must be an octal value
   * between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   * +optional
   *
   * @generated from field: optional int32 mode = 4;
   */
  mode: number;
};

/**
 * Describes the message k8s.io.api.core.v1.DownwardAPIVolumeFile.
 * Use `create(DownwardAPIVolumeFileSchema)` to create a new message.
 */
export declare const DownwardAPIVolumeFileSchema: GenMessage<DownwardAPIVolumeFile, {validType: DownwardAPIVolumeFileValid}>;

/**
 * DownwardAPIVolumeSource represents a volume containing downward API info.
 * Downward API volumes support ownership management and SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.DownwardAPIVolumeSource
 */
export declare type DownwardAPIVolumeSource = Message<"k8s.io.api.core.v1.DownwardAPIVolumeSource"> & {
  /**
   * Items is a list of downward API volume file
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.DownwardAPIVolumeFile items = 1;
   */
  items: DownwardAPIVolumeFile[];

  /**
   * Optional: mode bits to use on created files by default. Must be a
   * Optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   * +optional
   *
   * @generated from field: optional int32 defaultMode = 2;
   */
  defaultMode: number;
};

/**
 * DownwardAPIVolumeSource represents a volume containing downward API info.
 * Downward API volumes support ownership management and SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.DownwardAPIVolumeSource
 */
export declare type DownwardAPIVolumeSourceValid = Message<"k8s.io.api.core.v1.DownwardAPIVolumeSource"> & {
  /**
   * Items is a list of downward API volume file
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.DownwardAPIVolumeFile items = 1;
   */
  items: DownwardAPIVolumeFileValid[];

  /**
   * Optional: mode bits to use on created files by default. Must be a
   * Optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   * +optional
   *
   * @generated from field: optional int32 defaultMode = 2;
   */
  defaultMode: number;
};

/**
 * Describes the message k8s.io.api.core.v1.DownwardAPIVolumeSource.
 * Use `create(DownwardAPIVolumeSourceSchema)` to create a new message.
 */
export declare const DownwardAPIVolumeSourceSchema: GenMessage<DownwardAPIVolumeSource, {validType: DownwardAPIVolumeSourceValid}>;

/**
 * Represents an empty directory for a pod.
 * Empty directory volumes support ownership management and SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.EmptyDirVolumeSource
 */
export declare type EmptyDirVolumeSource = Message<"k8s.io.api.core.v1.EmptyDirVolumeSource"> & {
  /**
   * medium represents what type of storage medium should back this directory.
   * The default is "" which means to use the node's default medium.
   * Must be an empty string (default) or Memory.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   * +optional
   *
   * @generated from field: optional string medium = 1;
   */
  medium: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume.
   * The size limit is also applicable for memory medium.
   * The maximum usage on memory medium EmptyDir would be the minimum value between
   * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
   * The default is nil which means that the limit is undefined.
   * More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.api.resource.Quantity sizeLimit = 2;
   */
  sizeLimit?: Quantity;
};

/**
 * Represents an empty directory for a pod.
 * Empty directory volumes support ownership management and SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.EmptyDirVolumeSource
 */
export declare type EmptyDirVolumeSourceValid = Message<"k8s.io.api.core.v1.EmptyDirVolumeSource"> & {
  /**
   * medium represents what type of storage medium should back this directory.
   * The default is "" which means to use the node's default medium.
   * Must be an empty string (default) or Memory.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   * +optional
   *
   * @generated from field: optional string medium = 1;
   */
  medium: string;

  /**
   * sizeLimit is the total amount of local storage required for this EmptyDir volume.
   * The size limit is also applicable for memory medium.
   * The maximum usage on memory medium EmptyDir would be the minimum value between
   * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
   * The default is nil which means that the limit is undefined.
   * More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.api.resource.Quantity sizeLimit = 2;
   */
  sizeLimit?: QuantityValid;
};

/**
 * Describes the message k8s.io.api.core.v1.EmptyDirVolumeSource.
 * Use `create(EmptyDirVolumeSourceSchema)` to create a new message.
 */
export declare const EmptyDirVolumeSourceSchema: GenMessage<EmptyDirVolumeSource, {validType: EmptyDirVolumeSourceValid}>;

/**
 * EndpointAddress is a tuple that describes single IP address.
 * +structType=atomic
 *
 * @generated from message k8s.io.api.core.v1.EndpointAddress
 */
export declare type EndpointAddress = Message<"k8s.io.api.core.v1.EndpointAddress"> & {
  /**
   * The IP of this endpoint.
   * May not be loopback (127.0.0.0/8), link-local (169.254.0.0/16),
   * or link-local multicast ((224.0.0.0/24).
   * IPv6 is also accepted but not fully supported on all platforms. Also, certain
   * kubernetes components, like kube-proxy, are not IPv6 ready.
   * TODO: This should allow hostname or IP, See #4447.
   *
   * @generated from field: optional string ip = 1;
   */
  ip: string;

  /**
   * The Hostname of this endpoint
   * +optional
   *
   * @generated from field: optional string hostname = 3;
   */
  hostname: string;

  /**
   * Optional: Node hosting this endpoint. This can be used to determine endpoints local to a node.
   * +optional
   *
   * @generated from field: optional string nodeName = 4;
   */
  nodeName: string;

  /**
   * Reference to object providing the endpoint.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ObjectReference targetRef = 2;
   */
  targetRef?: ObjectReference;
};

/**
 * EndpointAddress is a tuple that describes single IP address.
 * +structType=atomic
 *
 * @generated from message k8s.io.api.core.v1.EndpointAddress
 */
export declare type EndpointAddressValid = Message<"k8s.io.api.core.v1.EndpointAddress"> & {
  /**
   * The IP of this endpoint.
   * May not be loopback (127.0.0.0/8), link-local (169.254.0.0/16),
   * or link-local multicast ((224.0.0.0/24).
   * IPv6 is also accepted but not fully supported on all platforms. Also, certain
   * kubernetes components, like kube-proxy, are not IPv6 ready.
   * TODO: This should allow hostname or IP, See #4447.
   *
   * @generated from field: optional string ip = 1;
   */
  ip: string;

  /**
   * The Hostname of this endpoint
   * +optional
   *
   * @generated from field: optional string hostname = 3;
   */
  hostname: string;

  /**
   * Optional: Node hosting this endpoint. This can be used to determine endpoints local to a node.
   * +optional
   *
   * @generated from field: optional string nodeName = 4;
   */
  nodeName: string;

  /**
   * Reference to object providing the endpoint.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ObjectReference targetRef = 2;
   */
  targetRef?: ObjectReferenceValid;
};

/**
 * Describes the message k8s.io.api.core.v1.EndpointAddress.
 * Use `create(EndpointAddressSchema)` to create a new message.
 */
export declare const EndpointAddressSchema: GenMessage<EndpointAddress, {validType: EndpointAddressValid}>;

/**
 * EndpointPort is a tuple that describes a single port.
 * +structType=atomic
 *
 * @generated from message k8s.io.api.core.v1.EndpointPort
 */
export declare type EndpointPort = Message<"k8s.io.api.core.v1.EndpointPort"> & {
  /**
   * The name of this port.  This must match the 'name' field in the
   * corresponding ServicePort.
   * Must be a DNS_LABEL.
   * Optional only if one port is defined.
   * +optional
   *
   * @generated from field: optional string name = 1;
   */
  name: string;

  /**
   * The port number of the endpoint.
   *
   * @generated from field: optional int32 port = 2;
   */
  port: number;

  /**
   * The IP protocol for this port.
   * Must be UDP, TCP, or SCTP.
   * Default is TCP.
   * +optional
   *
   * @generated from field: optional string protocol = 3;
   */
  protocol: string;

  /**
   * The application protocol for this port.
   * This field follows standard Kubernetes label syntax.
   * Un-prefixed names are reserved for IANA standard service names (as per
   * RFC-6335 and https://www.iana.org/assignments/service-names).
   * Non-standard protocols should use prefixed names such as
   * mycompany.com/my-custom-protocol.
   * +optional
   *
   * @generated from field: optional string appProtocol = 4;
   */
  appProtocol: string;
};

/**
 * EndpointPort is a tuple that describes a single port.
 * +structType=atomic
 *
 * @generated from message k8s.io.api.core.v1.EndpointPort
 */
export declare type EndpointPortValid = Message<"k8s.io.api.core.v1.EndpointPort"> & {
  /**
   * The name of this port.  This must match the 'name' field in the
   * corresponding ServicePort.
   * Must be a DNS_LABEL.
   * Optional only if one port is defined.
   * +optional
   *
   * @generated from field: optional string name = 1;
   */
  name: string;

  /**
   * The port number of the endpoint.
   *
   * @generated from field: optional int32 port = 2;
   */
  port: number;

  /**
   * The IP protocol for this port.
   * Must be UDP, TCP, or SCTP.
   * Default is TCP.
   * +optional
   *
   * @generated from field: optional string protocol = 3;
   */
  protocol: string;

  /**
   * The application protocol for this port.
   * This field follows standard Kubernetes label syntax.
   * Un-prefixed names are reserved for IANA standard service names (as per
   * RFC-6335 and https://www.iana.org/assignments/service-names).
   * Non-standard protocols should use prefixed names such as
   * mycompany.com/my-custom-protocol.
   * +optional
   *
   * @generated from field: optional string appProtocol = 4;
   */
  appProtocol: string;
};

/**
 * Describes the message k8s.io.api.core.v1.EndpointPort.
 * Use `create(EndpointPortSchema)` to create a new message.
 */
export declare const EndpointPortSchema: GenMessage<EndpointPort, {validType: EndpointPortValid}>;

/**
 * EndpointSubset is a group of addresses with a common set of ports. The
 * expanded set of endpoints is the Cartesian product of Addresses x Ports.
 * For example, given:
 *   {
 *     Addresses: [{"ip": "10.10.1.1"}, {"ip": "10.10.2.2"}],
 *     Ports:     [{"name": "a", "port": 8675}, {"name": "b", "port": 309}]
 *   }
 * The resulting set of endpoints can be viewed as:
 *     a: [ 10.10.1.1:8675, 10.10.2.2:8675 ],
 *     b: [ 10.10.1.1:309, 10.10.2.2:309 ]
 *
 * @generated from message k8s.io.api.core.v1.EndpointSubset
 */
export declare type EndpointSubset = Message<"k8s.io.api.core.v1.EndpointSubset"> & {
  /**
   * IP addresses which offer the related ports that are marked as ready. These endpoints
   * should be considered safe for load balancers and clients to utilize.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.EndpointAddress addresses = 1;
   */
  addresses: EndpointAddress[];

  /**
   * IP addresses which offer the related ports but are not currently marked as ready
   * because they have not yet finished starting, have recently failed a readiness check,
   * or have recently failed a liveness check.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.EndpointAddress notReadyAddresses = 2;
   */
  notReadyAddresses: EndpointAddress[];

  /**
   * Port numbers available on the related IP addresses.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.EndpointPort ports = 3;
   */
  ports: EndpointPort[];
};

/**
 * EndpointSubset is a group of addresses with a common set of ports. The
 * expanded set of endpoints is the Cartesian product of Addresses x Ports.
 * For example, given:
 *   {
 *     Addresses: [{"ip": "10.10.1.1"}, {"ip": "10.10.2.2"}],
 *     Ports:     [{"name": "a", "port": 8675}, {"name": "b", "port": 309}]
 *   }
 * The resulting set of endpoints can be viewed as:
 *     a: [ 10.10.1.1:8675, 10.10.2.2:8675 ],
 *     b: [ 10.10.1.1:309, 10.10.2.2:309 ]
 *
 * @generated from message k8s.io.api.core.v1.EndpointSubset
 */
export declare type EndpointSubsetValid = Message<"k8s.io.api.core.v1.EndpointSubset"> & {
  /**
   * IP addresses which offer the related ports that are marked as ready. These endpoints
   * should be considered safe for load balancers and clients to utilize.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.EndpointAddress addresses = 1;
   */
  addresses: EndpointAddressValid[];

  /**
   * IP addresses which offer the related ports but are not currently marked as ready
   * because they have not yet finished starting, have recently failed a readiness check,
   * or have recently failed a liveness check.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.EndpointAddress notReadyAddresses = 2;
   */
  notReadyAddresses: EndpointAddressValid[];

  /**
   * Port numbers available on the related IP addresses.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.EndpointPort ports = 3;
   */
  ports: EndpointPortValid[];
};

/**
 * Describes the message k8s.io.api.core.v1.EndpointSubset.
 * Use `create(EndpointSubsetSchema)` to create a new message.
 */
export declare const EndpointSubsetSchema: GenMessage<EndpointSubset, {validType: EndpointSubsetValid}>;

/**
 * Endpoints is a collection of endpoints that implement the actual service. Example:
 *   Name: "mysvc",
 *   Subsets: [
 *     {
 *       Addresses: [{"ip": "10.10.1.1"}, {"ip": "10.10.2.2"}],
 *       Ports: [{"name": "a", "port": 8675}, {"name": "b", "port": 309}]
 *     },
 *     {
 *       Addresses: [{"ip": "10.10.3.3"}],
 *       Ports: [{"name": "a", "port": 93}, {"name": "b", "port": 76}]
 *     },
 *  ]
 *
 * @generated from message k8s.io.api.core.v1.Endpoints
 */
export declare type Endpoints = Message<"k8s.io.api.core.v1.Endpoints"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMeta;

  /**
   * The set of all endpoints is the union of all subsets. Addresses are placed into
   * subsets according to the IPs they share. A single address with multiple ports,
   * some of which are ready and some of which are not (because they come from
   * different containers) will result in the address being displayed in different
   * subsets for the different ports. No address will appear in both Addresses and
   * NotReadyAddresses in the same subset.
   * Sets of addresses and ports that comprise a service.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.EndpointSubset subsets = 2;
   */
  subsets: EndpointSubset[];
};

/**
 * Endpoints is a collection of endpoints that implement the actual service. Example:
 *   Name: "mysvc",
 *   Subsets: [
 *     {
 *       Addresses: [{"ip": "10.10.1.1"}, {"ip": "10.10.2.2"}],
 *       Ports: [{"name": "a", "port": 8675}, {"name": "b", "port": 309}]
 *     },
 *     {
 *       Addresses: [{"ip": "10.10.3.3"}],
 *       Ports: [{"name": "a", "port": 93}, {"name": "b", "port": 76}]
 *     },
 *  ]
 *
 * @generated from message k8s.io.api.core.v1.Endpoints
 */
export declare type EndpointsValid = Message<"k8s.io.api.core.v1.Endpoints"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMetaValid;

  /**
   * The set of all endpoints is the union of all subsets. Addresses are placed into
   * subsets according to the IPs they share. A single address with multiple ports,
   * some of which are ready and some of which are not (because they come from
   * different containers) will result in the address being displayed in different
   * subsets for the different ports. No address will appear in both Addresses and
   * NotReadyAddresses in the same subset.
   * Sets of addresses and ports that comprise a service.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.EndpointSubset subsets = 2;
   */
  subsets: EndpointSubsetValid[];
};

/**
 * Describes the message k8s.io.api.core.v1.Endpoints.
 * Use `create(EndpointsSchema)` to create a new message.
 */
export declare const EndpointsSchema: GenMessage<Endpoints, {validType: EndpointsValid}>;

/**
 * EndpointsList is a list of endpoints.
 *
 * @generated from message k8s.io.api.core.v1.EndpointsList
 */
export declare type EndpointsList = Message<"k8s.io.api.core.v1.EndpointsList"> & {
  /**
   * Standard list metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMeta;

  /**
   * List of endpoints.
   *
   * @generated from field: repeated k8s.io.api.core.v1.Endpoints items = 2;
   */
  items: Endpoints[];
};

/**
 * EndpointsList is a list of endpoints.
 *
 * @generated from message k8s.io.api.core.v1.EndpointsList
 */
export declare type EndpointsListValid = Message<"k8s.io.api.core.v1.EndpointsList"> & {
  /**
   * Standard list metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMetaValid;

  /**
   * List of endpoints.
   *
   * @generated from field: repeated k8s.io.api.core.v1.Endpoints items = 2;
   */
  items: EndpointsValid[];
};

/**
 * Describes the message k8s.io.api.core.v1.EndpointsList.
 * Use `create(EndpointsListSchema)` to create a new message.
 */
export declare const EndpointsListSchema: GenMessage<EndpointsList, {validType: EndpointsListValid}>;

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @generated from message k8s.io.api.core.v1.EnvFromSource
 */
export declare type EnvFromSource = Message<"k8s.io.api.core.v1.EnvFromSource"> & {
  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   * +optional
   *
   * @generated from field: optional string prefix = 1;
   */
  prefix: string;

  /**
   * The ConfigMap to select from
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ConfigMapEnvSource configMapRef = 2;
   */
  configMapRef?: ConfigMapEnvSource;

  /**
   * The Secret to select from
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.SecretEnvSource secretRef = 3;
   */
  secretRef?: SecretEnvSource;
};

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @generated from message k8s.io.api.core.v1.EnvFromSource
 */
export declare type EnvFromSourceValid = Message<"k8s.io.api.core.v1.EnvFromSource"> & {
  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   * +optional
   *
   * @generated from field: optional string prefix = 1;
   */
  prefix: string;

  /**
   * The ConfigMap to select from
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ConfigMapEnvSource configMapRef = 2;
   */
  configMapRef?: ConfigMapEnvSourceValid;

  /**
   * The Secret to select from
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.SecretEnvSource secretRef = 3;
   */
  secretRef?: SecretEnvSourceValid;
};

/**
 * Describes the message k8s.io.api.core.v1.EnvFromSource.
 * Use `create(EnvFromSourceSchema)` to create a new message.
 */
export declare const EnvFromSourceSchema: GenMessage<EnvFromSource, {validType: EnvFromSourceValid}>;

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @generated from message k8s.io.api.core.v1.EnvVar
 */
export declare type EnvVar = Message<"k8s.io.api.core.v1.EnvVar"> & {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @generated from field: optional string name = 1;
   */
  name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   * +optional
   *
   * @generated from field: optional string value = 2;
   */
  value: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.EnvVarSource valueFrom = 3;
   */
  valueFrom?: EnvVarSource;
};

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @generated from message k8s.io.api.core.v1.EnvVar
 */
export declare type EnvVarValid = Message<"k8s.io.api.core.v1.EnvVar"> & {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @generated from field: optional string name = 1;
   */
  name: string;

  /**
   * Variable references $(VAR_NAME) are expanded
   * using the previously defined environment variables in the container and
   * any service environment variables. If a variable cannot be resolved,
   * the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
   * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
   * Escaped references will never be expanded, regardless of whether the variable
   * exists or not.
   * Defaults to "".
   * +optional
   *
   * @generated from field: optional string value = 2;
   */
  value: string;

  /**
   * Source for the environment variable's value. Cannot be used if value is not empty.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.EnvVarSource valueFrom = 3;
   */
  valueFrom?: EnvVarSourceValid;
};

/**
 * Describes the message k8s.io.api.core.v1.EnvVar.
 * Use `create(EnvVarSchema)` to create a new message.
 */
export declare const EnvVarSchema: GenMessage<EnvVar, {validType: EnvVarValid}>;

/**
 * EnvVarSource represents a source for the value of an EnvVar.
 *
 * @generated from message k8s.io.api.core.v1.EnvVarSource
 */
export declare type EnvVarSource = Message<"k8s.io.api.core.v1.EnvVarSource"> & {
  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ObjectFieldSelector fieldRef = 1;
   */
  fieldRef?: ObjectFieldSelector;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ResourceFieldSelector resourceFieldRef = 2;
   */
  resourceFieldRef?: ResourceFieldSelector;

  /**
   * Selects a key of a ConfigMap.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ConfigMapKeySelector configMapKeyRef = 3;
   */
  configMapKeyRef?: ConfigMapKeySelector;

  /**
   * Selects a key of a secret in the pod's namespace
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.SecretKeySelector secretKeyRef = 4;
   */
  secretKeyRef?: SecretKeySelector;
};

/**
 * EnvVarSource represents a source for the value of an EnvVar.
 *
 * @generated from message k8s.io.api.core.v1.EnvVarSource
 */
export declare type EnvVarSourceValid = Message<"k8s.io.api.core.v1.EnvVarSource"> & {
  /**
   * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
   * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ObjectFieldSelector fieldRef = 1;
   */
  fieldRef?: ObjectFieldSelectorValid;

  /**
   * Selects a resource of the container: only resources limits and requests
   * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ResourceFieldSelector resourceFieldRef = 2;
   */
  resourceFieldRef?: ResourceFieldSelectorValid;

  /**
   * Selects a key of a ConfigMap.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ConfigMapKeySelector configMapKeyRef = 3;
   */
  configMapKeyRef?: ConfigMapKeySelectorValid;

  /**
   * Selects a key of a secret in the pod's namespace
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.SecretKeySelector secretKeyRef = 4;
   */
  secretKeyRef?: SecretKeySelectorValid;
};

/**
 * Describes the message k8s.io.api.core.v1.EnvVarSource.
 * Use `create(EnvVarSourceSchema)` to create a new message.
 */
export declare const EnvVarSourceSchema: GenMessage<EnvVarSource, {validType: EnvVarSourceValid}>;

/**
 * An EphemeralContainer is a temporary container that you may add to an existing Pod for
 * user-initiated activities such as debugging. Ephemeral containers have no resource or
 * scheduling guarantees, and they will not be restarted when they exit or when a Pod is
 * removed or restarted. The kubelet may evict a Pod if an ephemeral container causes the
 * Pod to exceed its resource allocation.
 *
 * To add an ephemeral container, use the ephemeralcontainers subresource of an existing
 * Pod. Ephemeral containers may not be removed or restarted.
 *
 * This is a beta feature available on clusters that haven't disabled the EphemeralContainers feature gate.
 *
 * @generated from message k8s.io.api.core.v1.EphemeralContainer
 */
export declare type EphemeralContainer = Message<"k8s.io.api.core.v1.EphemeralContainer"> & {
  /**
   * Ephemeral containers have all of the fields of Container, plus additional fields
   * specific to ephemeral containers. Fields in common with Container are in the
   * following inlined struct so than an EphemeralContainer may easily be converted
   * to a Container.
   *
   * @generated from field: optional k8s.io.api.core.v1.EphemeralContainerCommon ephemeralContainerCommon = 1;
   */
  ephemeralContainerCommon?: EphemeralContainerCommon;

  /**
   * If set, the name of the container from PodSpec that this ephemeral container targets.
   * The ephemeral container will be run in the namespaces (IPC, PID, etc) of this container.
   * If not set then the ephemeral container uses the namespaces configured in the Pod spec.
   *
   * The container runtime must implement support for this feature. If the runtime does not
   * support namespace targeting then the result of setting this field is undefined.
   * +optional
   *
   * @generated from field: optional string targetContainerName = 2;
   */
  targetContainerName: string;
};

/**
 * An EphemeralContainer is a temporary container that you may add to an existing Pod for
 * user-initiated activities such as debugging. Ephemeral containers have no resource or
 * scheduling guarantees, and they will not be restarted when they exit or when a Pod is
 * removed or restarted. The kubelet may evict a Pod if an ephemeral container causes the
 * Pod to exceed its resource allocation.
 *
 * To add an ephemeral container, use the ephemeralcontainers subresource of an existing
 * Pod. Ephemeral containers may not be removed or restarted.
 *
 * This is a beta feature available on clusters that haven't disabled the EphemeralContainers feature gate.
 *
 * @generated from message k8s.io.api.core.v1.EphemeralContainer
 */
export declare type EphemeralContainerValid = Message<"k8s.io.api.core.v1.EphemeralContainer"> & {
  /**
   * Ephemeral containers have all of the fields of Container, plus additional fields
   * specific to ephemeral containers. Fields in common with Container are in the
   * following inlined struct so than an EphemeralContainer may easily be converted
   * to a Container.
   *
   * @generated from field: optional k8s.io.api.core.v1.EphemeralContainerCommon ephemeralContainerCommon = 1;
   */
  ephemeralContainerCommon?: EphemeralContainerCommonValid;

  /**
   * If set, the name of the container from PodSpec that this ephemeral container targets.
   * The ephemeral container will be run in the namespaces (IPC, PID, etc) of this container.
   * If not set then the ephemeral container uses the namespaces configured in the Pod spec.
   *
   * The container runtime must implement support for this feature. If the runtime does not
   * support namespace targeting then the result of setting this field is undefined.
   * +optional
   *
   * @generated from field: optional string targetContainerName = 2;
   */
  targetContainerName: string;
};

/**
 * Describes the message k8s.io.api.core.v1.EphemeralContainer.
 * Use `create(EphemeralContainerSchema)` to create a new message.
 */
export declare const EphemeralContainerSchema: GenMessage<EphemeralContainer, {validType: EphemeralContainerValid}>;

/**
 * EphemeralContainerCommon is a copy of all fields in Container to be inlined in
 * EphemeralContainer. This separate type allows easy conversion from EphemeralContainer
 * to Container and allows separate documentation for the fields of EphemeralContainer.
 * When a new field is added to Container it must be added here as well.
 *
 * @generated from message k8s.io.api.core.v1.EphemeralContainerCommon
 */
export declare type EphemeralContainerCommon = Message<"k8s.io.api.core.v1.EphemeralContainerCommon"> & {
  /**
   * Name of the ephemeral container specified as a DNS_LABEL.
   * This name must be unique among all containers, init containers and ephemeral containers.
   *
   * @generated from field: optional string name = 1;
   */
  name: string;

  /**
   * Container image name.
   * More info: https://kubernetes.io/docs/concepts/containers/images
   *
   * @generated from field: optional string image = 2;
   */
  image: string;

  /**
   * Entrypoint array. Not executed within a shell.
   * The image's ENTRYPOINT is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   * +optional
   *
   * @generated from field: repeated string command = 3;
   */
  command: string[];

  /**
   * Arguments to the entrypoint.
   * The image's CMD is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   * +optional
   *
   * @generated from field: repeated string args = 4;
   */
  args: string[];

  /**
   * Container's working directory.
   * If not specified, the container runtime's default will be used, which
   * might be configured in the container image.
   * Cannot be updated.
   * +optional
   *
   * @generated from field: optional string workingDir = 5;
   */
  workingDir: string;

  /**
   * Ports are not allowed for ephemeral containers.
   * +optional
   * +patchMergeKey=containerPort
   * +patchStrategy=merge
   * +listType=map
   * +listMapKey=containerPort
   * +listMapKey=protocol
   *
   * @generated from field: repeated k8s.io.api.core.v1.ContainerPort ports = 6;
   */
  ports: ContainerPort[];

  /**
   * List of sources to populate environment variables in the container.
   * The keys defined within a source must be a C_IDENTIFIER. All invalid keys
   * will be reported as an event when the container is starting. When a key exists in multiple
   * sources, the value associated with the last source will take precedence.
   * Values defined by an Env with a duplicate key will take precedence.
   * Cannot be updated.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.EnvFromSource envFrom = 19;
   */
  envFrom: EnvFromSource[];

  /**
   * List of environment variables to set in the container.
   * Cannot be updated.
   * +optional
   * +patchMergeKey=name
   * +patchStrategy=merge
   *
   * @generated from field: repeated k8s.io.api.core.v1.EnvVar env = 7;
   */
  env: EnvVar[];

  /**
   * Resources are not allowed for ephemeral containers. Ephemeral containers use spare resources
   * already allocated to the pod.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ResourceRequirements resources = 8;
   */
  resources?: ResourceRequirements;

  /**
   * Pod volumes to mount into the container's filesystem. Subpath mounts are not allowed for ephemeral containers.
   * Cannot be updated.
   * +optional
   * +patchMergeKey=mountPath
   * +patchStrategy=merge
   *
   * @generated from field: repeated k8s.io.api.core.v1.VolumeMount volumeMounts = 9;
   */
  volumeMounts: VolumeMount[];

  /**
   * volumeDevices is the list of block devices to be used by the container.
   * +patchMergeKey=devicePath
   * +patchStrategy=merge
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.VolumeDevice volumeDevices = 21;
   */
  volumeDevices: VolumeDevice[];

  /**
   * Probes are not allowed for ephemeral containers.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.Probe livenessProbe = 10;
   */
  livenessProbe?: Probe;

  /**
   * Probes are not allowed for ephemeral containers.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.Probe readinessProbe = 11;
   */
  readinessProbe?: Probe;

  /**
   * Probes are not allowed for ephemeral containers.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.Probe startupProbe = 22;
   */
  startupProbe?: Probe;

  /**
   * Lifecycle is not allowed for ephemeral containers.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.Lifecycle lifecycle = 12;
   */
  lifecycle?: Lifecycle;

  /**
   * Optional: Path at which the file to which the container's termination message
   * will be written is mounted into the container's filesystem.
   * Message written is intended to be brief final status, such as an assertion failure message.
   * Will be truncated by the node if greater than 4096 bytes. The total message length across
   * all containers will be limited to 12kb.
   * Defaults to /dev/termination-log.
   * Cannot be updated.
   * +optional
   *
   * @generated from field: optional string terminationMessagePath = 13;
   */
  terminationMessagePath: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of
   * terminationMessagePath to populate the container status message on both success and failure.
   * FallbackToLogsOnError will use the last chunk of container log output if the termination
   * message file is empty and the container exited with an error.
   * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
   * Defaults to File.
   * Cannot be updated.
   * +optional
   *
   * @generated from field: optional string terminationMessagePolicy = 20;
   */
  terminationMessagePolicy: string;

  /**
   * Image pull policy.
   * One of Always, Never, IfNotPresent.
   * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   * +optional
   *
   * @generated from field: optional string imagePullPolicy = 14;
   */
  imagePullPolicy: string;

  /**
   * Optional: SecurityContext defines the security options the ephemeral container should be run with.
   * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.SecurityContext securityContext = 15;
   */
  securityContext?: SecurityContext;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this
   * is not set, reads from stdin in the container will always result in EOF.
   * Default is false.
   * +optional
   *
   * @generated from field: optional bool stdin = 16;
   */
  stdin: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by
   * a single attach. When stdin is true the stdin stream will remain open across multiple attach
   * sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
   * first client attaches to stdin, and then remains open and accepts data until the client disconnects,
   * at which time stdin is closed and remains closed until the container is restarted. If this
   * flag is false, a container processes that reads from stdin will never receive an EOF.
   * Default is false
   * +optional
   *
   * @generated from field: optional bool stdinOnce = 17;
   */
  stdinOnce: boolean;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
   * Default is false.
   * +optional
   *
   * @generated from field: optional bool tty = 18;
   */
  tty: boolean;
};

/**
 * EphemeralContainerCommon is a copy of all fields in Container to be inlined in
 * EphemeralContainer. This separate type allows easy conversion from EphemeralContainer
 * to Container and allows separate documentation for the fields of EphemeralContainer.
 * When a new field is added to Container it must be added here as well.
 *
 * @generated from message k8s.io.api.core.v1.EphemeralContainerCommon
 */
export declare type EphemeralContainerCommonValid = Message<"k8s.io.api.core.v1.EphemeralContainerCommon"> & {
  /**
   * Name of the ephemeral container specified as a DNS_LABEL.
   * This name must be unique among all containers, init containers and ephemeral containers.
   *
   * @generated from field: optional string name = 1;
   */
  name: string;

  /**
   * Container image name.
   * More info: https://kubernetes.io/docs/concepts/containers/images
   *
   * @generated from field: optional string image = 2;
   */
  image: string;

  /**
   * Entrypoint array. Not executed within a shell.
   * The image's ENTRYPOINT is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   * +optional
   *
   * @generated from field: repeated string command = 3;
   */
  command: string[];

  /**
   * Arguments to the entrypoint.
   * The image's CMD is used if this is not provided.
   * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
   * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
   * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
   * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
   * of whether the variable exists or not. Cannot be updated.
   * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   * +optional
   *
   * @generated from field: repeated string args = 4;
   */
  args: string[];

  /**
   * Container's working directory.
   * If not specified, the container runtime's default will be used, which
   * might be configured in the container image.
   * Cannot be updated.
   * +optional
   *
   * @generated from field: optional string workingDir = 5;
   */
  workingDir: string;

  /**
   * Ports are not allowed for ephemeral containers.
   * +optional
   * +patchMergeKey=containerPort
   * +patchStrategy=merge
   * +listType=map
   * +listMapKey=containerPort
   * +listMapKey=protocol
   *
   * @generated from field: repeated k8s.io.api.core.v1.ContainerPort ports = 6;
   */
  ports: ContainerPortValid[];

  /**
   * List of sources to populate environment variables in the container.
   * The keys defined within a source must be a C_IDENTIFIER. All invalid keys
   * will be reported as an event when the container is starting. When a key exists in multiple
   * sources, the value associated with the last source will take precedence.
   * Values defined by an Env with a duplicate key will take precedence.
   * Cannot be updated.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.EnvFromSource envFrom = 19;
   */
  envFrom: EnvFromSourceValid[];

  /**
   * List of environment variables to set in the container.
   * Cannot be updated.
   * +optional
   * +patchMergeKey=name
   * +patchStrategy=merge
   *
   * @generated from field: repeated k8s.io.api.core.v1.EnvVar env = 7;
   */
  env: EnvVarValid[];

  /**
   * Resources are not allowed for ephemeral containers. Ephemeral containers use spare resources
   * already allocated to the pod.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ResourceRequirements resources = 8;
   */
  resources?: ResourceRequirementsValid;

  /**
   * Pod volumes to mount into the container's filesystem. Subpath mounts are not allowed for ephemeral containers.
   * Cannot be updated.
   * +optional
   * +patchMergeKey=mountPath
   * +patchStrategy=merge
   *
   * @generated from field: repeated k8s.io.api.core.v1.VolumeMount volumeMounts = 9;
   */
  volumeMounts: VolumeMountValid[];

  /**
   * volumeDevices is the list of block devices to be used by the container.
   * +patchMergeKey=devicePath
   * +patchStrategy=merge
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.VolumeDevice volumeDevices = 21;
   */
  volumeDevices: VolumeDeviceValid[];

  /**
   * Probes are not allowed for ephemeral containers.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.Probe livenessProbe = 10;
   */
  livenessProbe?: ProbeValid;

  /**
   * Probes are not allowed for ephemeral containers.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.Probe readinessProbe = 11;
   */
  readinessProbe?: ProbeValid;

  /**
   * Probes are not allowed for ephemeral containers.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.Probe startupProbe = 22;
   */
  startupProbe?: ProbeValid;

  /**
   * Lifecycle is not allowed for ephemeral containers.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.Lifecycle lifecycle = 12;
   */
  lifecycle?: LifecycleValid;

  /**
   * Optional: Path at which the file to which the container's termination message
   * will be written is mounted into the container's filesystem.
   * Message written is intended to be brief final status, such as an assertion failure message.
   * Will be truncated by the node if greater than 4096 bytes. The total message length across
   * all containers will be limited to 12kb.
   * Defaults to /dev/termination-log.
   * Cannot be updated.
   * +optional
   *
   * @generated from field: optional string terminationMessagePath = 13;
   */
  terminationMessagePath: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of
   * terminationMessagePath to populate the container status message on both success and failure.
   * FallbackToLogsOnError will use the last chunk of container log output if the termination
   * message file is empty and the container exited with an error.
   * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
   * Defaults to File.
   * Cannot be updated.
   * +optional
   *
   * @generated from field: optional string terminationMessagePolicy = 20;
   */
  terminationMessagePolicy: string;

  /**
   * Image pull policy.
   * One of Always, Never, IfNotPresent.
   * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   * +optional
   *
   * @generated from field: optional string imagePullPolicy = 14;
   */
  imagePullPolicy: string;

  /**
   * Optional: SecurityContext defines the security options the ephemeral container should be run with.
   * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.SecurityContext securityContext = 15;
   */
  securityContext?: SecurityContextValid;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this
   * is not set, reads from stdin in the container will always result in EOF.
   * Default is false.
   * +optional
   *
   * @generated from field: optional bool stdin = 16;
   */
  stdin: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by
   * a single attach. When stdin is true the stdin stream will remain open across multiple attach
   * sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
   * first client attaches to stdin, and then remains open and accepts data until the client disconnects,
   * at which time stdin is closed and remains closed until the container is restarted. If this
   * flag is false, a container processes that reads from stdin will never receive an EOF.
   * Default is false
   * +optional
   *
   * @generated from field: optional bool stdinOnce = 17;
   */
  stdinOnce: boolean;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
   * Default is false.
   * +optional
   *
   * @generated from field: optional bool tty = 18;
   */
  tty: boolean;
};

/**
 * Describes the message k8s.io.api.core.v1.EphemeralContainerCommon.
 * Use `create(EphemeralContainerCommonSchema)` to create a new message.
 */
export declare const EphemeralContainerCommonSchema: GenMessage<EphemeralContainerCommon, {validType: EphemeralContainerCommonValid}>;

/**
 * Represents an ephemeral volume that is handled by a normal storage driver.
 *
 * @generated from message k8s.io.api.core.v1.EphemeralVolumeSource
 */
export declare type EphemeralVolumeSource = Message<"k8s.io.api.core.v1.EphemeralVolumeSource"> & {
  /**
   * Will be used to create a stand-alone PVC to provision the volume.
   * The pod in which this EphemeralVolumeSource is embedded will be the
   * owner of the PVC, i.e. the PVC will be deleted together with the
   * pod.  The name of the PVC will be `<pod name>-<volume name>` where
   * `<volume name>` is the name from the `PodSpec.Volumes` array
   * entry. Pod validation will reject the pod if the concatenated name
   * is not valid for a PVC (for example, too long).
   *
   * An existing PVC with that name that is not owned by the pod
   * will *not* be used for the pod to avoid using an unrelated
   * volume by mistake. Starting the pod is then blocked until
   * the unrelated PVC is removed. If such a pre-created PVC is
   * meant to be used by the pod, the PVC has to updated with an
   * owner reference to the pod once the pod exists. Normally
   * this should not be necessary, but it may be useful when
   * manually reconstructing a broken cluster.
   *
   * This field is read-only and no changes will be made by Kubernetes
   * to the PVC after it has been created.
   *
   * Required, must not be nil.
   *
   * @generated from field: optional k8s.io.api.core.v1.PersistentVolumeClaimTemplate volumeClaimTemplate = 1;
   */
  volumeClaimTemplate?: PersistentVolumeClaimTemplate;
};

/**
 * Represents an ephemeral volume that is handled by a normal storage driver.
 *
 * @generated from message k8s.io.api.core.v1.EphemeralVolumeSource
 */
export declare type EphemeralVolumeSourceValid = Message<"k8s.io.api.core.v1.EphemeralVolumeSource"> & {
  /**
   * Will be used to create a stand-alone PVC to provision the volume.
   * The pod in which this EphemeralVolumeSource is embedded will be the
   * owner of the PVC, i.e. the PVC will be deleted together with the
   * pod.  The name of the PVC will be `<pod name>-<volume name>` where
   * `<volume name>` is the name from the `PodSpec.Volumes` array
   * entry. Pod validation will reject the pod if the concatenated name
   * is not valid for a PVC (for example, too long).
   *
   * An existing PVC with that name that is not owned by the pod
   * will *not* be used for the pod to avoid using an unrelated
   * volume by mistake. Starting the pod is then blocked until
   * the unrelated PVC is removed. If such a pre-created PVC is
   * meant to be used by the pod, the PVC has to updated with an
   * owner reference to the pod once the pod exists. Normally
   * this should not be necessary, but it may be useful when
   * manually reconstructing a broken cluster.
   *
   * This field is read-only and no changes will be made by Kubernetes
   * to the PVC after it has been created.
   *
   * Required, must not be nil.
   *
   * @generated from field: optional k8s.io.api.core.v1.PersistentVolumeClaimTemplate volumeClaimTemplate = 1;
   */
  volumeClaimTemplate?: PersistentVolumeClaimTemplateValid;
};

/**
 * Describes the message k8s.io.api.core.v1.EphemeralVolumeSource.
 * Use `create(EphemeralVolumeSourceSchema)` to create a new message.
 */
export declare const EphemeralVolumeSourceSchema: GenMessage<EphemeralVolumeSource, {validType: EphemeralVolumeSourceValid}>;

/**
 * Event is a report of an event somewhere in the cluster.  Events
 * have a limited retention time and triggers and messages may evolve
 * with time.  Event consumers should not rely on the timing of an event
 * with a given Reason reflecting a consistent underlying trigger, or the
 * continued existence of events with that Reason.  Events should be
 * treated as informative, best-effort, supplemental data.
 *
 * @generated from message k8s.io.api.core.v1.Event
 */
export declare type Event = Message<"k8s.io.api.core.v1.Event"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMeta;

  /**
   * The object that this event is about.
   *
   * @generated from field: optional k8s.io.api.core.v1.ObjectReference involvedObject = 2;
   */
  involvedObject?: ObjectReference;

  /**
   * This should be a short, machine understandable string that gives the reason
   * for the transition into the object's current status.
   * TODO: provide exact specification for format.
   * +optional
   *
   * @generated from field: optional string reason = 3;
   */
  reason: string;

  /**
   * A human-readable description of the status of this operation.
   * TODO: decide on maximum length.
   * +optional
   *
   * @generated from field: optional string message = 4;
   */
  message: string;

  /**
   * The component reporting this event. Should be a short machine understandable string.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.EventSource source = 5;
   */
  source?: EventSource;

  /**
   * The time at which the event was first recorded. (Time of server receipt is in TypeMeta.)
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time firstTimestamp = 6;
   */
  firstTimestamp?: Time;

  /**
   * The time at which the most recent occurrence of this event was recorded.
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTimestamp = 7;
   */
  lastTimestamp?: Time;

  /**
   * The number of times this event has occurred.
   * +optional
   *
   * @generated from field: optional int32 count = 8;
   */
  count: number;

  /**
   * Type of this event (Normal, Warning), new types could be added in the future
   * +optional
   *
   * @generated from field: optional string type = 9;
   */
  type: string;

  /**
   * Time when this Event was first observed.
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime eventTime = 10;
   */
  eventTime?: MicroTime;

  /**
   * Data about the Event series this event represents or nil if it's a singleton Event.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.EventSeries series = 11;
   */
  series?: EventSeries;

  /**
   * What action was taken/failed regarding to the Regarding object.
   * +optional
   *
   * @generated from field: optional string action = 12;
   */
  action: string;

  /**
   * Optional secondary object for more complex actions.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ObjectReference related = 13;
   */
  related?: ObjectReference;

  /**
   * Name of the controller that emitted this Event, e.g. `kubernetes.io/kubelet`.
   * +optional
   *
   * @generated from field: optional string reportingComponent = 14;
   */
  reportingComponent: string;

  /**
   * ID of the controller instance, e.g. `kubelet-xyzf`.
   * +optional
   *
   * @generated from field: optional string reportingInstance = 15;
   */
  reportingInstance: string;
};

/**
 * Event is a report of an event somewhere in the cluster.  Events
 * have a limited retention time and triggers and messages may evolve
 * with time.  Event consumers should not rely on the timing of an event
 * with a given Reason reflecting a consistent underlying trigger, or the
 * continued existence of events with that Reason.  Events should be
 * treated as informative, best-effort, supplemental data.
 *
 * @generated from message k8s.io.api.core.v1.Event
 */
export declare type EventValid = Message<"k8s.io.api.core.v1.Event"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMetaValid;

  /**
   * The object that this event is about.
   *
   * @generated from field: optional k8s.io.api.core.v1.ObjectReference involvedObject = 2;
   */
  involvedObject?: ObjectReferenceValid;

  /**
   * This should be a short, machine understandable string that gives the reason
   * for the transition into the object's current status.
   * TODO: provide exact specification for format.
   * +optional
   *
   * @generated from field: optional string reason = 3;
   */
  reason: string;

  /**
   * A human-readable description of the status of this operation.
   * TODO: decide on maximum length.
   * +optional
   *
   * @generated from field: optional string message = 4;
   */
  message: string;

  /**
   * The component reporting this event. Should be a short machine understandable string.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.EventSource source = 5;
   */
  source?: EventSourceValid;

  /**
   * The time at which the event was first recorded. (Time of server receipt is in TypeMeta.)
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time firstTimestamp = 6;
   */
  firstTimestamp?: TimeValid;

  /**
   * The time at which the most recent occurrence of this event was recorded.
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTimestamp = 7;
   */
  lastTimestamp?: TimeValid;

  /**
   * The number of times this event has occurred.
   * +optional
   *
   * @generated from field: optional int32 count = 8;
   */
  count: number;

  /**
   * Type of this event (Normal, Warning), new types could be added in the future
   * +optional
   *
   * @generated from field: optional string type = 9;
   */
  type: string;

  /**
   * Time when this Event was first observed.
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime eventTime = 10;
   */
  eventTime?: MicroTimeValid;

  /**
   * Data about the Event series this event represents or nil if it's a singleton Event.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.EventSeries series = 11;
   */
  series?: EventSeriesValid;

  /**
   * What action was taken/failed regarding to the Regarding object.
   * +optional
   *
   * @generated from field: optional string action = 12;
   */
  action: string;

  /**
   * Optional secondary object for more complex actions.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ObjectReference related = 13;
   */
  related?: ObjectReferenceValid;

  /**
   * Name of the controller that emitted this Event, e.g. `kubernetes.io/kubelet`.
   * +optional
   *
   * @generated from field: optional string reportingComponent = 14;
   */
  reportingComponent: string;

  /**
   * ID of the controller instance, e.g. `kubelet-xyzf`.
   * +optional
   *
   * @generated from field: optional string reportingInstance = 15;
   */
  reportingInstance: string;
};

/**
 * Describes the message k8s.io.api.core.v1.Event.
 * Use `create(EventSchema)` to create a new message.
 */
export declare const EventSchema: GenMessage<Event, {validType: EventValid}>;

/**
 * EventList is a list of events.
 *
 * @generated from message k8s.io.api.core.v1.EventList
 */
export declare type EventList = Message<"k8s.io.api.core.v1.EventList"> & {
  /**
   * Standard list metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMeta;

  /**
   * List of events
   *
   * @generated from field: repeated k8s.io.api.core.v1.Event items = 2;
   */
  items: Event[];
};

/**
 * EventList is a list of events.
 *
 * @generated from message k8s.io.api.core.v1.EventList
 */
export declare type EventListValid = Message<"k8s.io.api.core.v1.EventList"> & {
  /**
   * Standard list metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMetaValid;

  /**
   * List of events
   *
   * @generated from field: repeated k8s.io.api.core.v1.Event items = 2;
   */
  items: EventValid[];
};

/**
 * Describes the message k8s.io.api.core.v1.EventList.
 * Use `create(EventListSchema)` to create a new message.
 */
export declare const EventListSchema: GenMessage<EventList, {validType: EventListValid}>;

/**
 * EventSeries contain information on series of events, i.e. thing that was/is happening
 * continuously for some time.
 *
 * @generated from message k8s.io.api.core.v1.EventSeries
 */
export declare type EventSeries = Message<"k8s.io.api.core.v1.EventSeries"> & {
  /**
   * Number of occurrences in this series up to the last heartbeat time
   *
   * @generated from field: optional int32 count = 1;
   */
  count: number;

  /**
   * Time of the last occurrence observed
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime lastObservedTime = 2;
   */
  lastObservedTime?: MicroTime;
};

/**
 * EventSeries contain information on series of events, i.e. thing that was/is happening
 * continuously for some time.
 *
 * @generated from message k8s.io.api.core.v1.EventSeries
 */
export declare type EventSeriesValid = Message<"k8s.io.api.core.v1.EventSeries"> & {
  /**
   * Number of occurrences in this series up to the last heartbeat time
   *
   * @generated from field: optional int32 count = 1;
   */
  count: number;

  /**
   * Time of the last occurrence observed
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime lastObservedTime = 2;
   */
  lastObservedTime?: MicroTimeValid;
};

/**
 * Describes the message k8s.io.api.core.v1.EventSeries.
 * Use `create(EventSeriesSchema)` to create a new message.
 */
export declare const EventSeriesSchema: GenMessage<EventSeries, {validType: EventSeriesValid}>;

/**
 * EventSource contains information for an event.
 *
 * @generated from message k8s.io.api.core.v1.EventSource
 */
export declare type EventSource = Message<"k8s.io.api.core.v1.EventSource"> & {
  /**
   * Component from which the event is generated.
   * +optional
   *
   * @generated from field: optional string component = 1;
   */
  component: string;

  /**
   * Node name on which the event is generated.
   * +optional
   *
   * @generated from field: optional string host = 2;
   */
  host: string;
};

/**
 * EventSource contains information for an event.
 *
 * @generated from message k8s.io.api.core.v1.EventSource
 */
export declare type EventSourceValid = Message<"k8s.io.api.core.v1.EventSource"> & {
  /**
   * Component from which the event is generated.
   * +optional
   *
   * @generated from field: optional string component = 1;
   */
  component: string;

  /**
   * Node name on which the event is generated.
   * +optional
   *
   * @generated from field: optional string host = 2;
   */
  host: string;
};

/**
 * Describes the message k8s.io.api.core.v1.EventSource.
 * Use `create(EventSourceSchema)` to create a new message.
 */
export declare const EventSourceSchema: GenMessage<EventSource, {validType: EventSourceValid}>;

/**
 * ExecAction describes a "run in container" action.
 *
 * @generated from message k8s.io.api.core.v1.ExecAction
 */
export declare type ExecAction = Message<"k8s.io.api.core.v1.ExecAction"> & {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   * +optional
   *
   * @generated from field: repeated string command = 1;
   */
  command: string[];
};

/**
 * ExecAction describes a "run in container" action.
 *
 * @generated from message k8s.io.api.core.v1.ExecAction
 */
export declare type ExecActionValid = Message<"k8s.io.api.core.v1.ExecAction"> & {
  /**
   * Command is the command line to execute inside the container, the working directory for the
   * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
   * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
   * a shell, you need to explicitly call out to that shell.
   * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   * +optional
   *
   * @generated from field: repeated string command = 1;
   */
  command: string[];
};

/**
 * Describes the message k8s.io.api.core.v1.ExecAction.
 * Use `create(ExecActionSchema)` to create a new message.
 */
export declare const ExecActionSchema: GenMessage<ExecAction, {validType: ExecActionValid}>;

/**
 * Represents a Fibre Channel volume.
 * Fibre Channel volumes can only be mounted as read/write once.
 * Fibre Channel volumes support ownership management and SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.FCVolumeSource
 */
export declare type FCVolumeSource = Message<"k8s.io.api.core.v1.FCVolumeSource"> & {
  /**
   * targetWWNs is Optional: FC target worldwide names (WWNs)
   * +optional
   *
   * @generated from field: repeated string targetWWNs = 1;
   */
  targetWWNs: string[];

  /**
   * lun is Optional: FC target lun number
   * +optional
   *
   * @generated from field: optional int32 lun = 2;
   */
  lun: number;

  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   * +optional
   *
   * @generated from field: optional string fsType = 3;
   */
  fsType: string;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * +optional
   *
   * @generated from field: optional bool readOnly = 4;
   */
  readOnly: boolean;

  /**
   * wwids Optional: FC volume world wide identifiers (wwids)
   * Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
   * +optional
   *
   * @generated from field: repeated string wwids = 5;
   */
  wwids: string[];
};

/**
 * Represents a Fibre Channel volume.
 * Fibre Channel volumes can only be mounted as read/write once.
 * Fibre Channel volumes support ownership management and SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.FCVolumeSource
 */
export declare type FCVolumeSourceValid = Message<"k8s.io.api.core.v1.FCVolumeSource"> & {
  /**
   * targetWWNs is Optional: FC target worldwide names (WWNs)
   * +optional
   *
   * @generated from field: repeated string targetWWNs = 1;
   */
  targetWWNs: string[];

  /**
   * lun is Optional: FC target lun number
   * +optional
   *
   * @generated from field: optional int32 lun = 2;
   */
  lun: number;

  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   * +optional
   *
   * @generated from field: optional string fsType = 3;
   */
  fsType: string;

  /**
   * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * +optional
   *
   * @generated from field: optional bool readOnly = 4;
   */
  readOnly: boolean;

  /**
   * wwids Optional: FC volume world wide identifiers (wwids)
   * Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
   * +optional
   *
   * @generated from field: repeated string wwids = 5;
   */
  wwids: string[];
};

/**
 * Describes the message k8s.io.api.core.v1.FCVolumeSource.
 * Use `create(FCVolumeSourceSchema)` to create a new message.
 */
export declare const FCVolumeSourceSchema: GenMessage<FCVolumeSource, {validType: FCVolumeSourceValid}>;

/**
 * FlexPersistentVolumeSource represents a generic persistent volume resource that is
 * provisioned/attached using an exec based plugin.
 *
 * @generated from message k8s.io.api.core.v1.FlexPersistentVolumeSource
 */
export declare type FlexPersistentVolumeSource = Message<"k8s.io.api.core.v1.FlexPersistentVolumeSource"> & {
  /**
   * driver is the name of the driver to use for this volume.
   *
   * @generated from field: optional string driver = 1;
   */
  driver: string;

  /**
   * fsType is the Filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   * +optional
   *
   * @generated from field: optional string fsType = 2;
   */
  fsType: string;

  /**
   * secretRef is Optional: SecretRef is reference to the secret object containing
   * sensitive information to pass to the plugin scripts. This may be
   * empty if no secret object is specified. If the secret object
   * contains more than one secret, all secrets are passed to the plugin
   * scripts.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.SecretReference secretRef = 3;
   */
  secretRef?: SecretReference;

  /**
   * readOnly is Optional: defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * +optional
   *
   * @generated from field: optional bool readOnly = 4;
   */
  readOnly: boolean;

  /**
   * options is Optional: this field holds extra command options if any.
   * +optional
   *
   * @generated from field: map<string, string> options = 5;
   */
  options: { [key: string]: string };
};

/**
 * FlexPersistentVolumeSource represents a generic persistent volume resource that is
 * provisioned/attached using an exec based plugin.
 *
 * @generated from message k8s.io.api.core.v1.FlexPersistentVolumeSource
 */
export declare type FlexPersistentVolumeSourceValid = Message<"k8s.io.api.core.v1.FlexPersistentVolumeSource"> & {
  /**
   * driver is the name of the driver to use for this volume.
   *
   * @generated from field: optional string driver = 1;
   */
  driver: string;

  /**
   * fsType is the Filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   * +optional
   *
   * @generated from field: optional string fsType = 2;
   */
  fsType: string;

  /**
   * secretRef is Optional: SecretRef is reference to the secret object containing
   * sensitive information to pass to the plugin scripts. This may be
   * empty if no secret object is specified. If the secret object
   * contains more than one secret, all secrets are passed to the plugin
   * scripts.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.SecretReference secretRef = 3;
   */
  secretRef?: SecretReferenceValid;

  /**
   * readOnly is Optional: defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * +optional
   *
   * @generated from field: optional bool readOnly = 4;
   */
  readOnly: boolean;

  /**
   * options is Optional: this field holds extra command options if any.
   * +optional
   *
   * @generated from field: map<string, string> options = 5;
   */
  options: { [key: string]: string };
};

/**
 * Describes the message k8s.io.api.core.v1.FlexPersistentVolumeSource.
 * Use `create(FlexPersistentVolumeSourceSchema)` to create a new message.
 */
export declare const FlexPersistentVolumeSourceSchema: GenMessage<FlexPersistentVolumeSource, {validType: FlexPersistentVolumeSourceValid}>;

/**
 * FlexVolume represents a generic volume resource that is
 * provisioned/attached using an exec based plugin.
 *
 * @generated from message k8s.io.api.core.v1.FlexVolumeSource
 */
export declare type FlexVolumeSource = Message<"k8s.io.api.core.v1.FlexVolumeSource"> & {
  /**
   * driver is the name of the driver to use for this volume.
   *
   * @generated from field: optional string driver = 1;
   */
  driver: string;

  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   * +optional
   *
   * @generated from field: optional string fsType = 2;
   */
  fsType: string;

  /**
   * secretRef is Optional: secretRef is reference to the secret object containing
   * sensitive information to pass to the plugin scripts. This may be
   * empty if no secret object is specified. If the secret object
   * contains more than one secret, all secrets are passed to the plugin
   * scripts.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.LocalObjectReference secretRef = 3;
   */
  secretRef?: LocalObjectReference;

  /**
   * readOnly is Optional: defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * +optional
   *
   * @generated from field: optional bool readOnly = 4;
   */
  readOnly: boolean;

  /**
   * options is Optional: this field holds extra command options if any.
   * +optional
   *
   * @generated from field: map<string, string> options = 5;
   */
  options: { [key: string]: string };
};

/**
 * FlexVolume represents a generic volume resource that is
 * provisioned/attached using an exec based plugin.
 *
 * @generated from message k8s.io.api.core.v1.FlexVolumeSource
 */
export declare type FlexVolumeSourceValid = Message<"k8s.io.api.core.v1.FlexVolumeSource"> & {
  /**
   * driver is the name of the driver to use for this volume.
   *
   * @generated from field: optional string driver = 1;
   */
  driver: string;

  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   * +optional
   *
   * @generated from field: optional string fsType = 2;
   */
  fsType: string;

  /**
   * secretRef is Optional: secretRef is reference to the secret object containing
   * sensitive information to pass to the plugin scripts. This may be
   * empty if no secret object is specified. If the secret object
   * contains more than one secret, all secrets are passed to the plugin
   * scripts.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.LocalObjectReference secretRef = 3;
   */
  secretRef?: LocalObjectReferenceValid;

  /**
   * readOnly is Optional: defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * +optional
   *
   * @generated from field: optional bool readOnly = 4;
   */
  readOnly: boolean;

  /**
   * options is Optional: this field holds extra command options if any.
   * +optional
   *
   * @generated from field: map<string, string> options = 5;
   */
  options: { [key: string]: string };
};

/**
 * Describes the message k8s.io.api.core.v1.FlexVolumeSource.
 * Use `create(FlexVolumeSourceSchema)` to create a new message.
 */
export declare const FlexVolumeSourceSchema: GenMessage<FlexVolumeSource, {validType: FlexVolumeSourceValid}>;

/**
 * Represents a Flocker volume mounted by the Flocker agent.
 * One and only one of datasetName and datasetUUID should be set.
 * Flocker volumes do not support ownership management or SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.FlockerVolumeSource
 */
export declare type FlockerVolumeSource = Message<"k8s.io.api.core.v1.FlockerVolumeSource"> & {
  /**
   * datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker
   * should be considered as deprecated
   * +optional
   *
   * @generated from field: optional string datasetName = 1;
   */
  datasetName: string;

  /**
   * datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
   * +optional
   *
   * @generated from field: optional string datasetUUID = 2;
   */
  datasetUUID: string;
};

/**
 * Represents a Flocker volume mounted by the Flocker agent.
 * One and only one of datasetName and datasetUUID should be set.
 * Flocker volumes do not support ownership management or SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.FlockerVolumeSource
 */
export declare type FlockerVolumeSourceValid = Message<"k8s.io.api.core.v1.FlockerVolumeSource"> & {
  /**
   * datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker
   * should be considered as deprecated
   * +optional
   *
   * @generated from field: optional string datasetName = 1;
   */
  datasetName: string;

  /**
   * datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
   * +optional
   *
   * @generated from field: optional string datasetUUID = 2;
   */
  datasetUUID: string;
};

/**
 * Describes the message k8s.io.api.core.v1.FlockerVolumeSource.
 * Use `create(FlockerVolumeSourceSchema)` to create a new message.
 */
export declare const FlockerVolumeSourceSchema: GenMessage<FlockerVolumeSource, {validType: FlockerVolumeSourceValid}>;

/**
 * Represents a Persistent Disk resource in Google Compute Engine.
 *
 * A GCE PD must exist before mounting to a container. The disk must
 * also be in the same GCE project and zone as the kubelet. A GCE PD
 * can only be mounted as read/write once or read-only many times. GCE
 * PDs support ownership management and SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.GCEPersistentDiskVolumeSource
 */
export declare type GCEPersistentDiskVolumeSource = Message<"k8s.io.api.core.v1.GCEPersistentDiskVolumeSource"> & {
  /**
   * pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @generated from field: optional string pdName = 1;
   */
  pdName: string;

  /**
   * fsType is filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   * +optional
   *
   * @generated from field: optional string fsType = 2;
   */
  fsType: string;

  /**
   * partition is the partition in the volume that you want to mount.
   * If omitted, the default is to mount by volume name.
   * Examples: For volume /dev/sda1, you specify the partition as "1".
   * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * +optional
   *
   * @generated from field: optional int32 partition = 3;
   */
  partition: number;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * +optional
   *
   * @generated from field: optional bool readOnly = 4;
   */
  readOnly: boolean;
};

/**
 * Represents a Persistent Disk resource in Google Compute Engine.
 *
 * A GCE PD must exist before mounting to a container. The disk must
 * also be in the same GCE project and zone as the kubelet. A GCE PD
 * can only be mounted as read/write once or read-only many times. GCE
 * PDs support ownership management and SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.GCEPersistentDiskVolumeSource
 */
export declare type GCEPersistentDiskVolumeSourceValid = Message<"k8s.io.api.core.v1.GCEPersistentDiskVolumeSource"> & {
  /**
   * pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @generated from field: optional string pdName = 1;
   */
  pdName: string;

  /**
   * fsType is filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   * +optional
   *
   * @generated from field: optional string fsType = 2;
   */
  fsType: string;

  /**
   * partition is the partition in the volume that you want to mount.
   * If omitted, the default is to mount by volume name.
   * Examples: For volume /dev/sda1, you specify the partition as "1".
   * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * +optional
   *
   * @generated from field: optional int32 partition = 3;
   */
  partition: number;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * +optional
   *
   * @generated from field: optional bool readOnly = 4;
   */
  readOnly: boolean;
};

/**
 * Describes the message k8s.io.api.core.v1.GCEPersistentDiskVolumeSource.
 * Use `create(GCEPersistentDiskVolumeSourceSchema)` to create a new message.
 */
export declare const GCEPersistentDiskVolumeSourceSchema: GenMessage<GCEPersistentDiskVolumeSource, {validType: GCEPersistentDiskVolumeSourceValid}>;

/**
 * @generated from message k8s.io.api.core.v1.GRPCAction
 */
export declare type GRPCAction = Message<"k8s.io.api.core.v1.GRPCAction"> & {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @generated from field: optional int32 port = 1;
   */
  port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   * +optional
   * +default=""
   *
   * @generated from field: optional string service = 2;
   */
  service: string;
};

/**
 * @generated from message k8s.io.api.core.v1.GRPCAction
 */
export declare type GRPCActionValid = Message<"k8s.io.api.core.v1.GRPCAction"> & {
  /**
   * Port number of the gRPC service. Number must be in the range 1 to 65535.
   *
   * @generated from field: optional int32 port = 1;
   */
  port: number;

  /**
   * Service is the name of the service to place in the gRPC HealthCheckRequest
   * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
   *
   * If this is not specified, the default behavior is defined by gRPC.
   * +optional
   * +default=""
   *
   * @generated from field: optional string service = 2;
   */
  service: string;
};

/**
 * Describes the message k8s.io.api.core.v1.GRPCAction.
 * Use `create(GRPCActionSchema)` to create a new message.
 */
export declare const GRPCActionSchema: GenMessage<GRPCAction, {validType: GRPCActionValid}>;

/**
 * Represents a volume that is populated with the contents of a git repository.
 * Git repo volumes do not support ownership management.
 * Git repo volumes support SELinux relabeling.
 *
 * DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
 * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
 * into the Pod's container.
 *
 * @generated from message k8s.io.api.core.v1.GitRepoVolumeSource
 */
export declare type GitRepoVolumeSource = Message<"k8s.io.api.core.v1.GitRepoVolumeSource"> & {
  /**
   * repository is the URL
   *
   * @generated from field: optional string repository = 1;
   */
  repository: string;

  /**
   * revision is the commit hash for the specified revision.
   * +optional
   *
   * @generated from field: optional string revision = 2;
   */
  revision: string;

  /**
   * directory is the target directory name.
   * Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
   * git repository.  Otherwise, if specified, the volume will contain the git repository in
   * the subdirectory with the given name.
   * +optional
   *
   * @generated from field: optional string directory = 3;
   */
  directory: string;
};

/**
 * Represents a volume that is populated with the contents of a git repository.
 * Git repo volumes do not support ownership management.
 * Git repo volumes support SELinux relabeling.
 *
 * DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
 * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
 * into the Pod's container.
 *
 * @generated from message k8s.io.api.core.v1.GitRepoVolumeSource
 */
export declare type GitRepoVolumeSourceValid = Message<"k8s.io.api.core.v1.GitRepoVolumeSource"> & {
  /**
   * repository is the URL
   *
   * @generated from field: optional string repository = 1;
   */
  repository: string;

  /**
   * revision is the commit hash for the specified revision.
   * +optional
   *
   * @generated from field: optional string revision = 2;
   */
  revision: string;

  /**
   * directory is the target directory name.
   * Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
   * git repository.  Otherwise, if specified, the volume will contain the git repository in
   * the subdirectory with the given name.
   * +optional
   *
   * @generated from field: optional string directory = 3;
   */
  directory: string;
};

/**
 * Describes the message k8s.io.api.core.v1.GitRepoVolumeSource.
 * Use `create(GitRepoVolumeSourceSchema)` to create a new message.
 */
export declare const GitRepoVolumeSourceSchema: GenMessage<GitRepoVolumeSource, {validType: GitRepoVolumeSourceValid}>;

/**
 * Represents a Glusterfs mount that lasts the lifetime of a pod.
 * Glusterfs volumes do not support ownership management or SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.GlusterfsPersistentVolumeSource
 */
export declare type GlusterfsPersistentVolumeSource = Message<"k8s.io.api.core.v1.GlusterfsPersistentVolumeSource"> & {
  /**
   * endpoints is the endpoint name that details Glusterfs topology.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @generated from field: optional string endpoints = 1;
   */
  endpoints: string;

  /**
   * path is the Glusterfs volume path.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @generated from field: optional string path = 2;
   */
  path: string;

  /**
   * readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   * +optional
   *
   * @generated from field: optional bool readOnly = 3;
   */
  readOnly: boolean;

  /**
   * endpointsNamespace is the namespace that contains Glusterfs endpoint.
   * If this field is empty, the EndpointNamespace defaults to the same namespace as the bound PVC.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   * +optional
   *
   * @generated from field: optional string endpointsNamespace = 4;
   */
  endpointsNamespace: string;
};

/**
 * Represents a Glusterfs mount that lasts the lifetime of a pod.
 * Glusterfs volumes do not support ownership management or SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.GlusterfsPersistentVolumeSource
 */
export declare type GlusterfsPersistentVolumeSourceValid = Message<"k8s.io.api.core.v1.GlusterfsPersistentVolumeSource"> & {
  /**
   * endpoints is the endpoint name that details Glusterfs topology.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @generated from field: optional string endpoints = 1;
   */
  endpoints: string;

  /**
   * path is the Glusterfs volume path.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @generated from field: optional string path = 2;
   */
  path: string;

  /**
   * readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   * +optional
   *
   * @generated from field: optional bool readOnly = 3;
   */
  readOnly: boolean;

  /**
   * endpointsNamespace is the namespace that contains Glusterfs endpoint.
   * If this field is empty, the EndpointNamespace defaults to the same namespace as the bound PVC.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   * +optional
   *
   * @generated from field: optional string endpointsNamespace = 4;
   */
  endpointsNamespace: string;
};

/**
 * Describes the message k8s.io.api.core.v1.GlusterfsPersistentVolumeSource.
 * Use `create(GlusterfsPersistentVolumeSourceSchema)` to create a new message.
 */
export declare const GlusterfsPersistentVolumeSourceSchema: GenMessage<GlusterfsPersistentVolumeSource, {validType: GlusterfsPersistentVolumeSourceValid}>;

/**
 * Represents a Glusterfs mount that lasts the lifetime of a pod.
 * Glusterfs volumes do not support ownership management or SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.GlusterfsVolumeSource
 */
export declare type GlusterfsVolumeSource = Message<"k8s.io.api.core.v1.GlusterfsVolumeSource"> & {
  /**
   * endpoints is the endpoint name that details Glusterfs topology.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @generated from field: optional string endpoints = 1;
   */
  endpoints: string;

  /**
   * path is the Glusterfs volume path.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @generated from field: optional string path = 2;
   */
  path: string;

  /**
   * readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   * +optional
   *
   * @generated from field: optional bool readOnly = 3;
   */
  readOnly: boolean;
};

/**
 * Represents a Glusterfs mount that lasts the lifetime of a pod.
 * Glusterfs volumes do not support ownership management or SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.GlusterfsVolumeSource
 */
export declare type GlusterfsVolumeSourceValid = Message<"k8s.io.api.core.v1.GlusterfsVolumeSource"> & {
  /**
   * endpoints is the endpoint name that details Glusterfs topology.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @generated from field: optional string endpoints = 1;
   */
  endpoints: string;

  /**
   * path is the Glusterfs volume path.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   *
   * @generated from field: optional string path = 2;
   */
  path: string;

  /**
   * readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
   * +optional
   *
   * @generated from field: optional bool readOnly = 3;
   */
  readOnly: boolean;
};

/**
 * Describes the message k8s.io.api.core.v1.GlusterfsVolumeSource.
 * Use `create(GlusterfsVolumeSourceSchema)` to create a new message.
 */
export declare const GlusterfsVolumeSourceSchema: GenMessage<GlusterfsVolumeSource, {validType: GlusterfsVolumeSourceValid}>;

/**
 * HTTPGetAction describes an action based on HTTP Get requests.
 *
 * @generated from message k8s.io.api.core.v1.HTTPGetAction
 */
export declare type HTTPGetAction = Message<"k8s.io.api.core.v1.HTTPGetAction"> & {
  /**
   * Path to access on the HTTP server.
   * +optional
   *
   * @generated from field: optional string path = 1;
   */
  path: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 2;
   */
  port?: IntOrString;

  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   * +optional
   *
   * @generated from field: optional string host = 3;
   */
  host: string;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   * +optional
   *
   * @generated from field: optional string scheme = 4;
   */
  scheme: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.HTTPHeader httpHeaders = 5;
   */
  httpHeaders: HTTPHeader[];
};

/**
 * HTTPGetAction describes an action based on HTTP Get requests.
 *
 * @generated from message k8s.io.api.core.v1.HTTPGetAction
 */
export declare type HTTPGetActionValid = Message<"k8s.io.api.core.v1.HTTPGetAction"> & {
  /**
   * Path to access on the HTTP server.
   * +optional
   *
   * @generated from field: optional string path = 1;
   */
  path: string;

  /**
   * Name or number of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 2;
   */
  port?: IntOrStringValid;

  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set
   * "Host" in httpHeaders instead.
   * +optional
   *
   * @generated from field: optional string host = 3;
   */
  host: string;

  /**
   * Scheme to use for connecting to the host.
   * Defaults to HTTP.
   * +optional
   *
   * @generated from field: optional string scheme = 4;
   */
  scheme: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.HTTPHeader httpHeaders = 5;
   */
  httpHeaders: HTTPHeaderValid[];
};

/**
 * Describes the message k8s.io.api.core.v1.HTTPGetAction.
 * Use `create(HTTPGetActionSchema)` to create a new message.
 */
export declare const HTTPGetActionSchema: GenMessage<HTTPGetAction, {validType: HTTPGetActionValid}>;

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @generated from message k8s.io.api.core.v1.HTTPHeader
 */
export declare type HTTPHeader = Message<"k8s.io.api.core.v1.HTTPHeader"> & {
  /**
   * The header field name
   *
   * @generated from field: optional string name = 1;
   */
  name: string;

  /**
   * The header field value
   *
   * @generated from field: optional string value = 2;
   */
  value: string;
};

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @generated from message k8s.io.api.core.v1.HTTPHeader
 */
export declare type HTTPHeaderValid = Message<"k8s.io.api.core.v1.HTTPHeader"> & {
  /**
   * The header field name
   *
   * @generated from field: optional string name = 1;
   */
  name: string;

  /**
   * The header field value
   *
   * @generated from field: optional string value = 2;
   */
  value: string;
};

/**
 * Describes the message k8s.io.api.core.v1.HTTPHeader.
 * Use `create(HTTPHeaderSchema)` to create a new message.
 */
export declare const HTTPHeaderSchema: GenMessage<HTTPHeader, {validType: HTTPHeaderValid}>;

/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
 * pod's hosts file.
 *
 * @generated from message k8s.io.api.core.v1.HostAlias
 */
export declare type HostAlias = Message<"k8s.io.api.core.v1.HostAlias"> & {
  /**
   * IP address of the host file entry.
   *
   * @generated from field: optional string ip = 1;
   */
  ip: string;

  /**
   * Hostnames for the above IP address.
   *
   * @generated from field: repeated string hostnames = 2;
   */
  hostnames: string[];
};

/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
 * pod's hosts file.
 *
 * @generated from message k8s.io.api.core.v1.HostAlias
 */
export declare type HostAliasValid = Message<"k8s.io.api.core.v1.HostAlias"> & {
  /**
   * IP address of the host file entry.
   *
   * @generated from field: optional string ip = 1;
   */
  ip: string;

  /**
   * Hostnames for the above IP address.
   *
   * @generated from field: repeated string hostnames = 2;
   */
  hostnames: string[];
};

/**
 * Describes the message k8s.io.api.core.v1.HostAlias.
 * Use `create(HostAliasSchema)` to create a new message.
 */
export declare const HostAliasSchema: GenMessage<HostAlias, {validType: HostAliasValid}>;

/**
 * Represents a host path mapped into a pod.
 * Host path volumes do not support ownership management or SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.HostPathVolumeSource
 */
export declare type HostPathVolumeSource = Message<"k8s.io.api.core.v1.HostPathVolumeSource"> & {
  /**
   * path of the directory on the host.
   * If the path is a symlink, it will follow the link to the real path.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @generated from field: optional string path = 1;
   */
  path: string;

  /**
   * type for HostPath Volume
   * Defaults to ""
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * +optional
   *
   * @generated from field: optional string type = 2;
   */
  type: string;
};

/**
 * Represents a host path mapped into a pod.
 * Host path volumes do not support ownership management or SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.HostPathVolumeSource
 */
export declare type HostPathVolumeSourceValid = Message<"k8s.io.api.core.v1.HostPathVolumeSource"> & {
  /**
   * path of the directory on the host.
   * If the path is a symlink, it will follow the link to the real path.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @generated from field: optional string path = 1;
   */
  path: string;

  /**
   * type for HostPath Volume
   * Defaults to ""
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * +optional
   *
   * @generated from field: optional string type = 2;
   */
  type: string;
};

/**
 * Describes the message k8s.io.api.core.v1.HostPathVolumeSource.
 * Use `create(HostPathVolumeSourceSchema)` to create a new message.
 */
export declare const HostPathVolumeSourceSchema: GenMessage<HostPathVolumeSource, {validType: HostPathVolumeSourceValid}>;

/**
 * ISCSIPersistentVolumeSource represents an ISCSI disk.
 * ISCSI volumes can only be mounted as read/write once.
 * ISCSI volumes support ownership management and SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.ISCSIPersistentVolumeSource
 */
export declare type ISCSIPersistentVolumeSource = Message<"k8s.io.api.core.v1.ISCSIPersistentVolumeSource"> & {
  /**
   * targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   *
   * @generated from field: optional string targetPortal = 1;
   */
  targetPortal: string;

  /**
   * iqn is Target iSCSI Qualified Name.
   *
   * @generated from field: optional string iqn = 2;
   */
  iqn: string;

  /**
   * lun is iSCSI Target Lun number.
   *
   * @generated from field: optional int32 lun = 3;
   */
  lun: number;

  /**
   * iscsiInterface is the interface Name that uses an iSCSI transport.
   * Defaults to 'default' (tcp).
   * +optional
   *
   * @generated from field: optional string iscsiInterface = 4;
   */
  iscsiInterface: string;

  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   * +optional
   *
   * @generated from field: optional string fsType = 5;
   */
  fsType: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * +optional
   *
   * @generated from field: optional bool readOnly = 6;
   */
  readOnly: boolean;

  /**
   * portals is the iSCSI Target Portal List. The Portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   * +optional
   *
   * @generated from field: repeated string portals = 7;
   */
  portals: string[];

  /**
   * chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
   * +optional
   *
   * @generated from field: optional bool chapAuthDiscovery = 8;
   */
  chapAuthDiscovery: boolean;

  /**
   * chapAuthSession defines whether support iSCSI Session CHAP authentication
   * +optional
   *
   * @generated from field: optional bool chapAuthSession = 11;
   */
  chapAuthSession: boolean;

  /**
   * secretRef is the CHAP Secret for iSCSI target and initiator authentication
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.SecretReference secretRef = 10;
   */
  secretRef?: SecretReference;

  /**
   * initiatorName is the custom iSCSI Initiator Name.
   * If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
   * <target portal>:<volume name> will be created for the connection.
   * +optional
   *
   * @generated from field: optional string initiatorName = 12;
   */
  initiatorName: string;
};

/**
 * ISCSIPersistentVolumeSource represents an ISCSI disk.
 * ISCSI volumes can only be mounted as read/write once.
 * ISCSI volumes support ownership management and SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.ISCSIPersistentVolumeSource
 */
export declare type ISCSIPersistentVolumeSourceValid = Message<"k8s.io.api.core.v1.ISCSIPersistentVolumeSource"> & {
  /**
   * targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   *
   * @generated from field: optional string targetPortal = 1;
   */
  targetPortal: string;

  /**
   * iqn is Target iSCSI Qualified Name.
   *
   * @generated from field: optional string iqn = 2;
   */
  iqn: string;

  /**
   * lun is iSCSI Target Lun number.
   *
   * @generated from field: optional int32 lun = 3;
   */
  lun: number;

  /**
   * iscsiInterface is the interface Name that uses an iSCSI transport.
   * Defaults to 'default' (tcp).
   * +optional
   *
   * @generated from field: optional string iscsiInterface = 4;
   */
  iscsiInterface: string;

  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   * +optional
   *
   * @generated from field: optional string fsType = 5;
   */
  fsType: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * +optional
   *
   * @generated from field: optional bool readOnly = 6;
   */
  readOnly: boolean;

  /**
   * portals is the iSCSI Target Portal List. The Portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   * +optional
   *
   * @generated from field: repeated string portals = 7;
   */
  portals: string[];

  /**
   * chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
   * +optional
   *
   * @generated from field: optional bool chapAuthDiscovery = 8;
   */
  chapAuthDiscovery: boolean;

  /**
   * chapAuthSession defines whether support iSCSI Session CHAP authentication
   * +optional
   *
   * @generated from field: optional bool chapAuthSession = 11;
   */
  chapAuthSession: boolean;

  /**
   * secretRef is the CHAP Secret for iSCSI target and initiator authentication
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.SecretReference secretRef = 10;
   */
  secretRef?: SecretReferenceValid;

  /**
   * initiatorName is the custom iSCSI Initiator Name.
   * If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
   * <target portal>:<volume name> will be created for the connection.
   * +optional
   *
   * @generated from field: optional string initiatorName = 12;
   */
  initiatorName: string;
};

/**
 * Describes the message k8s.io.api.core.v1.ISCSIPersistentVolumeSource.
 * Use `create(ISCSIPersistentVolumeSourceSchema)` to create a new message.
 */
export declare const ISCSIPersistentVolumeSourceSchema: GenMessage<ISCSIPersistentVolumeSource, {validType: ISCSIPersistentVolumeSourceValid}>;

/**
 * Represents an ISCSI disk.
 * ISCSI volumes can only be mounted as read/write once.
 * ISCSI volumes support ownership management and SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.ISCSIVolumeSource
 */
export declare type ISCSIVolumeSource = Message<"k8s.io.api.core.v1.ISCSIVolumeSource"> & {
  /**
   * targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   *
   * @generated from field: optional string targetPortal = 1;
   */
  targetPortal: string;

  /**
   * iqn is the target iSCSI Qualified Name.
   *
   * @generated from field: optional string iqn = 2;
   */
  iqn: string;

  /**
   * lun represents iSCSI Target Lun number.
   *
   * @generated from field: optional int32 lun = 3;
   */
  lun: number;

  /**
   * iscsiInterface is the interface Name that uses an iSCSI transport.
   * Defaults to 'default' (tcp).
   * +optional
   *
   * @generated from field: optional string iscsiInterface = 4;
   */
  iscsiInterface: string;

  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   * +optional
   *
   * @generated from field: optional string fsType = 5;
   */
  fsType: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * +optional
   *
   * @generated from field: optional bool readOnly = 6;
   */
  readOnly: boolean;

  /**
   * portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   * +optional
   *
   * @generated from field: repeated string portals = 7;
   */
  portals: string[];

  /**
   * chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
   * +optional
   *
   * @generated from field: optional bool chapAuthDiscovery = 8;
   */
  chapAuthDiscovery: boolean;

  /**
   * chapAuthSession defines whether support iSCSI Session CHAP authentication
   * +optional
   *
   * @generated from field: optional bool chapAuthSession = 11;
   */
  chapAuthSession: boolean;

  /**
   * secretRef is the CHAP Secret for iSCSI target and initiator authentication
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.LocalObjectReference secretRef = 10;
   */
  secretRef?: LocalObjectReference;

  /**
   * initiatorName is the custom iSCSI Initiator Name.
   * If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
   * <target portal>:<volume name> will be created for the connection.
   * +optional
   *
   * @generated from field: optional string initiatorName = 12;
   */
  initiatorName: string;
};

/**
 * Represents an ISCSI disk.
 * ISCSI volumes can only be mounted as read/write once.
 * ISCSI volumes support ownership management and SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.ISCSIVolumeSource
 */
export declare type ISCSIVolumeSourceValid = Message<"k8s.io.api.core.v1.ISCSIVolumeSource"> & {
  /**
   * targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   *
   * @generated from field: optional string targetPortal = 1;
   */
  targetPortal: string;

  /**
   * iqn is the target iSCSI Qualified Name.
   *
   * @generated from field: optional string iqn = 2;
   */
  iqn: string;

  /**
   * lun represents iSCSI Target Lun number.
   *
   * @generated from field: optional int32 lun = 3;
   */
  lun: number;

  /**
   * iscsiInterface is the interface Name that uses an iSCSI transport.
   * Defaults to 'default' (tcp).
   * +optional
   *
   * @generated from field: optional string iscsiInterface = 4;
   */
  iscsiInterface: string;

  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   * +optional
   *
   * @generated from field: optional string fsType = 5;
   */
  fsType: string;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * +optional
   *
   * @generated from field: optional bool readOnly = 6;
   */
  readOnly: boolean;

  /**
   * portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
   * is other than default (typically TCP ports 860 and 3260).
   * +optional
   *
   * @generated from field: repeated string portals = 7;
   */
  portals: string[];

  /**
   * chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
   * +optional
   *
   * @generated from field: optional bool chapAuthDiscovery = 8;
   */
  chapAuthDiscovery: boolean;

  /**
   * chapAuthSession defines whether support iSCSI Session CHAP authentication
   * +optional
   *
   * @generated from field: optional bool chapAuthSession = 11;
   */
  chapAuthSession: boolean;

  /**
   * secretRef is the CHAP Secret for iSCSI target and initiator authentication
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.LocalObjectReference secretRef = 10;
   */
  secretRef?: LocalObjectReferenceValid;

  /**
   * initiatorName is the custom iSCSI Initiator Name.
   * If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
   * <target portal>:<volume name> will be created for the connection.
   * +optional
   *
   * @generated from field: optional string initiatorName = 12;
   */
  initiatorName: string;
};

/**
 * Describes the message k8s.io.api.core.v1.ISCSIVolumeSource.
 * Use `create(ISCSIVolumeSourceSchema)` to create a new message.
 */
export declare const ISCSIVolumeSourceSchema: GenMessage<ISCSIVolumeSource, {validType: ISCSIVolumeSourceValid}>;

/**
 * Maps a string key to a path within a volume.
 *
 * @generated from message k8s.io.api.core.v1.KeyToPath
 */
export declare type KeyToPath = Message<"k8s.io.api.core.v1.KeyToPath"> & {
  /**
   * key is the key to project.
   *
   * @generated from field: optional string key = 1;
   */
  key: string;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @generated from field: optional string path = 2;
   */
  path: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   * +optional
   *
   * @generated from field: optional int32 mode = 3;
   */
  mode: number;
};

/**
 * Maps a string key to a path within a volume.
 *
 * @generated from message k8s.io.api.core.v1.KeyToPath
 */
export declare type KeyToPathValid = Message<"k8s.io.api.core.v1.KeyToPath"> & {
  /**
   * key is the key to project.
   *
   * @generated from field: optional string key = 1;
   */
  key: string;

  /**
   * path is the relative path of the file to map the key to.
   * May not be an absolute path.
   * May not contain the path element '..'.
   * May not start with the string '..'.
   *
   * @generated from field: optional string path = 2;
   */
  path: string;

  /**
   * mode is Optional: mode bits used to set permissions on this file.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * If not specified, the volume defaultMode will be used.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   * +optional
   *
   * @generated from field: optional int32 mode = 3;
   */
  mode: number;
};

/**
 * Describes the message k8s.io.api.core.v1.KeyToPath.
 * Use `create(KeyToPathSchema)` to create a new message.
 */
export declare const KeyToPathSchema: GenMessage<KeyToPath, {validType: KeyToPathValid}>;

/**
 * Lifecycle describes actions that the management system should take in response to container lifecycle
 * events. For the PostStart and PreStop lifecycle handlers, management of the container blocks
 * until the action is complete, unless the container process fails, in which case the handler is aborted.
 *
 * @generated from message k8s.io.api.core.v1.Lifecycle
 */
export declare type Lifecycle = Message<"k8s.io.api.core.v1.Lifecycle"> & {
  /**
   * PostStart is called immediately after a container is created. If the handler fails,
   * the container is terminated and restarted according to its restart policy.
   * Other management of the container blocks until the hook completes.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.LifecycleHandler postStart = 1;
   */
  postStart?: LifecycleHandler;

  /**
   * PreStop is called immediately before a container is terminated due to an
   * API request or management event such as liveness/startup probe failure,
   * preemption, resource contention, etc. The handler is not called if the
   * container crashes or exits. The Pod's termination grace period countdown begins before the
   * PreStop hook is executed. Regardless of the outcome of the handler, the
   * container will eventually terminate within the Pod's termination grace
   * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
   * or until the termination grace period is reached.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.LifecycleHandler preStop = 2;
   */
  preStop?: LifecycleHandler;
};

/**
 * Lifecycle describes actions that the management system should take in response to container lifecycle
 * events. For the PostStart and PreStop lifecycle handlers, management of the container blocks
 * until the action is complete, unless the container process fails, in which case the handler is aborted.
 *
 * @generated from message k8s.io.api.core.v1.Lifecycle
 */
export declare type LifecycleValid = Message<"k8s.io.api.core.v1.Lifecycle"> & {
  /**
   * PostStart is called immediately after a container is created. If the handler fails,
   * the container is terminated and restarted according to its restart policy.
   * Other management of the container blocks until the hook completes.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.LifecycleHandler postStart = 1;
   */
  postStart?: LifecycleHandlerValid;

  /**
   * PreStop is called immediately before a container is terminated due to an
   * API request or management event such as liveness/startup probe failure,
   * preemption, resource contention, etc. The handler is not called if the
   * container crashes or exits. The Pod's termination grace period countdown begins before the
   * PreStop hook is executed. Regardless of the outcome of the handler, the
   * container will eventually terminate within the Pod's termination grace
   * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
   * or until the termination grace period is reached.
   * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.LifecycleHandler preStop = 2;
   */
  preStop?: LifecycleHandlerValid;
};

/**
 * Describes the message k8s.io.api.core.v1.Lifecycle.
 * Use `create(LifecycleSchema)` to create a new message.
 */
export declare const LifecycleSchema: GenMessage<Lifecycle, {validType: LifecycleValid}>;

/**
 * LifecycleHandler defines a specific action that should be taken in a lifecycle
 * hook. One and only one of the fields, except TCPSocket must be specified.
 *
 * @generated from message k8s.io.api.core.v1.LifecycleHandler
 */
export declare type LifecycleHandler = Message<"k8s.io.api.core.v1.LifecycleHandler"> & {
  /**
   * Exec specifies the action to take.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ExecAction exec = 1;
   */
  exec?: ExecAction;

  /**
   * HTTPGet specifies the http request to perform.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.HTTPGetAction httpGet = 2;
   */
  httpGet?: HTTPGetAction;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for the backward compatibility. There are no validation of this field and
   * lifecycle hooks will fail in runtime when tcp handler is specified.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.TCPSocketAction tcpSocket = 3;
   */
  tcpSocket?: TCPSocketAction;
};

/**
 * LifecycleHandler defines a specific action that should be taken in a lifecycle
 * hook. One and only one of the fields, except TCPSocket must be specified.
 *
 * @generated from message k8s.io.api.core.v1.LifecycleHandler
 */
export declare type LifecycleHandlerValid = Message<"k8s.io.api.core.v1.LifecycleHandler"> & {
  /**
   * Exec specifies the action to take.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ExecAction exec = 1;
   */
  exec?: ExecActionValid;

  /**
   * HTTPGet specifies the http request to perform.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.HTTPGetAction httpGet = 2;
   */
  httpGet?: HTTPGetActionValid;

  /**
   * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
   * for the backward compatibility. There are no validation of this field and
   * lifecycle hooks will fail in runtime when tcp handler is specified.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.TCPSocketAction tcpSocket = 3;
   */
  tcpSocket?: TCPSocketActionValid;
};

/**
 * Describes the message k8s.io.api.core.v1.LifecycleHandler.
 * Use `create(LifecycleHandlerSchema)` to create a new message.
 */
export declare const LifecycleHandlerSchema: GenMessage<LifecycleHandler, {validType: LifecycleHandlerValid}>;

/**
 * LimitRange sets resource usage limits for each kind of resource in a Namespace.
 *
 * @generated from message k8s.io.api.core.v1.LimitRange
 */
export declare type LimitRange = Message<"k8s.io.api.core.v1.LimitRange"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMeta;

  /**
   * Spec defines the limits enforced.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.LimitRangeSpec spec = 2;
   */
  spec?: LimitRangeSpec;
};

/**
 * LimitRange sets resource usage limits for each kind of resource in a Namespace.
 *
 * @generated from message k8s.io.api.core.v1.LimitRange
 */
export declare type LimitRangeValid = Message<"k8s.io.api.core.v1.LimitRange"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMetaValid;

  /**
   * Spec defines the limits enforced.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.LimitRangeSpec spec = 2;
   */
  spec?: LimitRangeSpecValid;
};

/**
 * Describes the message k8s.io.api.core.v1.LimitRange.
 * Use `create(LimitRangeSchema)` to create a new message.
 */
export declare const LimitRangeSchema: GenMessage<LimitRange, {validType: LimitRangeValid}>;

/**
 * LimitRangeItem defines a min/max usage limit for any resource that matches on kind.
 *
 * @generated from message k8s.io.api.core.v1.LimitRangeItem
 */
export declare type LimitRangeItem = Message<"k8s.io.api.core.v1.LimitRangeItem"> & {
  /**
   * Type of resource that this limit applies to.
   *
   * @generated from field: optional string type = 1;
   */
  type: string;

  /**
   * Max usage constraints on this kind by resource name.
   * +optional
   *
   * @generated from field: map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> max = 2;
   */
  max: { [key: string]: Quantity };

  /**
   * Min usage constraints on this kind by resource name.
   * +optional
   *
   * @generated from field: map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> min = 3;
   */
  min: { [key: string]: Quantity };

  /**
   * Default resource requirement limit value by resource name if resource limit is omitted.
   * +optional
   *
   * @generated from field: map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> default = 4;
   */
  default: { [key: string]: Quantity };

  /**
   * DefaultRequest is the default resource requirement request value by resource name if resource request is omitted.
   * +optional
   *
   * @generated from field: map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> defaultRequest = 5;
   */
  defaultRequest: { [key: string]: Quantity };

  /**
   * MaxLimitRequestRatio if specified, the named resource must have a request and limit that are both non-zero where limit divided by request is less than or equal to the enumerated value; this represents the max burst for the named resource.
   * +optional
   *
   * @generated from field: map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> maxLimitRequestRatio = 6;
   */
  maxLimitRequestRatio: { [key: string]: Quantity };
};

/**
 * LimitRangeItem defines a min/max usage limit for any resource that matches on kind.
 *
 * @generated from message k8s.io.api.core.v1.LimitRangeItem
 */
export declare type LimitRangeItemValid = Message<"k8s.io.api.core.v1.LimitRangeItem"> & {
  /**
   * Type of resource that this limit applies to.
   *
   * @generated from field: optional string type = 1;
   */
  type: string;

  /**
   * Max usage constraints on this kind by resource name.
   * +optional
   *
   * @generated from field: map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> max = 2;
   */
  max: { [key: string]: QuantityValid };

  /**
   * Min usage constraints on this kind by resource name.
   * +optional
   *
   * @generated from field: map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> min = 3;
   */
  min: { [key: string]: QuantityValid };

  /**
   * Default resource requirement limit value by resource name if resource limit is omitted.
   * +optional
   *
   * @generated from field: map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> default = 4;
   */
  default: { [key: string]: QuantityValid };

  /**
   * DefaultRequest is the default resource requirement request value by resource name if resource request is omitted.
   * +optional
   *
   * @generated from field: map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> defaultRequest = 5;
   */
  defaultRequest: { [key: string]: QuantityValid };

  /**
   * MaxLimitRequestRatio if specified, the named resource must have a request and limit that are both non-zero where limit divided by request is less than or equal to the enumerated value; this represents the max burst for the named resource.
   * +optional
   *
   * @generated from field: map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> maxLimitRequestRatio = 6;
   */
  maxLimitRequestRatio: { [key: string]: QuantityValid };
};

/**
 * Describes the message k8s.io.api.core.v1.LimitRangeItem.
 * Use `create(LimitRangeItemSchema)` to create a new message.
 */
export declare const LimitRangeItemSchema: GenMessage<LimitRangeItem, {validType: LimitRangeItemValid}>;

/**
 * LimitRangeList is a list of LimitRange items.
 *
 * @generated from message k8s.io.api.core.v1.LimitRangeList
 */
export declare type LimitRangeList = Message<"k8s.io.api.core.v1.LimitRangeList"> & {
  /**
   * Standard list metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMeta;

  /**
   * Items is a list of LimitRange objects.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @generated from field: repeated k8s.io.api.core.v1.LimitRange items = 2;
   */
  items: LimitRange[];
};

/**
 * LimitRangeList is a list of LimitRange items.
 *
 * @generated from message k8s.io.api.core.v1.LimitRangeList
 */
export declare type LimitRangeListValid = Message<"k8s.io.api.core.v1.LimitRangeList"> & {
  /**
   * Standard list metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMetaValid;

  /**
   * Items is a list of LimitRange objects.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   *
   * @generated from field: repeated k8s.io.api.core.v1.LimitRange items = 2;
   */
  items: LimitRangeValid[];
};

/**
 * Describes the message k8s.io.api.core.v1.LimitRangeList.
 * Use `create(LimitRangeListSchema)` to create a new message.
 */
export declare const LimitRangeListSchema: GenMessage<LimitRangeList, {validType: LimitRangeListValid}>;

/**
 * LimitRangeSpec defines a min/max usage limit for resources that match on kind.
 *
 * @generated from message k8s.io.api.core.v1.LimitRangeSpec
 */
export declare type LimitRangeSpec = Message<"k8s.io.api.core.v1.LimitRangeSpec"> & {
  /**
   * Limits is the list of LimitRangeItem objects that are enforced.
   *
   * @generated from field: repeated k8s.io.api.core.v1.LimitRangeItem limits = 1;
   */
  limits: LimitRangeItem[];
};

/**
 * LimitRangeSpec defines a min/max usage limit for resources that match on kind.
 *
 * @generated from message k8s.io.api.core.v1.LimitRangeSpec
 */
export declare type LimitRangeSpecValid = Message<"k8s.io.api.core.v1.LimitRangeSpec"> & {
  /**
   * Limits is the list of LimitRangeItem objects that are enforced.
   *
   * @generated from field: repeated k8s.io.api.core.v1.LimitRangeItem limits = 1;
   */
  limits: LimitRangeItemValid[];
};

/**
 * Describes the message k8s.io.api.core.v1.LimitRangeSpec.
 * Use `create(LimitRangeSpecSchema)` to create a new message.
 */
export declare const LimitRangeSpecSchema: GenMessage<LimitRangeSpec, {validType: LimitRangeSpecValid}>;

/**
 * List holds a list of objects, which may not be known by the server.
 *
 * @generated from message k8s.io.api.core.v1.List
 */
export declare type List = Message<"k8s.io.api.core.v1.List"> & {
  /**
   * Standard list metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMeta;

  /**
   * List of objects
   *
   * @generated from field: repeated k8s.io.apimachinery.pkg.runtime.RawExtension items = 2;
   */
  items: RawExtension[];
};

/**
 * List holds a list of objects, which may not be known by the server.
 *
 * @generated from message k8s.io.api.core.v1.List
 */
export declare type ListValid = Message<"k8s.io.api.core.v1.List"> & {
  /**
   * Standard list metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMetaValid;

  /**
   * List of objects
   *
   * @generated from field: repeated k8s.io.apimachinery.pkg.runtime.RawExtension items = 2;
   */
  items: RawExtensionValid[];
};

/**
 * Describes the message k8s.io.api.core.v1.List.
 * Use `create(ListSchema)` to create a new message.
 */
export declare const ListSchema: GenMessage<List, {validType: ListValid}>;

/**
 * LoadBalancerIngress represents the status of a load-balancer ingress point:
 * traffic intended for the service should be sent to an ingress point.
 *
 * @generated from message k8s.io.api.core.v1.LoadBalancerIngress
 */
export declare type LoadBalancerIngress = Message<"k8s.io.api.core.v1.LoadBalancerIngress"> & {
  /**
   * IP is set for load-balancer ingress points that are IP based
   * (typically GCE or OpenStack load-balancers)
   * +optional
   *
   * @generated from field: optional string ip = 1;
   */
  ip: string;

  /**
   * Hostname is set for load-balancer ingress points that are DNS based
   * (typically AWS load-balancers)
   * +optional
   *
   * @generated from field: optional string hostname = 2;
   */
  hostname: string;

  /**
   * Ports is a list of records of service ports
   * If used, every port defined in the service should have an entry in it
   * +listType=atomic
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.PortStatus ports = 4;
   */
  ports: PortStatus[];
};

/**
 * LoadBalancerIngress represents the status of a load-balancer ingress point:
 * traffic intended for the service should be sent to an ingress point.
 *
 * @generated from message k8s.io.api.core.v1.LoadBalancerIngress
 */
export declare type LoadBalancerIngressValid = Message<"k8s.io.api.core.v1.LoadBalancerIngress"> & {
  /**
   * IP is set for load-balancer ingress points that are IP based
   * (typically GCE or OpenStack load-balancers)
   * +optional
   *
   * @generated from field: optional string ip = 1;
   */
  ip: string;

  /**
   * Hostname is set for load-balancer ingress points that are DNS based
   * (typically AWS load-balancers)
   * +optional
   *
   * @generated from field: optional string hostname = 2;
   */
  hostname: string;

  /**
   * Ports is a list of records of service ports
   * If used, every port defined in the service should have an entry in it
   * +listType=atomic
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.PortStatus ports = 4;
   */
  ports: PortStatusValid[];
};

/**
 * Describes the message k8s.io.api.core.v1.LoadBalancerIngress.
 * Use `create(LoadBalancerIngressSchema)` to create a new message.
 */
export declare const LoadBalancerIngressSchema: GenMessage<LoadBalancerIngress, {validType: LoadBalancerIngressValid}>;

/**
 * LoadBalancerStatus represents the status of a load-balancer.
 *
 * @generated from message k8s.io.api.core.v1.LoadBalancerStatus
 */
export declare type LoadBalancerStatus = Message<"k8s.io.api.core.v1.LoadBalancerStatus"> & {
  /**
   * Ingress is a list containing ingress points for the load-balancer.
   * Traffic intended for the service should be sent to these ingress points.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.LoadBalancerIngress ingress = 1;
   */
  ingress: LoadBalancerIngress[];
};

/**
 * LoadBalancerStatus represents the status of a load-balancer.
 *
 * @generated from message k8s.io.api.core.v1.LoadBalancerStatus
 */
export declare type LoadBalancerStatusValid = Message<"k8s.io.api.core.v1.LoadBalancerStatus"> & {
  /**
   * Ingress is a list containing ingress points for the load-balancer.
   * Traffic intended for the service should be sent to these ingress points.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.LoadBalancerIngress ingress = 1;
   */
  ingress: LoadBalancerIngressValid[];
};

/**
 * Describes the message k8s.io.api.core.v1.LoadBalancerStatus.
 * Use `create(LoadBalancerStatusSchema)` to create a new message.
 */
export declare const LoadBalancerStatusSchema: GenMessage<LoadBalancerStatus, {validType: LoadBalancerStatusValid}>;

/**
 * LocalObjectReference contains enough information to let you locate the
 * referenced object inside the same namespace.
 * +structType=atomic
 *
 * @generated from message k8s.io.api.core.v1.LocalObjectReference
 */
export declare type LocalObjectReference = Message<"k8s.io.api.core.v1.LocalObjectReference"> & {
  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * +optional
   *
   * @generated from field: optional string name = 1;
   */
  name: string;
};

/**
 * LocalObjectReference contains enough information to let you locate the
 * referenced object inside the same namespace.
 * +structType=atomic
 *
 * @generated from message k8s.io.api.core.v1.LocalObjectReference
 */
export declare type LocalObjectReferenceValid = Message<"k8s.io.api.core.v1.LocalObjectReference"> & {
  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * TODO: Add other useful fields. apiVersion, kind, uid?
   * +optional
   *
   * @generated from field: optional string name = 1;
   */
  name: string;
};

/**
 * Describes the message k8s.io.api.core.v1.LocalObjectReference.
 * Use `create(LocalObjectReferenceSchema)` to create a new message.
 */
export declare const LocalObjectReferenceSchema: GenMessage<LocalObjectReference, {validType: LocalObjectReferenceValid}>;

/**
 * Local represents directly-attached storage with node affinity (Beta feature)
 *
 * @generated from message k8s.io.api.core.v1.LocalVolumeSource
 */
export declare type LocalVolumeSource = Message<"k8s.io.api.core.v1.LocalVolumeSource"> & {
  /**
   * path of the full path to the volume on the node.
   * It can be either a directory or block device (disk, partition, ...).
   *
   * @generated from field: optional string path = 1;
   */
  path: string;

  /**
   * fsType is the filesystem type to mount.
   * It applies only when the Path is a block device.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". The default value is to auto-select a filesystem if unspecified.
   * +optional
   *
   * @generated from field: optional string fsType = 2;
   */
  fsType: string;
};

/**
 * Local represents directly-attached storage with node affinity (Beta feature)
 *
 * @generated from message k8s.io.api.core.v1.LocalVolumeSource
 */
export declare type LocalVolumeSourceValid = Message<"k8s.io.api.core.v1.LocalVolumeSource"> & {
  /**
   * path of the full path to the volume on the node.
   * It can be either a directory or block device (disk, partition, ...).
   *
   * @generated from field: optional string path = 1;
   */
  path: string;

  /**
   * fsType is the filesystem type to mount.
   * It applies only when the Path is a block device.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". The default value is to auto-select a filesystem if unspecified.
   * +optional
   *
   * @generated from field: optional string fsType = 2;
   */
  fsType: string;
};

/**
 * Describes the message k8s.io.api.core.v1.LocalVolumeSource.
 * Use `create(LocalVolumeSourceSchema)` to create a new message.
 */
export declare const LocalVolumeSourceSchema: GenMessage<LocalVolumeSource, {validType: LocalVolumeSourceValid}>;

/**
 * Represents an NFS mount that lasts the lifetime of a pod.
 * NFS volumes do not support ownership management or SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.NFSVolumeSource
 */
export declare type NFSVolumeSource = Message<"k8s.io.api.core.v1.NFSVolumeSource"> & {
  /**
   * server is the hostname or IP address of the NFS server.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @generated from field: optional string server = 1;
   */
  server: string;

  /**
   * path that is exported by the NFS server.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @generated from field: optional string path = 2;
   */
  path: string;

  /**
   * readOnly here will force the NFS export to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   * +optional
   *
   * @generated from field: optional bool readOnly = 3;
   */
  readOnly: boolean;
};

/**
 * Represents an NFS mount that lasts the lifetime of a pod.
 * NFS volumes do not support ownership management or SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.NFSVolumeSource
 */
export declare type NFSVolumeSourceValid = Message<"k8s.io.api.core.v1.NFSVolumeSource"> & {
  /**
   * server is the hostname or IP address of the NFS server.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @generated from field: optional string server = 1;
   */
  server: string;

  /**
   * path that is exported by the NFS server.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @generated from field: optional string path = 2;
   */
  path: string;

  /**
   * readOnly here will force the NFS export to be mounted with read-only permissions.
   * Defaults to false.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   * +optional
   *
   * @generated from field: optional bool readOnly = 3;
   */
  readOnly: boolean;
};

/**
 * Describes the message k8s.io.api.core.v1.NFSVolumeSource.
 * Use `create(NFSVolumeSourceSchema)` to create a new message.
 */
export declare const NFSVolumeSourceSchema: GenMessage<NFSVolumeSource, {validType: NFSVolumeSourceValid}>;

/**
 * Namespace provides a scope for Names.
 * Use of multiple namespaces is optional.
 *
 * @generated from message k8s.io.api.core.v1.Namespace
 */
export declare type Namespace = Message<"k8s.io.api.core.v1.Namespace"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMeta;

  /**
   * Spec defines the behavior of the Namespace.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.NamespaceSpec spec = 2;
   */
  spec?: NamespaceSpec;

  /**
   * Status describes the current status of a Namespace.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.NamespaceStatus status = 3;
   */
  status?: NamespaceStatus;
};

/**
 * Namespace provides a scope for Names.
 * Use of multiple namespaces is optional.
 *
 * @generated from message k8s.io.api.core.v1.Namespace
 */
export declare type NamespaceValid = Message<"k8s.io.api.core.v1.Namespace"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMetaValid;

  /**
   * Spec defines the behavior of the Namespace.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.NamespaceSpec spec = 2;
   */
  spec?: NamespaceSpecValid;

  /**
   * Status describes the current status of a Namespace.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.NamespaceStatus status = 3;
   */
  status?: NamespaceStatusValid;
};

/**
 * Describes the message k8s.io.api.core.v1.Namespace.
 * Use `create(NamespaceSchema)` to create a new message.
 */
export declare const NamespaceSchema: GenMessage<Namespace, {validType: NamespaceValid}>;

/**
 * NamespaceCondition contains details about state of namespace.
 *
 * @generated from message k8s.io.api.core.v1.NamespaceCondition
 */
export declare type NamespaceCondition = Message<"k8s.io.api.core.v1.NamespaceCondition"> & {
  /**
   * Type of namespace controller condition.
   *
   * @generated from field: optional string type = 1;
   */
  type: string;

  /**
   * Status of the condition, one of True, False, Unknown.
   *
   * @generated from field: optional string status = 2;
   */
  status: string;

  /**
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;
   */
  lastTransitionTime?: Time;

  /**
   * +optional
   *
   * @generated from field: optional string reason = 5;
   */
  reason: string;

  /**
   * +optional
   *
   * @generated from field: optional string message = 6;
   */
  message: string;
};

/**
 * NamespaceCondition contains details about state of namespace.
 *
 * @generated from message k8s.io.api.core.v1.NamespaceCondition
 */
export declare type NamespaceConditionValid = Message<"k8s.io.api.core.v1.NamespaceCondition"> & {
  /**
   * Type of namespace controller condition.
   *
   * @generated from field: optional string type = 1;
   */
  type: string;

  /**
   * Status of the condition, one of True, False, Unknown.
   *
   * @generated from field: optional string status = 2;
   */
  status: string;

  /**
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;
   */
  lastTransitionTime?: TimeValid;

  /**
   * +optional
   *
   * @generated from field: optional string reason = 5;
   */
  reason: string;

  /**
   * +optional
   *
   * @generated from field: optional string message = 6;
   */
  message: string;
};

/**
 * Describes the message k8s.io.api.core.v1.NamespaceCondition.
 * Use `create(NamespaceConditionSchema)` to create a new message.
 */
export declare const NamespaceConditionSchema: GenMessage<NamespaceCondition, {validType: NamespaceConditionValid}>;

/**
 * NamespaceList is a list of Namespaces.
 *
 * @generated from message k8s.io.api.core.v1.NamespaceList
 */
export declare type NamespaceList = Message<"k8s.io.api.core.v1.NamespaceList"> & {
  /**
   * Standard list metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMeta;

  /**
   * Items is the list of Namespace objects in the list.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @generated from field: repeated k8s.io.api.core.v1.Namespace items = 2;
   */
  items: Namespace[];
};

/**
 * NamespaceList is a list of Namespaces.
 *
 * @generated from message k8s.io.api.core.v1.NamespaceList
 */
export declare type NamespaceListValid = Message<"k8s.io.api.core.v1.NamespaceList"> & {
  /**
   * Standard list metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMetaValid;

  /**
   * Items is the list of Namespace objects in the list.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   *
   * @generated from field: repeated k8s.io.api.core.v1.Namespace items = 2;
   */
  items: NamespaceValid[];
};

/**
 * Describes the message k8s.io.api.core.v1.NamespaceList.
 * Use `create(NamespaceListSchema)` to create a new message.
 */
export declare const NamespaceListSchema: GenMessage<NamespaceList, {validType: NamespaceListValid}>;

/**
 * NamespaceSpec describes the attributes on a Namespace.
 *
 * @generated from message k8s.io.api.core.v1.NamespaceSpec
 */
export declare type NamespaceSpec = Message<"k8s.io.api.core.v1.NamespaceSpec"> & {
  /**
   * Finalizers is an opaque list of values that must be empty to permanently remove object from storage.
   * More info: https://kubernetes.io/docs/tasks/administer-cluster/namespaces/
   * +optional
   *
   * @generated from field: repeated string finalizers = 1;
   */
  finalizers: string[];
};

/**
 * NamespaceSpec describes the attributes on a Namespace.
 *
 * @generated from message k8s.io.api.core.v1.NamespaceSpec
 */
export declare type NamespaceSpecValid = Message<"k8s.io.api.core.v1.NamespaceSpec"> & {
  /**
   * Finalizers is an opaque list of values that must be empty to permanently remove object from storage.
   * More info: https://kubernetes.io/docs/tasks/administer-cluster/namespaces/
   * +optional
   *
   * @generated from field: repeated string finalizers = 1;
   */
  finalizers: string[];
};

/**
 * Describes the message k8s.io.api.core.v1.NamespaceSpec.
 * Use `create(NamespaceSpecSchema)` to create a new message.
 */
export declare const NamespaceSpecSchema: GenMessage<NamespaceSpec, {validType: NamespaceSpecValid}>;

/**
 * NamespaceStatus is information about the current status of a Namespace.
 *
 * @generated from message k8s.io.api.core.v1.NamespaceStatus
 */
export declare type NamespaceStatus = Message<"k8s.io.api.core.v1.NamespaceStatus"> & {
  /**
   * Phase is the current lifecycle phase of the namespace.
   * More info: https://kubernetes.io/docs/tasks/administer-cluster/namespaces/
   * +optional
   *
   * @generated from field: optional string phase = 1;
   */
  phase: string;

  /**
   * Represents the latest available observations of a namespace's current state.
   * +optional
   * +patchMergeKey=type
   * +patchStrategy=merge
   *
   * @generated from field: repeated k8s.io.api.core.v1.NamespaceCondition conditions = 2;
   */
  conditions: NamespaceCondition[];
};

/**
 * NamespaceStatus is information about the current status of a Namespace.
 *
 * @generated from message k8s.io.api.core.v1.NamespaceStatus
 */
export declare type NamespaceStatusValid = Message<"k8s.io.api.core.v1.NamespaceStatus"> & {
  /**
   * Phase is the current lifecycle phase of the namespace.
   * More info: https://kubernetes.io/docs/tasks/administer-cluster/namespaces/
   * +optional
   *
   * @generated from field: optional string phase = 1;
   */
  phase: string;

  /**
   * Represents the latest available observations of a namespace's current state.
   * +optional
   * +patchMergeKey=type
   * +patchStrategy=merge
   *
   * @generated from field: repeated k8s.io.api.core.v1.NamespaceCondition conditions = 2;
   */
  conditions: NamespaceConditionValid[];
};

/**
 * Describes the message k8s.io.api.core.v1.NamespaceStatus.
 * Use `create(NamespaceStatusSchema)` to create a new message.
 */
export declare const NamespaceStatusSchema: GenMessage<NamespaceStatus, {validType: NamespaceStatusValid}>;

/**
 * Node is a worker node in Kubernetes.
 * Each node will have a unique identifier in the cache (i.e. in etcd).
 *
 * @generated from message k8s.io.api.core.v1.Node
 */
export declare type Node = Message<"k8s.io.api.core.v1.Node"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMeta;

  /**
   * Spec defines the behavior of a node.
   * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.NodeSpec spec = 2;
   */
  spec?: NodeSpec;

  /**
   * Most recently observed status of the node.
   * Populated by the system.
   * Read-only.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.NodeStatus status = 3;
   */
  status?: NodeStatus;
};

/**
 * Node is a worker node in Kubernetes.
 * Each node will have a unique identifier in the cache (i.e. in etcd).
 *
 * @generated from message k8s.io.api.core.v1.Node
 */
export declare type NodeValid = Message<"k8s.io.api.core.v1.Node"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMetaValid;

  /**
   * Spec defines the behavior of a node.
   * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.NodeSpec spec = 2;
   */
  spec?: NodeSpecValid;

  /**
   * Most recently observed status of the node.
   * Populated by the system.
   * Read-only.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.NodeStatus status = 3;
   */
  status?: NodeStatusValid;
};

/**
 * Describes the message k8s.io.api.core.v1.Node.
 * Use `create(NodeSchema)` to create a new message.
 */
export declare const NodeSchema: GenMessage<Node, {validType: NodeValid}>;

/**
 * NodeAddress contains information for the node's address.
 *
 * @generated from message k8s.io.api.core.v1.NodeAddress
 */
export declare type NodeAddress = Message<"k8s.io.api.core.v1.NodeAddress"> & {
  /**
   * Node address type, one of Hostname, ExternalIP or InternalIP.
   *
   * @generated from field: optional string type = 1;
   */
  type: string;

  /**
   * The node address.
   *
   * @generated from field: optional string address = 2;
   */
  address: string;
};

/**
 * NodeAddress contains information for the node's address.
 *
 * @generated from message k8s.io.api.core.v1.NodeAddress
 */
export declare type NodeAddressValid = Message<"k8s.io.api.core.v1.NodeAddress"> & {
  /**
   * Node address type, one of Hostname, ExternalIP or InternalIP.
   *
   * @generated from field: optional string type = 1;
   */
  type: string;

  /**
   * The node address.
   *
   * @generated from field: optional string address = 2;
   */
  address: string;
};

/**
 * Describes the message k8s.io.api.core.v1.NodeAddress.
 * Use `create(NodeAddressSchema)` to create a new message.
 */
export declare const NodeAddressSchema: GenMessage<NodeAddress, {validType: NodeAddressValid}>;

/**
 * Node affinity is a group of node affinity scheduling rules.
 *
 * @generated from message k8s.io.api.core.v1.NodeAffinity
 */
export declare type NodeAffinity = Message<"k8s.io.api.core.v1.NodeAffinity"> & {
  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to an update), the system
   * may or may not try to eventually evict the pod from its node.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.NodeSelector requiredDuringSchedulingIgnoredDuringExecution = 1;
   */
  requiredDuringSchedulingIgnoredDuringExecution?: NodeSelector;

  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node matches the corresponding matchExpressions; the
   * node(s) with the highest sum are the most preferred.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.PreferredSchedulingTerm preferredDuringSchedulingIgnoredDuringExecution = 2;
   */
  preferredDuringSchedulingIgnoredDuringExecution: PreferredSchedulingTerm[];
};

/**
 * Node affinity is a group of node affinity scheduling rules.
 *
 * @generated from message k8s.io.api.core.v1.NodeAffinity
 */
export declare type NodeAffinityValid = Message<"k8s.io.api.core.v1.NodeAffinity"> & {
  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to an update), the system
   * may or may not try to eventually evict the pod from its node.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.NodeSelector requiredDuringSchedulingIgnoredDuringExecution = 1;
   */
  requiredDuringSchedulingIgnoredDuringExecution?: NodeSelectorValid;

  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node matches the corresponding matchExpressions; the
   * node(s) with the highest sum are the most preferred.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.PreferredSchedulingTerm preferredDuringSchedulingIgnoredDuringExecution = 2;
   */
  preferredDuringSchedulingIgnoredDuringExecution: PreferredSchedulingTermValid[];
};

/**
 * Describes the message k8s.io.api.core.v1.NodeAffinity.
 * Use `create(NodeAffinitySchema)` to create a new message.
 */
export declare const NodeAffinitySchema: GenMessage<NodeAffinity, {validType: NodeAffinityValid}>;

/**
 * NodeCondition contains condition information for a node.
 *
 * @generated from message k8s.io.api.core.v1.NodeCondition
 */
export declare type NodeCondition = Message<"k8s.io.api.core.v1.NodeCondition"> & {
  /**
   * Type of node condition.
   *
   * @generated from field: optional string type = 1;
   */
  type: string;

  /**
   * Status of the condition, one of True, False, Unknown.
   *
   * @generated from field: optional string status = 2;
   */
  status: string;

  /**
   * Last time we got an update on a given condition.
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastHeartbeatTime = 3;
   */
  lastHeartbeatTime?: Time;

  /**
   * Last time the condition transit from one status to another.
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;
   */
  lastTransitionTime?: Time;

  /**
   * (brief) reason for the condition's last transition.
   * +optional
   *
   * @generated from field: optional string reason = 5;
   */
  reason: string;

  /**
   * Human readable message indicating details about last transition.
   * +optional
   *
   * @generated from field: optional string message = 6;
   */
  message: string;
};

/**
 * NodeCondition contains condition information for a node.
 *
 * @generated from message k8s.io.api.core.v1.NodeCondition
 */
export declare type NodeConditionValid = Message<"k8s.io.api.core.v1.NodeCondition"> & {
  /**
   * Type of node condition.
   *
   * @generated from field: optional string type = 1;
   */
  type: string;

  /**
   * Status of the condition, one of True, False, Unknown.
   *
   * @generated from field: optional string status = 2;
   */
  status: string;

  /**
   * Last time we got an update on a given condition.
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastHeartbeatTime = 3;
   */
  lastHeartbeatTime?: TimeValid;

  /**
   * Last time the condition transit from one status to another.
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;
   */
  lastTransitionTime?: TimeValid;

  /**
   * (brief) reason for the condition's last transition.
   * +optional
   *
   * @generated from field: optional string reason = 5;
   */
  reason: string;

  /**
   * Human readable message indicating details about last transition.
   * +optional
   *
   * @generated from field: optional string message = 6;
   */
  message: string;
};

/**
 * Describes the message k8s.io.api.core.v1.NodeCondition.
 * Use `create(NodeConditionSchema)` to create a new message.
 */
export declare const NodeConditionSchema: GenMessage<NodeCondition, {validType: NodeConditionValid}>;

/**
 * NodeConfigSource specifies a source of node configuration. Exactly one subfield (excluding metadata) must be non-nil.
 * This API is deprecated since 1.22
 *
 * @generated from message k8s.io.api.core.v1.NodeConfigSource
 */
export declare type NodeConfigSource = Message<"k8s.io.api.core.v1.NodeConfigSource"> & {
  /**
   * ConfigMap is a reference to a Node's ConfigMap
   *
   * @generated from field: optional k8s.io.api.core.v1.ConfigMapNodeConfigSource configMap = 2;
   */
  configMap?: ConfigMapNodeConfigSource;
};

/**
 * NodeConfigSource specifies a source of node configuration. Exactly one subfield (excluding metadata) must be non-nil.
 * This API is deprecated since 1.22
 *
 * @generated from message k8s.io.api.core.v1.NodeConfigSource
 */
export declare type NodeConfigSourceValid = Message<"k8s.io.api.core.v1.NodeConfigSource"> & {
  /**
   * ConfigMap is a reference to a Node's ConfigMap
   *
   * @generated from field: optional k8s.io.api.core.v1.ConfigMapNodeConfigSource configMap = 2;
   */
  configMap?: ConfigMapNodeConfigSourceValid;
};

/**
 * Describes the message k8s.io.api.core.v1.NodeConfigSource.
 * Use `create(NodeConfigSourceSchema)` to create a new message.
 */
export declare const NodeConfigSourceSchema: GenMessage<NodeConfigSource, {validType: NodeConfigSourceValid}>;

/**
 * NodeConfigStatus describes the status of the config assigned by Node.Spec.ConfigSource.
 *
 * @generated from message k8s.io.api.core.v1.NodeConfigStatus
 */
export declare type NodeConfigStatus = Message<"k8s.io.api.core.v1.NodeConfigStatus"> & {
  /**
   * Assigned reports the checkpointed config the node will try to use.
   * When Node.Spec.ConfigSource is updated, the node checkpoints the associated
   * config payload to local disk, along with a record indicating intended
   * config. The node refers to this record to choose its config checkpoint, and
   * reports this record in Assigned. Assigned only updates in the status after
   * the record has been checkpointed to disk. When the Kubelet is restarted,
   * it tries to make the Assigned config the Active config by loading and
   * validating the checkpointed payload identified by Assigned.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.NodeConfigSource assigned = 1;
   */
  assigned?: NodeConfigSource;

  /**
   * Active reports the checkpointed config the node is actively using.
   * Active will represent either the current version of the Assigned config,
   * or the current LastKnownGood config, depending on whether attempting to use the
   * Assigned config results in an error.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.NodeConfigSource active = 2;
   */
  active?: NodeConfigSource;

  /**
   * LastKnownGood reports the checkpointed config the node will fall back to
   * when it encounters an error attempting to use the Assigned config.
   * The Assigned config becomes the LastKnownGood config when the node determines
   * that the Assigned config is stable and correct.
   * This is currently implemented as a 10-minute soak period starting when the local
   * record of Assigned config is updated. If the Assigned config is Active at the end
   * of this period, it becomes the LastKnownGood. Note that if Spec.ConfigSource is
   * reset to nil (use local defaults), the LastKnownGood is also immediately reset to nil,
   * because the local default config is always assumed good.
   * You should not make assumptions about the node's method of determining config stability
   * and correctness, as this may change or become configurable in the future.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.NodeConfigSource lastKnownGood = 3;
   */
  lastKnownGood?: NodeConfigSource;

  /**
   * Error describes any problems reconciling the Spec.ConfigSource to the Active config.
   * Errors may occur, for example, attempting to checkpoint Spec.ConfigSource to the local Assigned
   * record, attempting to checkpoint the payload associated with Spec.ConfigSource, attempting
   * to load or validate the Assigned config, etc.
   * Errors may occur at different points while syncing config. Earlier errors (e.g. download or
   * checkpointing errors) will not result in a rollback to LastKnownGood, and may resolve across
   * Kubelet retries. Later errors (e.g. loading or validating a checkpointed config) will result in
   * a rollback to LastKnownGood. In the latter case, it is usually possible to resolve the error
   * by fixing the config assigned in Spec.ConfigSource.
   * You can find additional information for debugging by searching the error message in the Kubelet log.
   * Error is a human-readable description of the error state; machines can check whether or not Error
   * is empty, but should not rely on the stability of the Error text across Kubelet versions.
   * +optional
   *
   * @generated from field: optional string error = 4;
   */
  error: string;
};

/**
 * NodeConfigStatus describes the status of the config assigned by Node.Spec.ConfigSource.
 *
 * @generated from message k8s.io.api.core.v1.NodeConfigStatus
 */
export declare type NodeConfigStatusValid = Message<"k8s.io.api.core.v1.NodeConfigStatus"> & {
  /**
   * Assigned reports the checkpointed config the node will try to use.
   * When Node.Spec.ConfigSource is updated, the node checkpoints the associated
   * config payload to local disk, along with a record indicating intended
   * config. The node refers to this record to choose its config checkpoint, and
   * reports this record in Assigned. Assigned only updates in the status after
   * the record has been checkpointed to disk. When the Kubelet is restarted,
   * it tries to make the Assigned config the Active config by loading and
   * validating the checkpointed payload identified by Assigned.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.NodeConfigSource assigned = 1;
   */
  assigned?: NodeConfigSourceValid;

  /**
   * Active reports the checkpointed config the node is actively using.
   * Active will represent either the current version of the Assigned config,
   * or the current LastKnownGood config, depending on whether attempting to use the
   * Assigned config results in an error.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.NodeConfigSource active = 2;
   */
  active?: NodeConfigSourceValid;

  /**
   * LastKnownGood reports the checkpointed config the node will fall back to
   * when it encounters an error attempting to use the Assigned config.
   * The Assigned config becomes the LastKnownGood config when the node determines
   * that the Assigned config is stable and correct.
   * This is currently implemented as a 10-minute soak period starting when the local
   * record of Assigned config is updated. If the Assigned config is Active at the end
   * of this period, it becomes the LastKnownGood. Note that if Spec.ConfigSource is
   * reset to nil (use local defaults), the LastKnownGood is also immediately reset to nil,
   * because the local default config is always assumed good.
   * You should not make assumptions about the node's method of determining config stability
   * and correctness, as this may change or become configurable in the future.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.NodeConfigSource lastKnownGood = 3;
   */
  lastKnownGood?: NodeConfigSourceValid;

  /**
   * Error describes any problems reconciling the Spec.ConfigSource to the Active config.
   * Errors may occur, for example, attempting to checkpoint Spec.ConfigSource to the local Assigned
   * record, attempting to checkpoint the payload associated with Spec.ConfigSource, attempting
   * to load or validate the Assigned config, etc.
   * Errors may occur at different points while syncing config. Earlier errors (e.g. download or
   * checkpointing errors) will not result in a rollback to LastKnownGood, and may resolve across
   * Kubelet retries. Later errors (e.g. loading or validating a checkpointed config) will result in
   * a rollback to LastKnownGood. In the latter case, it is usually possible to resolve the error
   * by fixing the config assigned in Spec.ConfigSource.
   * You can find additional information for debugging by searching the error message in the Kubelet log.
   * Error is a human-readable description of the error state; machines can check whether or not Error
   * is empty, but should not rely on the stability of the Error text across Kubelet versions.
   * +optional
   *
   * @generated from field: optional string error = 4;
   */
  error: string;
};

/**
 * Describes the message k8s.io.api.core.v1.NodeConfigStatus.
 * Use `create(NodeConfigStatusSchema)` to create a new message.
 */
export declare const NodeConfigStatusSchema: GenMessage<NodeConfigStatus, {validType: NodeConfigStatusValid}>;

/**
 * NodeDaemonEndpoints lists ports opened by daemons running on the Node.
 *
 * @generated from message k8s.io.api.core.v1.NodeDaemonEndpoints
 */
export declare type NodeDaemonEndpoints = Message<"k8s.io.api.core.v1.NodeDaemonEndpoints"> & {
  /**
   * Endpoint on which Kubelet is listening.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.DaemonEndpoint kubeletEndpoint = 1;
   */
  kubeletEndpoint?: DaemonEndpoint;
};

/**
 * NodeDaemonEndpoints lists ports opened by daemons running on the Node.
 *
 * @generated from message k8s.io.api.core.v1.NodeDaemonEndpoints
 */
export declare type NodeDaemonEndpointsValid = Message<"k8s.io.api.core.v1.NodeDaemonEndpoints"> & {
  /**
   * Endpoint on which Kubelet is listening.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.DaemonEndpoint kubeletEndpoint = 1;
   */
  kubeletEndpoint?: DaemonEndpointValid;
};

/**
 * Describes the message k8s.io.api.core.v1.NodeDaemonEndpoints.
 * Use `create(NodeDaemonEndpointsSchema)` to create a new message.
 */
export declare const NodeDaemonEndpointsSchema: GenMessage<NodeDaemonEndpoints, {validType: NodeDaemonEndpointsValid}>;

/**
 * NodeList is the whole list of all Nodes which have been registered with master.
 *
 * @generated from message k8s.io.api.core.v1.NodeList
 */
export declare type NodeList = Message<"k8s.io.api.core.v1.NodeList"> & {
  /**
   * Standard list metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMeta;

  /**
   * List of nodes
   *
   * @generated from field: repeated k8s.io.api.core.v1.Node items = 2;
   */
  items: Node[];
};

/**
 * NodeList is the whole list of all Nodes which have been registered with master.
 *
 * @generated from message k8s.io.api.core.v1.NodeList
 */
export declare type NodeListValid = Message<"k8s.io.api.core.v1.NodeList"> & {
  /**
   * Standard list metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMetaValid;

  /**
   * List of nodes
   *
   * @generated from field: repeated k8s.io.api.core.v1.Node items = 2;
   */
  items: NodeValid[];
};

/**
 * Describes the message k8s.io.api.core.v1.NodeList.
 * Use `create(NodeListSchema)` to create a new message.
 */
export declare const NodeListSchema: GenMessage<NodeList, {validType: NodeListValid}>;

/**
 * NodeProxyOptions is the query options to a Node's proxy call.
 *
 * @generated from message k8s.io.api.core.v1.NodeProxyOptions
 */
export declare type NodeProxyOptions = Message<"k8s.io.api.core.v1.NodeProxyOptions"> & {
  /**
   * Path is the URL path to use for the current proxy request to node.
   * +optional
   *
   * @generated from field: optional string path = 1;
   */
  path: string;
};

/**
 * NodeProxyOptions is the query options to a Node's proxy call.
 *
 * @generated from message k8s.io.api.core.v1.NodeProxyOptions
 */
export declare type NodeProxyOptionsValid = Message<"k8s.io.api.core.v1.NodeProxyOptions"> & {
  /**
   * Path is the URL path to use for the current proxy request to node.
   * +optional
   *
   * @generated from field: optional string path = 1;
   */
  path: string;
};

/**
 * Describes the message k8s.io.api.core.v1.NodeProxyOptions.
 * Use `create(NodeProxyOptionsSchema)` to create a new message.
 */
export declare const NodeProxyOptionsSchema: GenMessage<NodeProxyOptions, {validType: NodeProxyOptionsValid}>;

/**
 * NodeResources is an object for conveying resource information about a node.
 * see https://kubernetes.io/docs/concepts/architecture/nodes/#capacity for more details.
 *
 * @generated from message k8s.io.api.core.v1.NodeResources
 */
export declare type NodeResources = Message<"k8s.io.api.core.v1.NodeResources"> & {
  /**
   * Capacity represents the available resources of a node
   *
   * @generated from field: map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> capacity = 1;
   */
  capacity: { [key: string]: Quantity };
};

/**
 * NodeResources is an object for conveying resource information about a node.
 * see https://kubernetes.io/docs/concepts/architecture/nodes/#capacity for more details.
 *
 * @generated from message k8s.io.api.core.v1.NodeResources
 */
export declare type NodeResourcesValid = Message<"k8s.io.api.core.v1.NodeResources"> & {
  /**
   * Capacity represents the available resources of a node
   *
   * @generated from field: map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> capacity = 1;
   */
  capacity: { [key: string]: QuantityValid };
};

/**
 * Describes the message k8s.io.api.core.v1.NodeResources.
 * Use `create(NodeResourcesSchema)` to create a new message.
 */
export declare const NodeResourcesSchema: GenMessage<NodeResources, {validType: NodeResourcesValid}>;

/**
 * A node selector represents the union of the results of one or more label queries
 * over a set of nodes; that is, it represents the OR of the selectors represented
 * by the node selector terms.
 * +structType=atomic
 *
 * @generated from message k8s.io.api.core.v1.NodeSelector
 */
export declare type NodeSelector = Message<"k8s.io.api.core.v1.NodeSelector"> & {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @generated from field: repeated k8s.io.api.core.v1.NodeSelectorTerm nodeSelectorTerms = 1;
   */
  nodeSelectorTerms: NodeSelectorTerm[];
};

/**
 * A node selector represents the union of the results of one or more label queries
 * over a set of nodes; that is, it represents the OR of the selectors represented
 * by the node selector terms.
 * +structType=atomic
 *
 * @generated from message k8s.io.api.core.v1.NodeSelector
 */
export declare type NodeSelectorValid = Message<"k8s.io.api.core.v1.NodeSelector"> & {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @generated from field: repeated k8s.io.api.core.v1.NodeSelectorTerm nodeSelectorTerms = 1;
   */
  nodeSelectorTerms: NodeSelectorTermValid[];
};

/**
 * Describes the message k8s.io.api.core.v1.NodeSelector.
 * Use `create(NodeSelectorSchema)` to create a new message.
 */
export declare const NodeSelectorSchema: GenMessage<NodeSelector, {validType: NodeSelectorValid}>;

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @generated from message k8s.io.api.core.v1.NodeSelectorRequirement
 */
export declare type NodeSelectorRequirement = Message<"k8s.io.api.core.v1.NodeSelectorRequirement"> & {
  /**
   * The label key that the selector applies to.
   *
   * @generated from field: optional string key = 1;
   */
  key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @generated from field: optional string operator = 2;
   */
  operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   * +optional
   *
   * @generated from field: repeated string values = 3;
   */
  values: string[];
};

/**
 * A node selector requirement is a selector that contains values, a key, and an operator
 * that relates the key and values.
 *
 * @generated from message k8s.io.api.core.v1.NodeSelectorRequirement
 */
export declare type NodeSelectorRequirementValid = Message<"k8s.io.api.core.v1.NodeSelectorRequirement"> & {
  /**
   * The label key that the selector applies to.
   *
   * @generated from field: optional string key = 1;
   */
  key: string;

  /**
   * Represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @generated from field: optional string operator = 2;
   */
  operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. If the operator is Gt or Lt, the values
   * array must have a single element, which will be interpreted as an integer.
   * This array is replaced during a strategic merge patch.
   * +optional
   *
   * @generated from field: repeated string values = 3;
   */
  values: string[];
};

/**
 * Describes the message k8s.io.api.core.v1.NodeSelectorRequirement.
 * Use `create(NodeSelectorRequirementSchema)` to create a new message.
 */
export declare const NodeSelectorRequirementSchema: GenMessage<NodeSelectorRequirement, {validType: NodeSelectorRequirementValid}>;

/**
 * A null or empty node selector term matches no objects. The requirements of
 * them are ANDed.
 * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 * +structType=atomic
 *
 * @generated from message k8s.io.api.core.v1.NodeSelectorTerm
 */
export declare type NodeSelectorTerm = Message<"k8s.io.api.core.v1.NodeSelectorTerm"> & {
  /**
   * A list of node selector requirements by node's labels.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.NodeSelectorRequirement matchExpressions = 1;
   */
  matchExpressions: NodeSelectorRequirement[];

  /**
   * A list of node selector requirements by node's fields.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.NodeSelectorRequirement matchFields = 2;
   */
  matchFields: NodeSelectorRequirement[];
};

/**
 * A null or empty node selector term matches no objects. The requirements of
 * them are ANDed.
 * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 * +structType=atomic
 *
 * @generated from message k8s.io.api.core.v1.NodeSelectorTerm
 */
export declare type NodeSelectorTermValid = Message<"k8s.io.api.core.v1.NodeSelectorTerm"> & {
  /**
   * A list of node selector requirements by node's labels.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.NodeSelectorRequirement matchExpressions = 1;
   */
  matchExpressions: NodeSelectorRequirementValid[];

  /**
   * A list of node selector requirements by node's fields.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.NodeSelectorRequirement matchFields = 2;
   */
  matchFields: NodeSelectorRequirementValid[];
};

/**
 * Describes the message k8s.io.api.core.v1.NodeSelectorTerm.
 * Use `create(NodeSelectorTermSchema)` to create a new message.
 */
export declare const NodeSelectorTermSchema: GenMessage<NodeSelectorTerm, {validType: NodeSelectorTermValid}>;

/**
 * NodeSpec describes the attributes that a node is created with.
 *
 * @generated from message k8s.io.api.core.v1.NodeSpec
 */
export declare type NodeSpec = Message<"k8s.io.api.core.v1.NodeSpec"> & {
  /**
   * PodCIDR represents the pod IP range assigned to the node.
   * +optional
   *
   * @generated from field: optional string podCIDR = 1;
   */
  podCIDR: string;

  /**
   * podCIDRs represents the IP ranges assigned to the node for usage by Pods on that node. If this
   * field is specified, the 0th entry must match the podCIDR field. It may contain at most 1 value for
   * each of IPv4 and IPv6.
   * +optional
   * +patchStrategy=merge
   *
   * @generated from field: repeated string podCIDRs = 7;
   */
  podCIDRs: string[];

  /**
   * ID of the node assigned by the cloud provider in the format: <ProviderName>://<ProviderSpecificNodeID>
   * +optional
   *
   * @generated from field: optional string providerID = 3;
   */
  providerID: string;

  /**
   * Unschedulable controls node schedulability of new pods. By default, node is schedulable.
   * More info: https://kubernetes.io/docs/concepts/nodes/node/#manual-node-administration
   * +optional
   *
   * @generated from field: optional bool unschedulable = 4;
   */
  unschedulable: boolean;

  /**
   * If specified, the node's taints.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.Taint taints = 5;
   */
  taints: Taint[];

  /**
   * Deprecated: Previously used to specify the source of the node's configuration for the DynamicKubeletConfig feature. This feature is removed from Kubelets as of 1.24 and will be fully removed in 1.26.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.NodeConfigSource configSource = 6;
   */
  configSource?: NodeConfigSource;

  /**
   * Deprecated. Not all kubelets will set this field. Remove field after 1.13.
   * see: https://issues.k8s.io/61966
   * +optional
   *
   * @generated from field: optional string externalID = 2;
   */
  externalID: string;
};

/**
 * NodeSpec describes the attributes that a node is created with.
 *
 * @generated from message k8s.io.api.core.v1.NodeSpec
 */
export declare type NodeSpecValid = Message<"k8s.io.api.core.v1.NodeSpec"> & {
  /**
   * PodCIDR represents the pod IP range assigned to the node.
   * +optional
   *
   * @generated from field: optional string podCIDR = 1;
   */
  podCIDR: string;

  /**
   * podCIDRs represents the IP ranges assigned to the node for usage by Pods on that node. If this
   * field is specified, the 0th entry must match the podCIDR field. It may contain at most 1 value for
   * each of IPv4 and IPv6.
   * +optional
   * +patchStrategy=merge
   *
   * @generated from field: repeated string podCIDRs = 7;
   */
  podCIDRs: string[];

  /**
   * ID of the node assigned by the cloud provider in the format: <ProviderName>://<ProviderSpecificNodeID>
   * +optional
   *
   * @generated from field: optional string providerID = 3;
   */
  providerID: string;

  /**
   * Unschedulable controls node schedulability of new pods. By default, node is schedulable.
   * More info: https://kubernetes.io/docs/concepts/nodes/node/#manual-node-administration
   * +optional
   *
   * @generated from field: optional bool unschedulable = 4;
   */
  unschedulable: boolean;

  /**
   * If specified, the node's taints.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.Taint taints = 5;
   */
  taints: TaintValid[];

  /**
   * Deprecated: Previously used to specify the source of the node's configuration for the DynamicKubeletConfig feature. This feature is removed from Kubelets as of 1.24 and will be fully removed in 1.26.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.NodeConfigSource configSource = 6;
   */
  configSource?: NodeConfigSourceValid;

  /**
   * Deprecated. Not all kubelets will set this field. Remove field after 1.13.
   * see: https://issues.k8s.io/61966
   * +optional
   *
   * @generated from field: optional string externalID = 2;
   */
  externalID: string;
};

/**
 * Describes the message k8s.io.api.core.v1.NodeSpec.
 * Use `create(NodeSpecSchema)` to create a new message.
 */
export declare const NodeSpecSchema: GenMessage<NodeSpec, {validType: NodeSpecValid}>;

/**
 * NodeStatus is information about the current status of a node.
 *
 * @generated from message k8s.io.api.core.v1.NodeStatus
 */
export declare type NodeStatus = Message<"k8s.io.api.core.v1.NodeStatus"> & {
  /**
   * Capacity represents the total resources of a node.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
   * +optional
   *
   * @generated from field: map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> capacity = 1;
   */
  capacity: { [key: string]: Quantity };

  /**
   * Allocatable represents the resources of a node that are available for scheduling.
   * Defaults to Capacity.
   * +optional
   *
   * @generated from field: map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> allocatable = 2;
   */
  allocatable: { [key: string]: Quantity };

  /**
   * NodePhase is the recently observed lifecycle phase of the node.
   * More info: https://kubernetes.io/docs/concepts/nodes/node/#phase
   * The field is never populated, and now is deprecated.
   * +optional
   *
   * @generated from field: optional string phase = 3;
   */
  phase: string;

  /**
   * Conditions is an array of current observed node conditions.
   * More info: https://kubernetes.io/docs/concepts/nodes/node/#condition
   * +optional
   * +patchMergeKey=type
   * +patchStrategy=merge
   *
   * @generated from field: repeated k8s.io.api.core.v1.NodeCondition conditions = 4;
   */
  conditions: NodeCondition[];

  /**
   * List of addresses reachable to the node.
   * Queried from cloud provider, if available.
   * More info: https://kubernetes.io/docs/concepts/nodes/node/#addresses
   * Note: This field is declared as mergeable, but the merge key is not sufficiently
   * unique, which can cause data corruption when it is merged. Callers should instead
   * use a full-replacement patch. See http://pr.k8s.io/79391 for an example.
   * +optional
   * +patchMergeKey=type
   * +patchStrategy=merge
   *
   * @generated from field: repeated k8s.io.api.core.v1.NodeAddress addresses = 5;
   */
  addresses: NodeAddress[];

  /**
   * Endpoints of daemons running on the Node.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.NodeDaemonEndpoints daemonEndpoints = 6;
   */
  daemonEndpoints?: NodeDaemonEndpoints;

  /**
   * Set of ids/uuids to uniquely identify the node.
   * More info: https://kubernetes.io/docs/concepts/nodes/node/#info
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.NodeSystemInfo nodeInfo = 7;
   */
  nodeInfo?: NodeSystemInfo;

  /**
   * List of container images on this node
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.ContainerImage images = 8;
   */
  images: ContainerImage[];

  /**
   * List of attachable volumes in use (mounted) by the node.
   * +optional
   *
   * @generated from field: repeated string volumesInUse = 9;
   */
  volumesInUse: string[];

  /**
   * List of volumes that are attached to the node.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.AttachedVolume volumesAttached = 10;
   */
  volumesAttached: AttachedVolume[];

  /**
   * Status of the config assigned to the node via the dynamic Kubelet config feature.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.NodeConfigStatus config = 11;
   */
  config?: NodeConfigStatus;
};

/**
 * NodeStatus is information about the current status of a node.
 *
 * @generated from message k8s.io.api.core.v1.NodeStatus
 */
export declare type NodeStatusValid = Message<"k8s.io.api.core.v1.NodeStatus"> & {
  /**
   * Capacity represents the total resources of a node.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
   * +optional
   *
   * @generated from field: map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> capacity = 1;
   */
  capacity: { [key: string]: QuantityValid };

  /**
   * Allocatable represents the resources of a node that are available for scheduling.
   * Defaults to Capacity.
   * +optional
   *
   * @generated from field: map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> allocatable = 2;
   */
  allocatable: { [key: string]: QuantityValid };

  /**
   * NodePhase is the recently observed lifecycle phase of the node.
   * More info: https://kubernetes.io/docs/concepts/nodes/node/#phase
   * The field is never populated, and now is deprecated.
   * +optional
   *
   * @generated from field: optional string phase = 3;
   */
  phase: string;

  /**
   * Conditions is an array of current observed node conditions.
   * More info: https://kubernetes.io/docs/concepts/nodes/node/#condition
   * +optional
   * +patchMergeKey=type
   * +patchStrategy=merge
   *
   * @generated from field: repeated k8s.io.api.core.v1.NodeCondition conditions = 4;
   */
  conditions: NodeConditionValid[];

  /**
   * List of addresses reachable to the node.
   * Queried from cloud provider, if available.
   * More info: https://kubernetes.io/docs/concepts/nodes/node/#addresses
   * Note: This field is declared as mergeable, but the merge key is not sufficiently
   * unique, which can cause data corruption when it is merged. Callers should instead
   * use a full-replacement patch. See http://pr.k8s.io/79391 for an example.
   * +optional
   * +patchMergeKey=type
   * +patchStrategy=merge
   *
   * @generated from field: repeated k8s.io.api.core.v1.NodeAddress addresses = 5;
   */
  addresses: NodeAddressValid[];

  /**
   * Endpoints of daemons running on the Node.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.NodeDaemonEndpoints daemonEndpoints = 6;
   */
  daemonEndpoints?: NodeDaemonEndpointsValid;

  /**
   * Set of ids/uuids to uniquely identify the node.
   * More info: https://kubernetes.io/docs/concepts/nodes/node/#info
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.NodeSystemInfo nodeInfo = 7;
   */
  nodeInfo?: NodeSystemInfoValid;

  /**
   * List of container images on this node
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.ContainerImage images = 8;
   */
  images: ContainerImageValid[];

  /**
   * List of attachable volumes in use (mounted) by the node.
   * +optional
   *
   * @generated from field: repeated string volumesInUse = 9;
   */
  volumesInUse: string[];

  /**
   * List of volumes that are attached to the node.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.AttachedVolume volumesAttached = 10;
   */
  volumesAttached: AttachedVolumeValid[];

  /**
   * Status of the config assigned to the node via the dynamic Kubelet config feature.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.NodeConfigStatus config = 11;
   */
  config?: NodeConfigStatusValid;
};

/**
 * Describes the message k8s.io.api.core.v1.NodeStatus.
 * Use `create(NodeStatusSchema)` to create a new message.
 */
export declare const NodeStatusSchema: GenMessage<NodeStatus, {validType: NodeStatusValid}>;

/**
 * NodeSystemInfo is a set of ids/uuids to uniquely identify the node.
 *
 * @generated from message k8s.io.api.core.v1.NodeSystemInfo
 */
export declare type NodeSystemInfo = Message<"k8s.io.api.core.v1.NodeSystemInfo"> & {
  /**
   * MachineID reported by the node. For unique machine identification
   * in the cluster this field is preferred. Learn more from man(5)
   * machine-id: http://man7.org/linux/man-pages/man5/machine-id.5.html
   *
   * @generated from field: optional string machineID = 1;
   */
  machineID: string;

  /**
   * SystemUUID reported by the node. For unique machine identification
   * MachineID is preferred. This field is specific to Red Hat hosts
   * https://access.redhat.com/documentation/en-us/red_hat_subscription_management/1/html/rhsm/uuid
   *
   * @generated from field: optional string systemUUID = 2;
   */
  systemUUID: string;

  /**
   * Boot ID reported by the node.
   *
   * @generated from field: optional string bootID = 3;
   */
  bootID: string;

  /**
   * Kernel Version reported by the node from 'uname -r' (e.g. 3.16.0-0.bpo.4-amd64).
   *
   * @generated from field: optional string kernelVersion = 4;
   */
  kernelVersion: string;

  /**
   * OS Image reported by the node from /etc/os-release (e.g. Debian GNU/Linux 7 (wheezy)).
   *
   * @generated from field: optional string osImage = 5;
   */
  osImage: string;

  /**
   * ContainerRuntime Version reported by the node through runtime remote API (e.g. docker://1.5.0).
   *
   * @generated from field: optional string containerRuntimeVersion = 6;
   */
  containerRuntimeVersion: string;

  /**
   * Kubelet Version reported by the node.
   *
   * @generated from field: optional string kubeletVersion = 7;
   */
  kubeletVersion: string;

  /**
   * KubeProxy Version reported by the node.
   *
   * @generated from field: optional string kubeProxyVersion = 8;
   */
  kubeProxyVersion: string;

  /**
   * The Operating System reported by the node
   *
   * @generated from field: optional string operatingSystem = 9;
   */
  operatingSystem: string;

  /**
   * The Architecture reported by the node
   *
   * @generated from field: optional string architecture = 10;
   */
  architecture: string;
};

/**
 * NodeSystemInfo is a set of ids/uuids to uniquely identify the node.
 *
 * @generated from message k8s.io.api.core.v1.NodeSystemInfo
 */
export declare type NodeSystemInfoValid = Message<"k8s.io.api.core.v1.NodeSystemInfo"> & {
  /**
   * MachineID reported by the node. For unique machine identification
   * in the cluster this field is preferred. Learn more from man(5)
   * machine-id: http://man7.org/linux/man-pages/man5/machine-id.5.html
   *
   * @generated from field: optional string machineID = 1;
   */
  machineID: string;

  /**
   * SystemUUID reported by the node. For unique machine identification
   * MachineID is preferred. This field is specific to Red Hat hosts
   * https://access.redhat.com/documentation/en-us/red_hat_subscription_management/1/html/rhsm/uuid
   *
   * @generated from field: optional string systemUUID = 2;
   */
  systemUUID: string;

  /**
   * Boot ID reported by the node.
   *
   * @generated from field: optional string bootID = 3;
   */
  bootID: string;

  /**
   * Kernel Version reported by the node from 'uname -r' (e.g. 3.16.0-0.bpo.4-amd64).
   *
   * @generated from field: optional string kernelVersion = 4;
   */
  kernelVersion: string;

  /**
   * OS Image reported by the node from /etc/os-release (e.g. Debian GNU/Linux 7 (wheezy)).
   *
   * @generated from field: optional string osImage = 5;
   */
  osImage: string;

  /**
   * ContainerRuntime Version reported by the node through runtime remote API (e.g. docker://1.5.0).
   *
   * @generated from field: optional string containerRuntimeVersion = 6;
   */
  containerRuntimeVersion: string;

  /**
   * Kubelet Version reported by the node.
   *
   * @generated from field: optional string kubeletVersion = 7;
   */
  kubeletVersion: string;

  /**
   * KubeProxy Version reported by the node.
   *
   * @generated from field: optional string kubeProxyVersion = 8;
   */
  kubeProxyVersion: string;

  /**
   * The Operating System reported by the node
   *
   * @generated from field: optional string operatingSystem = 9;
   */
  operatingSystem: string;

  /**
   * The Architecture reported by the node
   *
   * @generated from field: optional string architecture = 10;
   */
  architecture: string;
};

/**
 * Describes the message k8s.io.api.core.v1.NodeSystemInfo.
 * Use `create(NodeSystemInfoSchema)` to create a new message.
 */
export declare const NodeSystemInfoSchema: GenMessage<NodeSystemInfo, {validType: NodeSystemInfoValid}>;

/**
 * ObjectFieldSelector selects an APIVersioned field of an object.
 * +structType=atomic
 *
 * @generated from message k8s.io.api.core.v1.ObjectFieldSelector
 */
export declare type ObjectFieldSelector = Message<"k8s.io.api.core.v1.ObjectFieldSelector"> & {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   * +optional
   *
   * @generated from field: optional string apiVersion = 1;
   */
  apiVersion: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @generated from field: optional string fieldPath = 2;
   */
  fieldPath: string;
};

/**
 * ObjectFieldSelector selects an APIVersioned field of an object.
 * +structType=atomic
 *
 * @generated from message k8s.io.api.core.v1.ObjectFieldSelector
 */
export declare type ObjectFieldSelectorValid = Message<"k8s.io.api.core.v1.ObjectFieldSelector"> & {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   * +optional
   *
   * @generated from field: optional string apiVersion = 1;
   */
  apiVersion: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @generated from field: optional string fieldPath = 2;
   */
  fieldPath: string;
};

/**
 * Describes the message k8s.io.api.core.v1.ObjectFieldSelector.
 * Use `create(ObjectFieldSelectorSchema)` to create a new message.
 */
export declare const ObjectFieldSelectorSchema: GenMessage<ObjectFieldSelector, {validType: ObjectFieldSelectorValid}>;

/**
 * ObjectReference contains enough information to let you inspect or modify the referred object.
 * ---
 * New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs.
 *  1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage.
 *  2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular
 *     restrictions like, "must refer only to types A and B" or "UID not honored" or "name must be restricted".
 *     Those cannot be well described when embedded.
 *  3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen.
 *  4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity
 *     during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple
 *     and the version of the actual struct is irrelevant.
 *  5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type
 *     will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control.
 * Instead of using this type, create a locally provided and used type that is well-focused on your reference.
 * For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .
 * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
 * +structType=atomic
 *
 * @generated from message k8s.io.api.core.v1.ObjectReference
 */
export declare type ObjectReference = Message<"k8s.io.api.core.v1.ObjectReference"> & {
  /**
   * Kind of the referent.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   * +optional
   *
   * @generated from field: optional string kind = 1;
   */
  kind: string;

  /**
   * Namespace of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   * +optional
   *
   * @generated from field: optional string namespace = 2;
   */
  namespace: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * +optional
   *
   * @generated from field: optional string name = 3;
   */
  name: string;

  /**
   * UID of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
   * +optional
   *
   * @generated from field: optional string uid = 4;
   */
  uid: string;

  /**
   * API version of the referent.
   * +optional
   *
   * @generated from field: optional string apiVersion = 5;
   */
  apiVersion: string;

  /**
   * Specific resourceVersion to which this reference is made, if any.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
   * +optional
   *
   * @generated from field: optional string resourceVersion = 6;
   */
  resourceVersion: string;

  /**
   * If referring to a piece of an object instead of an entire object, this string
   * should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].
   * For example, if the object reference is to a container within a pod, this would take on a value like:
   * "spec.containers{name}" (where "name" refers to the name of the container that triggered
   * the event) or if no container name is specified "spec.containers[2]" (container with
   * index 2 in this pod). This syntax is chosen only to have some well-defined way of
   * referencing a part of an object.
   * TODO: this design is not final and this field is subject to change in the future.
   * +optional
   *
   * @generated from field: optional string fieldPath = 7;
   */
  fieldPath: string;
};

/**
 * ObjectReference contains enough information to let you inspect or modify the referred object.
 * ---
 * New uses of this type are discouraged because of difficulty describing its usage when embedded in APIs.
 *  1. Ignored fields.  It includes many fields which are not generally honored.  For instance, ResourceVersion and FieldPath are both very rarely valid in actual usage.
 *  2. Invalid usage help.  It is impossible to add specific help for individual usage.  In most embedded usages, there are particular
 *     restrictions like, "must refer only to types A and B" or "UID not honored" or "name must be restricted".
 *     Those cannot be well described when embedded.
 *  3. Inconsistent validation.  Because the usages are different, the validation rules are different by usage, which makes it hard for users to predict what will happen.
 *  4. The fields are both imprecise and overly precise.  Kind is not a precise mapping to a URL. This can produce ambiguity
 *     during interpretation and require a REST mapping.  In most cases, the dependency is on the group,resource tuple
 *     and the version of the actual struct is irrelevant.
 *  5. We cannot easily change it.  Because this type is embedded in many locations, updates to this type
 *     will affect numerous schemas.  Don't make new APIs embed an underspecified API type they do not control.
 * Instead of using this type, create a locally provided and used type that is well-focused on your reference.
 * For example, ServiceReferences for admission registration: https://github.com/kubernetes/api/blob/release-1.17/admissionregistration/v1/types.go#L533 .
 * +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
 * +structType=atomic
 *
 * @generated from message k8s.io.api.core.v1.ObjectReference
 */
export declare type ObjectReferenceValid = Message<"k8s.io.api.core.v1.ObjectReference"> & {
  /**
   * Kind of the referent.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   * +optional
   *
   * @generated from field: optional string kind = 1;
   */
  kind: string;

  /**
   * Namespace of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
   * +optional
   *
   * @generated from field: optional string namespace = 2;
   */
  namespace: string;

  /**
   * Name of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   * +optional
   *
   * @generated from field: optional string name = 3;
   */
  name: string;

  /**
   * UID of the referent.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
   * +optional
   *
   * @generated from field: optional string uid = 4;
   */
  uid: string;

  /**
   * API version of the referent.
   * +optional
   *
   * @generated from field: optional string apiVersion = 5;
   */
  apiVersion: string;

  /**
   * Specific resourceVersion to which this reference is made, if any.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
   * +optional
   *
   * @generated from field: optional string resourceVersion = 6;
   */
  resourceVersion: string;

  /**
   * If referring to a piece of an object instead of an entire object, this string
   * should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].
   * For example, if the object reference is to a container within a pod, this would take on a value like:
   * "spec.containers{name}" (where "name" refers to the name of the container that triggered
   * the event) or if no container name is specified "spec.containers[2]" (container with
   * index 2 in this pod). This syntax is chosen only to have some well-defined way of
   * referencing a part of an object.
   * TODO: this design is not final and this field is subject to change in the future.
   * +optional
   *
   * @generated from field: optional string fieldPath = 7;
   */
  fieldPath: string;
};

/**
 * Describes the message k8s.io.api.core.v1.ObjectReference.
 * Use `create(ObjectReferenceSchema)` to create a new message.
 */
export declare const ObjectReferenceSchema: GenMessage<ObjectReference, {validType: ObjectReferenceValid}>;

/**
 * PersistentVolume (PV) is a storage resource provisioned by an administrator.
 * It is analogous to a node.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes
 *
 * @generated from message k8s.io.api.core.v1.PersistentVolume
 */
export declare type PersistentVolume = Message<"k8s.io.api.core.v1.PersistentVolume"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMeta;

  /**
   * spec defines a specification of a persistent volume owned by the cluster.
   * Provisioned by an administrator.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistent-volumes
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.PersistentVolumeSpec spec = 2;
   */
  spec?: PersistentVolumeSpec;

  /**
   * status represents the current information/status for the persistent volume.
   * Populated by the system.
   * Read-only.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistent-volumes
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.PersistentVolumeStatus status = 3;
   */
  status?: PersistentVolumeStatus;
};

/**
 * PersistentVolume (PV) is a storage resource provisioned by an administrator.
 * It is analogous to a node.
 * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes
 *
 * @generated from message k8s.io.api.core.v1.PersistentVolume
 */
export declare type PersistentVolumeValid = Message<"k8s.io.api.core.v1.PersistentVolume"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMetaValid;

  /**
   * spec defines a specification of a persistent volume owned by the cluster.
   * Provisioned by an administrator.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistent-volumes
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.PersistentVolumeSpec spec = 2;
   */
  spec?: PersistentVolumeSpecValid;

  /**
   * status represents the current information/status for the persistent volume.
   * Populated by the system.
   * Read-only.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistent-volumes
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.PersistentVolumeStatus status = 3;
   */
  status?: PersistentVolumeStatusValid;
};

/**
 * Describes the message k8s.io.api.core.v1.PersistentVolume.
 * Use `create(PersistentVolumeSchema)` to create a new message.
 */
export declare const PersistentVolumeSchema: GenMessage<PersistentVolume, {validType: PersistentVolumeValid}>;

/**
 * PersistentVolumeClaim is a user's request for and claim to a persistent volume
 *
 * @generated from message k8s.io.api.core.v1.PersistentVolumeClaim
 */
export declare type PersistentVolumeClaim = Message<"k8s.io.api.core.v1.PersistentVolumeClaim"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMeta;

  /**
   * spec defines the desired characteristics of a volume requested by a pod author.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.PersistentVolumeClaimSpec spec = 2;
   */
  spec?: PersistentVolumeClaimSpec;

  /**
   * status represents the current information/status of a persistent volume claim.
   * Read-only.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.PersistentVolumeClaimStatus status = 3;
   */
  status?: PersistentVolumeClaimStatus;
};

/**
 * PersistentVolumeClaim is a user's request for and claim to a persistent volume
 *
 * @generated from message k8s.io.api.core.v1.PersistentVolumeClaim
 */
export declare type PersistentVolumeClaimValid = Message<"k8s.io.api.core.v1.PersistentVolumeClaim"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMetaValid;

  /**
   * spec defines the desired characteristics of a volume requested by a pod author.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.PersistentVolumeClaimSpec spec = 2;
   */
  spec?: PersistentVolumeClaimSpecValid;

  /**
   * status represents the current information/status of a persistent volume claim.
   * Read-only.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.PersistentVolumeClaimStatus status = 3;
   */
  status?: PersistentVolumeClaimStatusValid;
};

/**
 * Describes the message k8s.io.api.core.v1.PersistentVolumeClaim.
 * Use `create(PersistentVolumeClaimSchema)` to create a new message.
 */
export declare const PersistentVolumeClaimSchema: GenMessage<PersistentVolumeClaim, {validType: PersistentVolumeClaimValid}>;

/**
 * PersistentVolumeClaimCondition contails details about state of pvc
 *
 * @generated from message k8s.io.api.core.v1.PersistentVolumeClaimCondition
 */
export declare type PersistentVolumeClaimCondition = Message<"k8s.io.api.core.v1.PersistentVolumeClaimCondition"> & {
  /**
   * @generated from field: optional string type = 1;
   */
  type: string;

  /**
   * @generated from field: optional string status = 2;
   */
  status: string;

  /**
   * lastProbeTime is the time we probed the condition.
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastProbeTime = 3;
   */
  lastProbeTime?: Time;

  /**
   * lastTransitionTime is the time the condition transitioned from one status to another.
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;
   */
  lastTransitionTime?: Time;

  /**
   * reason is a unique, this should be a short, machine understandable string that gives the reason
   * for condition's last transition. If it reports "ResizeStarted" that means the underlying
   * persistent volume is being resized.
   * +optional
   *
   * @generated from field: optional string reason = 5;
   */
  reason: string;

  /**
   * message is the human-readable message indicating details about last transition.
   * +optional
   *
   * @generated from field: optional string message = 6;
   */
  message: string;
};

/**
 * PersistentVolumeClaimCondition contails details about state of pvc
 *
 * @generated from message k8s.io.api.core.v1.PersistentVolumeClaimCondition
 */
export declare type PersistentVolumeClaimConditionValid = Message<"k8s.io.api.core.v1.PersistentVolumeClaimCondition"> & {
  /**
   * @generated from field: optional string type = 1;
   */
  type: string;

  /**
   * @generated from field: optional string status = 2;
   */
  status: string;

  /**
   * lastProbeTime is the time we probed the condition.
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastProbeTime = 3;
   */
  lastProbeTime?: TimeValid;

  /**
   * lastTransitionTime is the time the condition transitioned from one status to another.
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;
   */
  lastTransitionTime?: TimeValid;

  /**
   * reason is a unique, this should be a short, machine understandable string that gives the reason
   * for condition's last transition. If it reports "ResizeStarted" that means the underlying
   * persistent volume is being resized.
   * +optional
   *
   * @generated from field: optional string reason = 5;
   */
  reason: string;

  /**
   * message is the human-readable message indicating details about last transition.
   * +optional
   *
   * @generated from field: optional string message = 6;
   */
  message: string;
};

/**
 * Describes the message k8s.io.api.core.v1.PersistentVolumeClaimCondition.
 * Use `create(PersistentVolumeClaimConditionSchema)` to create a new message.
 */
export declare const PersistentVolumeClaimConditionSchema: GenMessage<PersistentVolumeClaimCondition, {validType: PersistentVolumeClaimConditionValid}>;

/**
 * PersistentVolumeClaimList is a list of PersistentVolumeClaim items.
 *
 * @generated from message k8s.io.api.core.v1.PersistentVolumeClaimList
 */
export declare type PersistentVolumeClaimList = Message<"k8s.io.api.core.v1.PersistentVolumeClaimList"> & {
  /**
   * Standard list metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMeta;

  /**
   * items is a list of persistent volume claims.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @generated from field: repeated k8s.io.api.core.v1.PersistentVolumeClaim items = 2;
   */
  items: PersistentVolumeClaim[];
};

/**
 * PersistentVolumeClaimList is a list of PersistentVolumeClaim items.
 *
 * @generated from message k8s.io.api.core.v1.PersistentVolumeClaimList
 */
export declare type PersistentVolumeClaimListValid = Message<"k8s.io.api.core.v1.PersistentVolumeClaimList"> & {
  /**
   * Standard list metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMetaValid;

  /**
   * items is a list of persistent volume claims.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @generated from field: repeated k8s.io.api.core.v1.PersistentVolumeClaim items = 2;
   */
  items: PersistentVolumeClaimValid[];
};

/**
 * Describes the message k8s.io.api.core.v1.PersistentVolumeClaimList.
 * Use `create(PersistentVolumeClaimListSchema)` to create a new message.
 */
export declare const PersistentVolumeClaimListSchema: GenMessage<PersistentVolumeClaimList, {validType: PersistentVolumeClaimListValid}>;

/**
 * PersistentVolumeClaimSpec describes the common attributes of storage devices
 * and allows a Source for provider-specific attributes
 *
 * @generated from message k8s.io.api.core.v1.PersistentVolumeClaimSpec
 */
export declare type PersistentVolumeClaimSpec = Message<"k8s.io.api.core.v1.PersistentVolumeClaimSpec"> & {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   * +optional
   *
   * @generated from field: repeated string accessModes = 1;
   */
  accessModes: string[];

  /**
   * selector is a label query over volumes to consider for binding.
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 4;
   */
  selector?: LabelSelector;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ResourceRequirements resources = 2;
   */
  resources?: ResourceRequirements;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   * +optional
   *
   * @generated from field: optional string volumeName = 3;
   */
  volumeName: string;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   * +optional
   *
   * @generated from field: optional string storageClassName = 5;
   */
  storageClassName: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   * +optional
   *
   * @generated from field: optional string volumeMode = 6;
   */
  volumeMode: string;

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * If the AnyVolumeDataSource feature gate is enabled, this field will always have
   * the same contents as the DataSourceRef field.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.TypedLocalObjectReference dataSource = 7;
   */
  dataSource?: TypedLocalObjectReference;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any local object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the DataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, both fields (DataSource and DataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * There are two important differences between DataSource and DataSourceRef:
   * * While DataSource only allows two specific types of objects, DataSourceRef
   *   allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While DataSource ignores disallowed values (dropping them), DataSourceRef
   *   preserves all values, and generates an error if a disallowed value is
   *   specified.
   * (Alpha) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.TypedLocalObjectReference dataSourceRef = 8;
   */
  dataSourceRef?: TypedLocalObjectReference;
};

/**
 * PersistentVolumeClaimSpec describes the common attributes of storage devices
 * and allows a Source for provider-specific attributes
 *
 * @generated from message k8s.io.api.core.v1.PersistentVolumeClaimSpec
 */
export declare type PersistentVolumeClaimSpecValid = Message<"k8s.io.api.core.v1.PersistentVolumeClaimSpec"> & {
  /**
   * accessModes contains the desired access modes the volume should have.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   * +optional
   *
   * @generated from field: repeated string accessModes = 1;
   */
  accessModes: string[];

  /**
   * selector is a label query over volumes to consider for binding.
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 4;
   */
  selector?: LabelSelectorValid;

  /**
   * resources represents the minimum resources the volume should have.
   * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
   * that are lower than previous value but must still be higher than capacity recorded in the
   * status field of the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ResourceRequirements resources = 2;
   */
  resources?: ResourceRequirementsValid;

  /**
   * volumeName is the binding reference to the PersistentVolume backing this claim.
   * +optional
   *
   * @generated from field: optional string volumeName = 3;
   */
  volumeName: string;

  /**
   * storageClassName is the name of the StorageClass required by the claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   * +optional
   *
   * @generated from field: optional string storageClassName = 5;
   */
  storageClassName: string;

  /**
   * volumeMode defines what type of volume is required by the claim.
   * Value of Filesystem is implied when not included in claim spec.
   * +optional
   *
   * @generated from field: optional string volumeMode = 6;
   */
  volumeMode: string;

  /**
   * dataSource field can be used to specify either:
   * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
   * * An existing PVC (PersistentVolumeClaim)
   * If the provisioner or an external controller can support the specified data source,
   * it will create a new volume based on the contents of the specified data source.
   * If the AnyVolumeDataSource feature gate is enabled, this field will always have
   * the same contents as the DataSourceRef field.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.TypedLocalObjectReference dataSource = 7;
   */
  dataSource?: TypedLocalObjectReferenceValid;

  /**
   * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
   * volume is desired. This may be any local object from a non-empty API group (non
   * core object) or a PersistentVolumeClaim object.
   * When this field is specified, volume binding will only succeed if the type of
   * the specified object matches some installed volume populator or dynamic
   * provisioner.
   * This field will replace the functionality of the DataSource field and as such
   * if both fields are non-empty, they must have the same value. For backwards
   * compatibility, both fields (DataSource and DataSourceRef) will be set to the same
   * value automatically if one of them is empty and the other is non-empty.
   * There are two important differences between DataSource and DataSourceRef:
   * * While DataSource only allows two specific types of objects, DataSourceRef
   *   allows any non-core object, as well as PersistentVolumeClaim objects.
   * * While DataSource ignores disallowed values (dropping them), DataSourceRef
   *   preserves all values, and generates an error if a disallowed value is
   *   specified.
   * (Alpha) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.TypedLocalObjectReference dataSourceRef = 8;
   */
  dataSourceRef?: TypedLocalObjectReferenceValid;
};

/**
 * Describes the message k8s.io.api.core.v1.PersistentVolumeClaimSpec.
 * Use `create(PersistentVolumeClaimSpecSchema)` to create a new message.
 */
export declare const PersistentVolumeClaimSpecSchema: GenMessage<PersistentVolumeClaimSpec, {validType: PersistentVolumeClaimSpecValid}>;

/**
 * PersistentVolumeClaimStatus is the current status of a persistent volume claim.
 *
 * @generated from message k8s.io.api.core.v1.PersistentVolumeClaimStatus
 */
export declare type PersistentVolumeClaimStatus = Message<"k8s.io.api.core.v1.PersistentVolumeClaimStatus"> & {
  /**
   * phase represents the current phase of PersistentVolumeClaim.
   * +optional
   *
   * @generated from field: optional string phase = 1;
   */
  phase: string;

  /**
   * accessModes contains the actual access modes the volume backing the PVC has.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   * +optional
   *
   * @generated from field: repeated string accessModes = 2;
   */
  accessModes: string[];

  /**
   * capacity represents the actual resources of the underlying volume.
   * +optional
   *
   * @generated from field: map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> capacity = 3;
   */
  capacity: { [key: string]: Quantity };

  /**
   * conditions is the current Condition of persistent volume claim. If underlying persistent volume is being
   * resized then the Condition will be set to 'ResizeStarted'.
   * +optional
   * +patchMergeKey=type
   * +patchStrategy=merge
   *
   * @generated from field: repeated k8s.io.api.core.v1.PersistentVolumeClaimCondition conditions = 4;
   */
  conditions: PersistentVolumeClaimCondition[];

  /**
   * allocatedResources is the storage resource within AllocatedResources tracks the capacity allocated to a PVC. It may
   * be larger than the actual capacity when a volume expansion operation is requested.
   * For storage quota, the larger value from allocatedResources and PVC.spec.resources is used.
   * If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.
   * If a volume expansion capacity request is lowered, allocatedResources is only
   * lowered if there are no expansion operations in progress and if the actual volume capacity
   * is equal or lower than the requested capacity.
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   * +featureGate=RecoverVolumeExpansionFailure
   * +optional
   *
   * @generated from field: map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> allocatedResources = 5;
   */
  allocatedResources: { [key: string]: Quantity };

  /**
   * resizeStatus stores status of resize operation.
   * ResizeStatus is not set by default but when expansion is complete resizeStatus is set to empty
   * string by resize controller or kubelet.
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   * +featureGate=RecoverVolumeExpansionFailure
   * +optional
   *
   * @generated from field: optional string resizeStatus = 6;
   */
  resizeStatus: string;
};

/**
 * PersistentVolumeClaimStatus is the current status of a persistent volume claim.
 *
 * @generated from message k8s.io.api.core.v1.PersistentVolumeClaimStatus
 */
export declare type PersistentVolumeClaimStatusValid = Message<"k8s.io.api.core.v1.PersistentVolumeClaimStatus"> & {
  /**
   * phase represents the current phase of PersistentVolumeClaim.
   * +optional
   *
   * @generated from field: optional string phase = 1;
   */
  phase: string;

  /**
   * accessModes contains the actual access modes the volume backing the PVC has.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   * +optional
   *
   * @generated from field: repeated string accessModes = 2;
   */
  accessModes: string[];

  /**
   * capacity represents the actual resources of the underlying volume.
   * +optional
   *
   * @generated from field: map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> capacity = 3;
   */
  capacity: { [key: string]: QuantityValid };

  /**
   * conditions is the current Condition of persistent volume claim. If underlying persistent volume is being
   * resized then the Condition will be set to 'ResizeStarted'.
   * +optional
   * +patchMergeKey=type
   * +patchStrategy=merge
   *
   * @generated from field: repeated k8s.io.api.core.v1.PersistentVolumeClaimCondition conditions = 4;
   */
  conditions: PersistentVolumeClaimConditionValid[];

  /**
   * allocatedResources is the storage resource within AllocatedResources tracks the capacity allocated to a PVC. It may
   * be larger than the actual capacity when a volume expansion operation is requested.
   * For storage quota, the larger value from allocatedResources and PVC.spec.resources is used.
   * If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.
   * If a volume expansion capacity request is lowered, allocatedResources is only
   * lowered if there are no expansion operations in progress and if the actual volume capacity
   * is equal or lower than the requested capacity.
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   * +featureGate=RecoverVolumeExpansionFailure
   * +optional
   *
   * @generated from field: map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> allocatedResources = 5;
   */
  allocatedResources: { [key: string]: QuantityValid };

  /**
   * resizeStatus stores status of resize operation.
   * ResizeStatus is not set by default but when expansion is complete resizeStatus is set to empty
   * string by resize controller or kubelet.
   * This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
   * +featureGate=RecoverVolumeExpansionFailure
   * +optional
   *
   * @generated from field: optional string resizeStatus = 6;
   */
  resizeStatus: string;
};

/**
 * Describes the message k8s.io.api.core.v1.PersistentVolumeClaimStatus.
 * Use `create(PersistentVolumeClaimStatusSchema)` to create a new message.
 */
export declare const PersistentVolumeClaimStatusSchema: GenMessage<PersistentVolumeClaimStatus, {validType: PersistentVolumeClaimStatusValid}>;

/**
 * PersistentVolumeClaimTemplate is used to produce
 * PersistentVolumeClaim objects as part of an EphemeralVolumeSource.
 *
 * @generated from message k8s.io.api.core.v1.PersistentVolumeClaimTemplate
 */
export declare type PersistentVolumeClaimTemplate = Message<"k8s.io.api.core.v1.PersistentVolumeClaimTemplate"> & {
  /**
   * May contain labels and annotations that will be copied into the PVC
   * when creating it. No other fields are allowed and will be rejected during
   * validation.
   *
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMeta;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is
   * copied unchanged into the PVC that gets created from this
   * template. The same fields as in a PersistentVolumeClaim
   * are also valid here.
   *
   * @generated from field: optional k8s.io.api.core.v1.PersistentVolumeClaimSpec spec = 2;
   */
  spec?: PersistentVolumeClaimSpec;
};

/**
 * PersistentVolumeClaimTemplate is used to produce
 * PersistentVolumeClaim objects as part of an EphemeralVolumeSource.
 *
 * @generated from message k8s.io.api.core.v1.PersistentVolumeClaimTemplate
 */
export declare type PersistentVolumeClaimTemplateValid = Message<"k8s.io.api.core.v1.PersistentVolumeClaimTemplate"> & {
  /**
   * May contain labels and annotations that will be copied into the PVC
   * when creating it. No other fields are allowed and will be rejected during
   * validation.
   *
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMetaValid;

  /**
   * The specification for the PersistentVolumeClaim. The entire content is
   * copied unchanged into the PVC that gets created from this
   * template. The same fields as in a PersistentVolumeClaim
   * are also valid here.
   *
   * @generated from field: optional k8s.io.api.core.v1.PersistentVolumeClaimSpec spec = 2;
   */
  spec?: PersistentVolumeClaimSpecValid;
};

/**
 * Describes the message k8s.io.api.core.v1.PersistentVolumeClaimTemplate.
 * Use `create(PersistentVolumeClaimTemplateSchema)` to create a new message.
 */
export declare const PersistentVolumeClaimTemplateSchema: GenMessage<PersistentVolumeClaimTemplate, {validType: PersistentVolumeClaimTemplateValid}>;

/**
 * PersistentVolumeClaimVolumeSource references the user's PVC in the same namespace.
 * This volume finds the bound PV and mounts that volume for the pod. A
 * PersistentVolumeClaimVolumeSource is, essentially, a wrapper around another
 * type of volume that is owned by someone else (the system).
 *
 * @generated from message k8s.io.api.core.v1.PersistentVolumeClaimVolumeSource
 */
export declare type PersistentVolumeClaimVolumeSource = Message<"k8s.io.api.core.v1.PersistentVolumeClaimVolumeSource"> & {
  /**
   * claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @generated from field: optional string claimName = 1;
   */
  claimName: string;

  /**
   * readOnly Will force the ReadOnly setting in VolumeMounts.
   * Default false.
   * +optional
   *
   * @generated from field: optional bool readOnly = 2;
   */
  readOnly: boolean;
};

/**
 * PersistentVolumeClaimVolumeSource references the user's PVC in the same namespace.
 * This volume finds the bound PV and mounts that volume for the pod. A
 * PersistentVolumeClaimVolumeSource is, essentially, a wrapper around another
 * type of volume that is owned by someone else (the system).
 *
 * @generated from message k8s.io.api.core.v1.PersistentVolumeClaimVolumeSource
 */
export declare type PersistentVolumeClaimVolumeSourceValid = Message<"k8s.io.api.core.v1.PersistentVolumeClaimVolumeSource"> & {
  /**
   * claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @generated from field: optional string claimName = 1;
   */
  claimName: string;

  /**
   * readOnly Will force the ReadOnly setting in VolumeMounts.
   * Default false.
   * +optional
   *
   * @generated from field: optional bool readOnly = 2;
   */
  readOnly: boolean;
};

/**
 * Describes the message k8s.io.api.core.v1.PersistentVolumeClaimVolumeSource.
 * Use `create(PersistentVolumeClaimVolumeSourceSchema)` to create a new message.
 */
export declare const PersistentVolumeClaimVolumeSourceSchema: GenMessage<PersistentVolumeClaimVolumeSource, {validType: PersistentVolumeClaimVolumeSourceValid}>;

/**
 * PersistentVolumeList is a list of PersistentVolume items.
 *
 * @generated from message k8s.io.api.core.v1.PersistentVolumeList
 */
export declare type PersistentVolumeList = Message<"k8s.io.api.core.v1.PersistentVolumeList"> & {
  /**
   * Standard list metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMeta;

  /**
   * items is a list of persistent volumes.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes
   *
   * @generated from field: repeated k8s.io.api.core.v1.PersistentVolume items = 2;
   */
  items: PersistentVolume[];
};

/**
 * PersistentVolumeList is a list of PersistentVolume items.
 *
 * @generated from message k8s.io.api.core.v1.PersistentVolumeList
 */
export declare type PersistentVolumeListValid = Message<"k8s.io.api.core.v1.PersistentVolumeList"> & {
  /**
   * Standard list metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMetaValid;

  /**
   * items is a list of persistent volumes.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes
   *
   * @generated from field: repeated k8s.io.api.core.v1.PersistentVolume items = 2;
   */
  items: PersistentVolumeValid[];
};

/**
 * Describes the message k8s.io.api.core.v1.PersistentVolumeList.
 * Use `create(PersistentVolumeListSchema)` to create a new message.
 */
export declare const PersistentVolumeListSchema: GenMessage<PersistentVolumeList, {validType: PersistentVolumeListValid}>;

/**
 * PersistentVolumeSource is similar to VolumeSource but meant for the
 * administrator who creates PVs. Exactly one of its members must be set.
 *
 * @generated from message k8s.io.api.core.v1.PersistentVolumeSource
 */
export declare type PersistentVolumeSource = Message<"k8s.io.api.core.v1.PersistentVolumeSource"> & {
  /**
   * gcePersistentDisk represents a GCE Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod. Provisioned by an admin.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.GCEPersistentDiskVolumeSource gcePersistentDisk = 1;
   */
  gcePersistentDisk?: GCEPersistentDiskVolumeSource;

  /**
   * awsElasticBlockStore represents an AWS Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.AWSElasticBlockStoreVolumeSource awsElasticBlockStore = 2;
   */
  awsElasticBlockStore?: AWSElasticBlockStoreVolumeSource;

  /**
   * hostPath represents a directory on the host.
   * Provisioned by a developer or tester.
   * This is useful for single-node development and testing only!
   * On-host storage is not supported in any way and WILL NOT WORK in a multi-node cluster.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.HostPathVolumeSource hostPath = 3;
   */
  hostPath?: HostPathVolumeSource;

  /**
   * glusterfs represents a Glusterfs volume that is attached to a host and
   * exposed to the pod. Provisioned by an admin.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.GlusterfsPersistentVolumeSource glusterfs = 4;
   */
  glusterfs?: GlusterfsPersistentVolumeSource;

  /**
   * nfs represents an NFS mount on the host. Provisioned by an admin.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.NFSVolumeSource nfs = 5;
   */
  nfs?: NFSVolumeSource;

  /**
   * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
   * More info: https://examples.k8s.io/volumes/rbd/README.md
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.RBDPersistentVolumeSource rbd = 6;
   */
  rbd?: RBDPersistentVolumeSource;

  /**
   * iscsi represents an ISCSI Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod. Provisioned by an admin.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ISCSIPersistentVolumeSource iscsi = 7;
   */
  iscsi?: ISCSIPersistentVolumeSource;

  /**
   * cinder represents a cinder volume attached and mounted on kubelets host machine.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.CinderPersistentVolumeSource cinder = 8;
   */
  cinder?: CinderPersistentVolumeSource;

  /**
   * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.CephFSPersistentVolumeSource cephfs = 9;
   */
  cephfs?: CephFSPersistentVolumeSource;

  /**
   * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.FCVolumeSource fc = 10;
   */
  fc?: FCVolumeSource;

  /**
   * flocker represents a Flocker volume attached to a kubelet's host machine and exposed to the pod for its usage. This depends on the Flocker control service being running
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.FlockerVolumeSource flocker = 11;
   */
  flocker?: FlockerVolumeSource;

  /**
   * flexVolume represents a generic volume resource that is
   * provisioned/attached using an exec based plugin.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.FlexPersistentVolumeSource flexVolume = 12;
   */
  flexVolume?: FlexPersistentVolumeSource;

  /**
   * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.AzureFilePersistentVolumeSource azureFile = 13;
   */
  azureFile?: AzureFilePersistentVolumeSource;

  /**
   * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.VsphereVirtualDiskVolumeSource vsphereVolume = 14;
   */
  vsphereVolume?: VsphereVirtualDiskVolumeSource;

  /**
   * quobyte represents a Quobyte mount on the host that shares a pod's lifetime
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.QuobyteVolumeSource quobyte = 15;
   */
  quobyte?: QuobyteVolumeSource;

  /**
   * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.AzureDiskVolumeSource azureDisk = 16;
   */
  azureDisk?: AzureDiskVolumeSource;

  /**
   * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
   *
   * @generated from field: optional k8s.io.api.core.v1.PhotonPersistentDiskVolumeSource photonPersistentDisk = 17;
   */
  photonPersistentDisk?: PhotonPersistentDiskVolumeSource;

  /**
   * portworxVolume represents a portworx volume attached and mounted on kubelets host machine
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.PortworxVolumeSource portworxVolume = 18;
   */
  portworxVolume?: PortworxVolumeSource;

  /**
   * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ScaleIOPersistentVolumeSource scaleIO = 19;
   */
  scaleIO?: ScaleIOPersistentVolumeSource;

  /**
   * local represents directly-attached storage with node affinity
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.LocalVolumeSource local = 20;
   */
  local?: LocalVolumeSource;

  /**
   * storageOS represents a StorageOS volume that is attached to the kubelet's host machine and mounted into the pod
   * More info: https://examples.k8s.io/volumes/storageos/README.md
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.StorageOSPersistentVolumeSource storageos = 21;
   */
  storageos?: StorageOSPersistentVolumeSource;

  /**
   * csi represents storage that is handled by an external CSI driver (Beta feature).
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.CSIPersistentVolumeSource csi = 22;
   */
  csi?: CSIPersistentVolumeSource;
};

/**
 * PersistentVolumeSource is similar to VolumeSource but meant for the
 * administrator who creates PVs. Exactly one of its members must be set.
 *
 * @generated from message k8s.io.api.core.v1.PersistentVolumeSource
 */
export declare type PersistentVolumeSourceValid = Message<"k8s.io.api.core.v1.PersistentVolumeSource"> & {
  /**
   * gcePersistentDisk represents a GCE Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod. Provisioned by an admin.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.GCEPersistentDiskVolumeSource gcePersistentDisk = 1;
   */
  gcePersistentDisk?: GCEPersistentDiskVolumeSourceValid;

  /**
   * awsElasticBlockStore represents an AWS Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.AWSElasticBlockStoreVolumeSource awsElasticBlockStore = 2;
   */
  awsElasticBlockStore?: AWSElasticBlockStoreVolumeSourceValid;

  /**
   * hostPath represents a directory on the host.
   * Provisioned by a developer or tester.
   * This is useful for single-node development and testing only!
   * On-host storage is not supported in any way and WILL NOT WORK in a multi-node cluster.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.HostPathVolumeSource hostPath = 3;
   */
  hostPath?: HostPathVolumeSourceValid;

  /**
   * glusterfs represents a Glusterfs volume that is attached to a host and
   * exposed to the pod. Provisioned by an admin.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.GlusterfsPersistentVolumeSource glusterfs = 4;
   */
  glusterfs?: GlusterfsPersistentVolumeSourceValid;

  /**
   * nfs represents an NFS mount on the host. Provisioned by an admin.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.NFSVolumeSource nfs = 5;
   */
  nfs?: NFSVolumeSourceValid;

  /**
   * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
   * More info: https://examples.k8s.io/volumes/rbd/README.md
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.RBDPersistentVolumeSource rbd = 6;
   */
  rbd?: RBDPersistentVolumeSourceValid;

  /**
   * iscsi represents an ISCSI Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod. Provisioned by an admin.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ISCSIPersistentVolumeSource iscsi = 7;
   */
  iscsi?: ISCSIPersistentVolumeSourceValid;

  /**
   * cinder represents a cinder volume attached and mounted on kubelets host machine.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.CinderPersistentVolumeSource cinder = 8;
   */
  cinder?: CinderPersistentVolumeSourceValid;

  /**
   * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.CephFSPersistentVolumeSource cephfs = 9;
   */
  cephfs?: CephFSPersistentVolumeSourceValid;

  /**
   * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.FCVolumeSource fc = 10;
   */
  fc?: FCVolumeSourceValid;

  /**
   * flocker represents a Flocker volume attached to a kubelet's host machine and exposed to the pod for its usage. This depends on the Flocker control service being running
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.FlockerVolumeSource flocker = 11;
   */
  flocker?: FlockerVolumeSourceValid;

  /**
   * flexVolume represents a generic volume resource that is
   * provisioned/attached using an exec based plugin.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.FlexPersistentVolumeSource flexVolume = 12;
   */
  flexVolume?: FlexPersistentVolumeSourceValid;

  /**
   * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.AzureFilePersistentVolumeSource azureFile = 13;
   */
  azureFile?: AzureFilePersistentVolumeSourceValid;

  /**
   * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.VsphereVirtualDiskVolumeSource vsphereVolume = 14;
   */
  vsphereVolume?: VsphereVirtualDiskVolumeSourceValid;

  /**
   * quobyte represents a Quobyte mount on the host that shares a pod's lifetime
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.QuobyteVolumeSource quobyte = 15;
   */
  quobyte?: QuobyteVolumeSourceValid;

  /**
   * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.AzureDiskVolumeSource azureDisk = 16;
   */
  azureDisk?: AzureDiskVolumeSourceValid;

  /**
   * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
   *
   * @generated from field: optional k8s.io.api.core.v1.PhotonPersistentDiskVolumeSource photonPersistentDisk = 17;
   */
  photonPersistentDisk?: PhotonPersistentDiskVolumeSourceValid;

  /**
   * portworxVolume represents a portworx volume attached and mounted on kubelets host machine
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.PortworxVolumeSource portworxVolume = 18;
   */
  portworxVolume?: PortworxVolumeSourceValid;

  /**
   * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ScaleIOPersistentVolumeSource scaleIO = 19;
   */
  scaleIO?: ScaleIOPersistentVolumeSourceValid;

  /**
   * local represents directly-attached storage with node affinity
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.LocalVolumeSource local = 20;
   */
  local?: LocalVolumeSourceValid;

  /**
   * storageOS represents a StorageOS volume that is attached to the kubelet's host machine and mounted into the pod
   * More info: https://examples.k8s.io/volumes/storageos/README.md
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.StorageOSPersistentVolumeSource storageos = 21;
   */
  storageos?: StorageOSPersistentVolumeSourceValid;

  /**
   * csi represents storage that is handled by an external CSI driver (Beta feature).
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.CSIPersistentVolumeSource csi = 22;
   */
  csi?: CSIPersistentVolumeSourceValid;
};

/**
 * Describes the message k8s.io.api.core.v1.PersistentVolumeSource.
 * Use `create(PersistentVolumeSourceSchema)` to create a new message.
 */
export declare const PersistentVolumeSourceSchema: GenMessage<PersistentVolumeSource, {validType: PersistentVolumeSourceValid}>;

/**
 * PersistentVolumeSpec is the specification of a persistent volume.
 *
 * @generated from message k8s.io.api.core.v1.PersistentVolumeSpec
 */
export declare type PersistentVolumeSpec = Message<"k8s.io.api.core.v1.PersistentVolumeSpec"> & {
  /**
   * capacity is the description of the persistent volume's resources and capacity.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
   * +optional
   *
   * @generated from field: map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> capacity = 1;
   */
  capacity: { [key: string]: Quantity };

  /**
   * persistentVolumeSource is the actual volume backing the persistent volume.
   *
   * @generated from field: optional k8s.io.api.core.v1.PersistentVolumeSource persistentVolumeSource = 2;
   */
  persistentVolumeSource?: PersistentVolumeSource;

  /**
   * accessModes contains all ways the volume can be mounted.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes
   * +optional
   *
   * @generated from field: repeated string accessModes = 3;
   */
  accessModes: string[];

  /**
   * claimRef is part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim.
   * Expected to be non-nil when bound.
   * claim.VolumeName is the authoritative bind between PV and PVC.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ObjectReference claimRef = 4;
   */
  claimRef?: ObjectReference;

  /**
   * persistentVolumeReclaimPolicy defines what happens to a persistent volume when released from its claim.
   * Valid options are Retain (default for manually created PersistentVolumes), Delete (default
   * for dynamically provisioned PersistentVolumes), and Recycle (deprecated).
   * Recycle must be supported by the volume plugin underlying this PersistentVolume.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming
   * +optional
   *
   * @generated from field: optional string persistentVolumeReclaimPolicy = 5;
   */
  persistentVolumeReclaimPolicy: string;

  /**
   * storageClassName is the name of StorageClass to which this persistent volume belongs. Empty value
   * means that this volume does not belong to any StorageClass.
   * +optional
   *
   * @generated from field: optional string storageClassName = 6;
   */
  storageClassName: string;

  /**
   * mountOptions is the list of mount options, e.g. ["ro", "soft"]. Not validated - mount will
   * simply fail if one is invalid.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options
   * +optional
   *
   * @generated from field: repeated string mountOptions = 7;
   */
  mountOptions: string[];

  /**
   * volumeMode defines if a volume is intended to be used with a formatted filesystem
   * or to remain in raw block state. Value of Filesystem is implied when not included in spec.
   * +optional
   *
   * @generated from field: optional string volumeMode = 8;
   */
  volumeMode: string;

  /**
   * nodeAffinity defines constraints that limit what nodes this volume can be accessed from.
   * This field influences the scheduling of pods that use this volume.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.VolumeNodeAffinity nodeAffinity = 9;
   */
  nodeAffinity?: VolumeNodeAffinity;
};

/**
 * PersistentVolumeSpec is the specification of a persistent volume.
 *
 * @generated from message k8s.io.api.core.v1.PersistentVolumeSpec
 */
export declare type PersistentVolumeSpecValid = Message<"k8s.io.api.core.v1.PersistentVolumeSpec"> & {
  /**
   * capacity is the description of the persistent volume's resources and capacity.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
   * +optional
   *
   * @generated from field: map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> capacity = 1;
   */
  capacity: { [key: string]: QuantityValid };

  /**
   * persistentVolumeSource is the actual volume backing the persistent volume.
   *
   * @generated from field: optional k8s.io.api.core.v1.PersistentVolumeSource persistentVolumeSource = 2;
   */
  persistentVolumeSource?: PersistentVolumeSourceValid;

  /**
   * accessModes contains all ways the volume can be mounted.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes
   * +optional
   *
   * @generated from field: repeated string accessModes = 3;
   */
  accessModes: string[];

  /**
   * claimRef is part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim.
   * Expected to be non-nil when bound.
   * claim.VolumeName is the authoritative bind between PV and PVC.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ObjectReference claimRef = 4;
   */
  claimRef?: ObjectReferenceValid;

  /**
   * persistentVolumeReclaimPolicy defines what happens to a persistent volume when released from its claim.
   * Valid options are Retain (default for manually created PersistentVolumes), Delete (default
   * for dynamically provisioned PersistentVolumes), and Recycle (deprecated).
   * Recycle must be supported by the volume plugin underlying this PersistentVolume.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming
   * +optional
   *
   * @generated from field: optional string persistentVolumeReclaimPolicy = 5;
   */
  persistentVolumeReclaimPolicy: string;

  /**
   * storageClassName is the name of StorageClass to which this persistent volume belongs. Empty value
   * means that this volume does not belong to any StorageClass.
   * +optional
   *
   * @generated from field: optional string storageClassName = 6;
   */
  storageClassName: string;

  /**
   * mountOptions is the list of mount options, e.g. ["ro", "soft"]. Not validated - mount will
   * simply fail if one is invalid.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options
   * +optional
   *
   * @generated from field: repeated string mountOptions = 7;
   */
  mountOptions: string[];

  /**
   * volumeMode defines if a volume is intended to be used with a formatted filesystem
   * or to remain in raw block state. Value of Filesystem is implied when not included in spec.
   * +optional
   *
   * @generated from field: optional string volumeMode = 8;
   */
  volumeMode: string;

  /**
   * nodeAffinity defines constraints that limit what nodes this volume can be accessed from.
   * This field influences the scheduling of pods that use this volume.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.VolumeNodeAffinity nodeAffinity = 9;
   */
  nodeAffinity?: VolumeNodeAffinityValid;
};

/**
 * Describes the message k8s.io.api.core.v1.PersistentVolumeSpec.
 * Use `create(PersistentVolumeSpecSchema)` to create a new message.
 */
export declare const PersistentVolumeSpecSchema: GenMessage<PersistentVolumeSpec, {validType: PersistentVolumeSpecValid}>;

/**
 * PersistentVolumeStatus is the current status of a persistent volume.
 *
 * @generated from message k8s.io.api.core.v1.PersistentVolumeStatus
 */
export declare type PersistentVolumeStatus = Message<"k8s.io.api.core.v1.PersistentVolumeStatus"> & {
  /**
   * phase indicates if a volume is available, bound to a claim, or released by a claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#phase
   * +optional
   *
   * @generated from field: optional string phase = 1;
   */
  phase: string;

  /**
   * message is a human-readable message indicating details about why the volume is in this state.
   * +optional
   *
   * @generated from field: optional string message = 2;
   */
  message: string;

  /**
   * reason is a brief CamelCase string that describes any failure and is meant
   * for machine parsing and tidy display in the CLI.
   * +optional
   *
   * @generated from field: optional string reason = 3;
   */
  reason: string;
};

/**
 * PersistentVolumeStatus is the current status of a persistent volume.
 *
 * @generated from message k8s.io.api.core.v1.PersistentVolumeStatus
 */
export declare type PersistentVolumeStatusValid = Message<"k8s.io.api.core.v1.PersistentVolumeStatus"> & {
  /**
   * phase indicates if a volume is available, bound to a claim, or released by a claim.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#phase
   * +optional
   *
   * @generated from field: optional string phase = 1;
   */
  phase: string;

  /**
   * message is a human-readable message indicating details about why the volume is in this state.
   * +optional
   *
   * @generated from field: optional string message = 2;
   */
  message: string;

  /**
   * reason is a brief CamelCase string that describes any failure and is meant
   * for machine parsing and tidy display in the CLI.
   * +optional
   *
   * @generated from field: optional string reason = 3;
   */
  reason: string;
};

/**
 * Describes the message k8s.io.api.core.v1.PersistentVolumeStatus.
 * Use `create(PersistentVolumeStatusSchema)` to create a new message.
 */
export declare const PersistentVolumeStatusSchema: GenMessage<PersistentVolumeStatus, {validType: PersistentVolumeStatusValid}>;

/**
 * Represents a Photon Controller persistent disk resource.
 *
 * @generated from message k8s.io.api.core.v1.PhotonPersistentDiskVolumeSource
 */
export declare type PhotonPersistentDiskVolumeSource = Message<"k8s.io.api.core.v1.PhotonPersistentDiskVolumeSource"> & {
  /**
   * pdID is the ID that identifies Photon Controller persistent disk
   *
   * @generated from field: optional string pdID = 1;
   */
  pdID: string;

  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @generated from field: optional string fsType = 2;
   */
  fsType: string;
};

/**
 * Represents a Photon Controller persistent disk resource.
 *
 * @generated from message k8s.io.api.core.v1.PhotonPersistentDiskVolumeSource
 */
export declare type PhotonPersistentDiskVolumeSourceValid = Message<"k8s.io.api.core.v1.PhotonPersistentDiskVolumeSource"> & {
  /**
   * pdID is the ID that identifies Photon Controller persistent disk
   *
   * @generated from field: optional string pdID = 1;
   */
  pdID: string;

  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @generated from field: optional string fsType = 2;
   */
  fsType: string;
};

/**
 * Describes the message k8s.io.api.core.v1.PhotonPersistentDiskVolumeSource.
 * Use `create(PhotonPersistentDiskVolumeSourceSchema)` to create a new message.
 */
export declare const PhotonPersistentDiskVolumeSourceSchema: GenMessage<PhotonPersistentDiskVolumeSource, {validType: PhotonPersistentDiskVolumeSourceValid}>;

/**
 * Pod is a collection of containers that can run on a host. This resource is created
 * by clients and scheduled onto hosts.
 *
 * @generated from message k8s.io.api.core.v1.Pod
 */
export declare type Pod = Message<"k8s.io.api.core.v1.Pod"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMeta;

  /**
   * Specification of the desired behavior of the pod.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.PodSpec spec = 2;
   */
  spec?: PodSpec;

  /**
   * Most recently observed status of the pod.
   * This data may not be up to date.
   * Populated by the system.
   * Read-only.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.PodStatus status = 3;
   */
  status?: PodStatus;
};

/**
 * Pod is a collection of containers that can run on a host. This resource is created
 * by clients and scheduled onto hosts.
 *
 * @generated from message k8s.io.api.core.v1.Pod
 */
export declare type PodValid = Message<"k8s.io.api.core.v1.Pod"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMetaValid;

  /**
   * Specification of the desired behavior of the pod.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.PodSpec spec = 2;
   */
  spec?: PodSpecValid;

  /**
   * Most recently observed status of the pod.
   * This data may not be up to date.
   * Populated by the system.
   * Read-only.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.PodStatus status = 3;
   */
  status?: PodStatusValid;
};

/**
 * Describes the message k8s.io.api.core.v1.Pod.
 * Use `create(PodSchema)` to create a new message.
 */
export declare const PodSchema: GenMessage<Pod, {validType: PodValid}>;

/**
 * Pod affinity is a group of inter pod affinity scheduling rules.
 *
 * @generated from message k8s.io.api.core.v1.PodAffinity
 */
export declare type PodAffinity = Message<"k8s.io.api.core.v1.PodAffinity"> & {
  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.PodAffinityTerm requiredDuringSchedulingIgnoredDuringExecution = 1;
   */
  requiredDuringSchedulingIgnoredDuringExecution: PodAffinityTerm[];

  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.WeightedPodAffinityTerm preferredDuringSchedulingIgnoredDuringExecution = 2;
   */
  preferredDuringSchedulingIgnoredDuringExecution: WeightedPodAffinityTerm[];
};

/**
 * Pod affinity is a group of inter pod affinity scheduling rules.
 *
 * @generated from message k8s.io.api.core.v1.PodAffinity
 */
export declare type PodAffinityValid = Message<"k8s.io.api.core.v1.PodAffinity"> & {
  /**
   * If the affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.PodAffinityTerm requiredDuringSchedulingIgnoredDuringExecution = 1;
   */
  requiredDuringSchedulingIgnoredDuringExecution: PodAffinityTermValid[];

  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.WeightedPodAffinityTerm preferredDuringSchedulingIgnoredDuringExecution = 2;
   */
  preferredDuringSchedulingIgnoredDuringExecution: WeightedPodAffinityTermValid[];
};

/**
 * Describes the message k8s.io.api.core.v1.PodAffinity.
 * Use `create(PodAffinitySchema)` to create a new message.
 */
export declare const PodAffinitySchema: GenMessage<PodAffinity, {validType: PodAffinityValid}>;

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @generated from message k8s.io.api.core.v1.PodAffinityTerm
 */
export declare type PodAffinityTerm = Message<"k8s.io.api.core.v1.PodAffinityTerm"> & {
  /**
   * A label query over a set of resources, in this case pods.
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector labelSelector = 1;
   */
  labelSelector?: LabelSelector;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   * +optional
   *
   * @generated from field: repeated string namespaces = 2;
   */
  namespaces: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @generated from field: optional string topologyKey = 3;
   */
  topologyKey: string;

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 4;
   */
  namespaceSelector?: LabelSelector;
};

/**
 * Defines a set of pods (namely those matching the labelSelector
 * relative to the given namespace(s)) that this pod should be
 * co-located (affinity) or not co-located (anti-affinity) with,
 * where co-located is defined as running on a node whose value of
 * the label with key <topologyKey> matches that of any node on which
 * a pod of the set of pods is running
 *
 * @generated from message k8s.io.api.core.v1.PodAffinityTerm
 */
export declare type PodAffinityTermValid = Message<"k8s.io.api.core.v1.PodAffinityTerm"> & {
  /**
   * A label query over a set of resources, in this case pods.
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector labelSelector = 1;
   */
  labelSelector?: LabelSelectorValid;

  /**
   * namespaces specifies a static list of namespace names that the term applies to.
   * The term is applied to the union of the namespaces listed in this field
   * and the ones selected by namespaceSelector.
   * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
   * +optional
   *
   * @generated from field: repeated string namespaces = 2;
   */
  namespaces: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
   * the labelSelector in the specified namespaces, where co-located is defined as running on a node
   * whose value of the label with key topologyKey matches that of any node on which any of the
   * selected pods is running.
   * Empty topologyKey is not allowed.
   *
   * @generated from field: optional string topologyKey = 3;
   */
  topologyKey: string;

  /**
   * A label query over the set of namespaces that the term applies to.
   * The term is applied to the union of the namespaces selected by this field
   * and the ones listed in the namespaces field.
   * null selector and null or empty namespaces list means "this pod's namespace".
   * An empty selector ({}) matches all namespaces.
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 4;
   */
  namespaceSelector?: LabelSelectorValid;
};

/**
 * Describes the message k8s.io.api.core.v1.PodAffinityTerm.
 * Use `create(PodAffinityTermSchema)` to create a new message.
 */
export declare const PodAffinityTermSchema: GenMessage<PodAffinityTerm, {validType: PodAffinityTermValid}>;

/**
 * Pod anti affinity is a group of inter pod anti affinity scheduling rules.
 *
 * @generated from message k8s.io.api.core.v1.PodAntiAffinity
 */
export declare type PodAntiAffinity = Message<"k8s.io.api.core.v1.PodAntiAffinity"> & {
  /**
   * If the anti-affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the anti-affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.PodAffinityTerm requiredDuringSchedulingIgnoredDuringExecution = 1;
   */
  requiredDuringSchedulingIgnoredDuringExecution: PodAffinityTerm[];

  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the anti-affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling anti-affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.WeightedPodAffinityTerm preferredDuringSchedulingIgnoredDuringExecution = 2;
   */
  preferredDuringSchedulingIgnoredDuringExecution: WeightedPodAffinityTerm[];
};

/**
 * Pod anti affinity is a group of inter pod anti affinity scheduling rules.
 *
 * @generated from message k8s.io.api.core.v1.PodAntiAffinity
 */
export declare type PodAntiAffinityValid = Message<"k8s.io.api.core.v1.PodAntiAffinity"> & {
  /**
   * If the anti-affinity requirements specified by this field are not met at
   * scheduling time, the pod will not be scheduled onto the node.
   * If the anti-affinity requirements specified by this field cease to be met
   * at some point during pod execution (e.g. due to a pod label update), the
   * system may or may not try to eventually evict the pod from its node.
   * When there are multiple elements, the lists of nodes corresponding to each
   * podAffinityTerm are intersected, i.e. all terms must be satisfied.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.PodAffinityTerm requiredDuringSchedulingIgnoredDuringExecution = 1;
   */
  requiredDuringSchedulingIgnoredDuringExecution: PodAffinityTermValid[];

  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy
   * the anti-affinity expressions specified by this field, but it may choose
   * a node that violates one or more of the expressions. The node that is
   * most preferred is the one with the greatest sum of weights, i.e.
   * for each node that meets all of the scheduling requirements (resource
   * request, requiredDuringScheduling anti-affinity expressions, etc.),
   * compute a sum by iterating through the elements of this field and adding
   * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
   * node(s) with the highest sum are the most preferred.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.WeightedPodAffinityTerm preferredDuringSchedulingIgnoredDuringExecution = 2;
   */
  preferredDuringSchedulingIgnoredDuringExecution: WeightedPodAffinityTermValid[];
};

/**
 * Describes the message k8s.io.api.core.v1.PodAntiAffinity.
 * Use `create(PodAntiAffinitySchema)` to create a new message.
 */
export declare const PodAntiAffinitySchema: GenMessage<PodAntiAffinity, {validType: PodAntiAffinityValid}>;

/**
 * PodAttachOptions is the query options to a Pod's remote attach call.
 * ---
 * TODO: merge w/ PodExecOptions below for stdin, stdout, etc
 * and also when we cut V2, we should export a "StreamOptions" or somesuch that contains Stdin, Stdout, Stder and TTY
 *
 * @generated from message k8s.io.api.core.v1.PodAttachOptions
 */
export declare type PodAttachOptions = Message<"k8s.io.api.core.v1.PodAttachOptions"> & {
  /**
   * Stdin if true, redirects the standard input stream of the pod for this call.
   * Defaults to false.
   * +optional
   *
   * @generated from field: optional bool stdin = 1;
   */
  stdin: boolean;

  /**
   * Stdout if true indicates that stdout is to be redirected for the attach call.
   * Defaults to true.
   * +optional
   *
   * @generated from field: optional bool stdout = 2;
   */
  stdout: boolean;

  /**
   * Stderr if true indicates that stderr is to be redirected for the attach call.
   * Defaults to true.
   * +optional
   *
   * @generated from field: optional bool stderr = 3;
   */
  stderr: boolean;

  /**
   * TTY if true indicates that a tty will be allocated for the attach call.
   * This is passed through the container runtime so the tty
   * is allocated on the worker node by the container runtime.
   * Defaults to false.
   * +optional
   *
   * @generated from field: optional bool tty = 4;
   */
  tty: boolean;

  /**
   * The container in which to execute the command.
   * Defaults to only container if there is only one container in the pod.
   * +optional
   *
   * @generated from field: optional string container = 5;
   */
  container: string;
};

/**
 * PodAttachOptions is the query options to a Pod's remote attach call.
 * ---
 * TODO: merge w/ PodExecOptions below for stdin, stdout, etc
 * and also when we cut V2, we should export a "StreamOptions" or somesuch that contains Stdin, Stdout, Stder and TTY
 *
 * @generated from message k8s.io.api.core.v1.PodAttachOptions
 */
export declare type PodAttachOptionsValid = Message<"k8s.io.api.core.v1.PodAttachOptions"> & {
  /**
   * Stdin if true, redirects the standard input stream of the pod for this call.
   * Defaults to false.
   * +optional
   *
   * @generated from field: optional bool stdin = 1;
   */
  stdin: boolean;

  /**
   * Stdout if true indicates that stdout is to be redirected for the attach call.
   * Defaults to true.
   * +optional
   *
   * @generated from field: optional bool stdout = 2;
   */
  stdout: boolean;

  /**
   * Stderr if true indicates that stderr is to be redirected for the attach call.
   * Defaults to true.
   * +optional
   *
   * @generated from field: optional bool stderr = 3;
   */
  stderr: boolean;

  /**
   * TTY if true indicates that a tty will be allocated for the attach call.
   * This is passed through the container runtime so the tty
   * is allocated on the worker node by the container runtime.
   * Defaults to false.
   * +optional
   *
   * @generated from field: optional bool tty = 4;
   */
  tty: boolean;

  /**
   * The container in which to execute the command.
   * Defaults to only container if there is only one container in the pod.
   * +optional
   *
   * @generated from field: optional string container = 5;
   */
  container: string;
};

/**
 * Describes the message k8s.io.api.core.v1.PodAttachOptions.
 * Use `create(PodAttachOptionsSchema)` to create a new message.
 */
export declare const PodAttachOptionsSchema: GenMessage<PodAttachOptions, {validType: PodAttachOptionsValid}>;

/**
 * PodCondition contains details for the current condition of this pod.
 *
 * @generated from message k8s.io.api.core.v1.PodCondition
 */
export declare type PodCondition = Message<"k8s.io.api.core.v1.PodCondition"> & {
  /**
   * Type is the type of the condition.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
   *
   * @generated from field: optional string type = 1;
   */
  type: string;

  /**
   * Status is the status of the condition.
   * Can be True, False, Unknown.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
   *
   * @generated from field: optional string status = 2;
   */
  status: string;

  /**
   * Last time we probed the condition.
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastProbeTime = 3;
   */
  lastProbeTime?: Time;

  /**
   * Last time the condition transitioned from one status to another.
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;
   */
  lastTransitionTime?: Time;

  /**
   * Unique, one-word, CamelCase reason for the condition's last transition.
   * +optional
   *
   * @generated from field: optional string reason = 5;
   */
  reason: string;

  /**
   * Human-readable message indicating details about last transition.
   * +optional
   *
   * @generated from field: optional string message = 6;
   */
  message: string;
};

/**
 * PodCondition contains details for the current condition of this pod.
 *
 * @generated from message k8s.io.api.core.v1.PodCondition
 */
export declare type PodConditionValid = Message<"k8s.io.api.core.v1.PodCondition"> & {
  /**
   * Type is the type of the condition.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
   *
   * @generated from field: optional string type = 1;
   */
  type: string;

  /**
   * Status is the status of the condition.
   * Can be True, False, Unknown.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
   *
   * @generated from field: optional string status = 2;
   */
  status: string;

  /**
   * Last time we probed the condition.
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastProbeTime = 3;
   */
  lastProbeTime?: TimeValid;

  /**
   * Last time the condition transitioned from one status to another.
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;
   */
  lastTransitionTime?: TimeValid;

  /**
   * Unique, one-word, CamelCase reason for the condition's last transition.
   * +optional
   *
   * @generated from field: optional string reason = 5;
   */
  reason: string;

  /**
   * Human-readable message indicating details about last transition.
   * +optional
   *
   * @generated from field: optional string message = 6;
   */
  message: string;
};

/**
 * Describes the message k8s.io.api.core.v1.PodCondition.
 * Use `create(PodConditionSchema)` to create a new message.
 */
export declare const PodConditionSchema: GenMessage<PodCondition, {validType: PodConditionValid}>;

/**
 * PodDNSConfig defines the DNS parameters of a pod in addition to
 * those generated from DNSPolicy.
 *
 * @generated from message k8s.io.api.core.v1.PodDNSConfig
 */
export declare type PodDNSConfig = Message<"k8s.io.api.core.v1.PodDNSConfig"> & {
  /**
   * A list of DNS name server IP addresses.
   * This will be appended to the base nameservers generated from DNSPolicy.
   * Duplicated nameservers will be removed.
   * +optional
   *
   * @generated from field: repeated string nameservers = 1;
   */
  nameservers: string[];

  /**
   * A list of DNS search domains for host-name lookup.
   * This will be appended to the base search paths generated from DNSPolicy.
   * Duplicated search paths will be removed.
   * +optional
   *
   * @generated from field: repeated string searches = 2;
   */
  searches: string[];

  /**
   * A list of DNS resolver options.
   * This will be merged with the base options generated from DNSPolicy.
   * Duplicated entries will be removed. Resolution options given in Options
   * will override those that appear in the base DNSPolicy.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.PodDNSConfigOption options = 3;
   */
  options: PodDNSConfigOption[];
};

/**
 * PodDNSConfig defines the DNS parameters of a pod in addition to
 * those generated from DNSPolicy.
 *
 * @generated from message k8s.io.api.core.v1.PodDNSConfig
 */
export declare type PodDNSConfigValid = Message<"k8s.io.api.core.v1.PodDNSConfig"> & {
  /**
   * A list of DNS name server IP addresses.
   * This will be appended to the base nameservers generated from DNSPolicy.
   * Duplicated nameservers will be removed.
   * +optional
   *
   * @generated from field: repeated string nameservers = 1;
   */
  nameservers: string[];

  /**
   * A list of DNS search domains for host-name lookup.
   * This will be appended to the base search paths generated from DNSPolicy.
   * Duplicated search paths will be removed.
   * +optional
   *
   * @generated from field: repeated string searches = 2;
   */
  searches: string[];

  /**
   * A list of DNS resolver options.
   * This will be merged with the base options generated from DNSPolicy.
   * Duplicated entries will be removed. Resolution options given in Options
   * will override those that appear in the base DNSPolicy.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.PodDNSConfigOption options = 3;
   */
  options: PodDNSConfigOptionValid[];
};

/**
 * Describes the message k8s.io.api.core.v1.PodDNSConfig.
 * Use `create(PodDNSConfigSchema)` to create a new message.
 */
export declare const PodDNSConfigSchema: GenMessage<PodDNSConfig, {validType: PodDNSConfigValid}>;

/**
 * PodDNSConfigOption defines DNS resolver options of a pod.
 *
 * @generated from message k8s.io.api.core.v1.PodDNSConfigOption
 */
export declare type PodDNSConfigOption = Message<"k8s.io.api.core.v1.PodDNSConfigOption"> & {
  /**
   * Required.
   *
   * @generated from field: optional string name = 1;
   */
  name: string;

  /**
   * +optional
   *
   * @generated from field: optional string value = 2;
   */
  value: string;
};

/**
 * PodDNSConfigOption defines DNS resolver options of a pod.
 *
 * @generated from message k8s.io.api.core.v1.PodDNSConfigOption
 */
export declare type PodDNSConfigOptionValid = Message<"k8s.io.api.core.v1.PodDNSConfigOption"> & {
  /**
   * Required.
   *
   * @generated from field: optional string name = 1;
   */
  name: string;

  /**
   * +optional
   *
   * @generated from field: optional string value = 2;
   */
  value: string;
};

/**
 * Describes the message k8s.io.api.core.v1.PodDNSConfigOption.
 * Use `create(PodDNSConfigOptionSchema)` to create a new message.
 */
export declare const PodDNSConfigOptionSchema: GenMessage<PodDNSConfigOption, {validType: PodDNSConfigOptionValid}>;

/**
 * PodExecOptions is the query options to a Pod's remote exec call.
 * ---
 * TODO: This is largely identical to PodAttachOptions above, make sure they stay in sync and see about merging
 * and also when we cut V2, we should export a "StreamOptions" or somesuch that contains Stdin, Stdout, Stder and TTY
 *
 * @generated from message k8s.io.api.core.v1.PodExecOptions
 */
export declare type PodExecOptions = Message<"k8s.io.api.core.v1.PodExecOptions"> & {
  /**
   * Redirect the standard input stream of the pod for this call.
   * Defaults to false.
   * +optional
   *
   * @generated from field: optional bool stdin = 1;
   */
  stdin: boolean;

  /**
   * Redirect the standard output stream of the pod for this call.
   * +optional
   *
   * @generated from field: optional bool stdout = 2;
   */
  stdout: boolean;

  /**
   * Redirect the standard error stream of the pod for this call.
   * +optional
   *
   * @generated from field: optional bool stderr = 3;
   */
  stderr: boolean;

  /**
   * TTY if true indicates that a tty will be allocated for the exec call.
   * Defaults to false.
   * +optional
   *
   * @generated from field: optional bool tty = 4;
   */
  tty: boolean;

  /**
   * Container in which to execute the command.
   * Defaults to only container if there is only one container in the pod.
   * +optional
   *
   * @generated from field: optional string container = 5;
   */
  container: string;

  /**
   * Command is the remote command to execute. argv array. Not executed within a shell.
   *
   * @generated from field: repeated string command = 6;
   */
  command: string[];
};

/**
 * PodExecOptions is the query options to a Pod's remote exec call.
 * ---
 * TODO: This is largely identical to PodAttachOptions above, make sure they stay in sync and see about merging
 * and also when we cut V2, we should export a "StreamOptions" or somesuch that contains Stdin, Stdout, Stder and TTY
 *
 * @generated from message k8s.io.api.core.v1.PodExecOptions
 */
export declare type PodExecOptionsValid = Message<"k8s.io.api.core.v1.PodExecOptions"> & {
  /**
   * Redirect the standard input stream of the pod for this call.
   * Defaults to false.
   * +optional
   *
   * @generated from field: optional bool stdin = 1;
   */
  stdin: boolean;

  /**
   * Redirect the standard output stream of the pod for this call.
   * +optional
   *
   * @generated from field: optional bool stdout = 2;
   */
  stdout: boolean;

  /**
   * Redirect the standard error stream of the pod for this call.
   * +optional
   *
   * @generated from field: optional bool stderr = 3;
   */
  stderr: boolean;

  /**
   * TTY if true indicates that a tty will be allocated for the exec call.
   * Defaults to false.
   * +optional
   *
   * @generated from field: optional bool tty = 4;
   */
  tty: boolean;

  /**
   * Container in which to execute the command.
   * Defaults to only container if there is only one container in the pod.
   * +optional
   *
   * @generated from field: optional string container = 5;
   */
  container: string;

  /**
   * Command is the remote command to execute. argv array. Not executed within a shell.
   *
   * @generated from field: repeated string command = 6;
   */
  command: string[];
};

/**
 * Describes the message k8s.io.api.core.v1.PodExecOptions.
 * Use `create(PodExecOptionsSchema)` to create a new message.
 */
export declare const PodExecOptionsSchema: GenMessage<PodExecOptions, {validType: PodExecOptionsValid}>;

/**
 * IP address information for entries in the (plural) PodIPs field.
 * Each entry includes:
 *    IP: An IP address allocated to the pod. Routable at least within the cluster.
 *
 * @generated from message k8s.io.api.core.v1.PodIP
 */
export declare type PodIP = Message<"k8s.io.api.core.v1.PodIP"> & {
  /**
   * ip is an IP address (IPv4 or IPv6) assigned to the pod
   *
   * @generated from field: optional string ip = 1;
   */
  ip: string;
};

/**
 * IP address information for entries in the (plural) PodIPs field.
 * Each entry includes:
 *    IP: An IP address allocated to the pod. Routable at least within the cluster.
 *
 * @generated from message k8s.io.api.core.v1.PodIP
 */
export declare type PodIPValid = Message<"k8s.io.api.core.v1.PodIP"> & {
  /**
   * ip is an IP address (IPv4 or IPv6) assigned to the pod
   *
   * @generated from field: optional string ip = 1;
   */
  ip: string;
};

/**
 * Describes the message k8s.io.api.core.v1.PodIP.
 * Use `create(PodIPSchema)` to create a new message.
 */
export declare const PodIPSchema: GenMessage<PodIP, {validType: PodIPValid}>;

/**
 * PodList is a list of Pods.
 *
 * @generated from message k8s.io.api.core.v1.PodList
 */
export declare type PodList = Message<"k8s.io.api.core.v1.PodList"> & {
  /**
   * Standard list metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMeta;

  /**
   * List of pods.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
   *
   * @generated from field: repeated k8s.io.api.core.v1.Pod items = 2;
   */
  items: Pod[];
};

/**
 * PodList is a list of Pods.
 *
 * @generated from message k8s.io.api.core.v1.PodList
 */
export declare type PodListValid = Message<"k8s.io.api.core.v1.PodList"> & {
  /**
   * Standard list metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMetaValid;

  /**
   * List of pods.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
   *
   * @generated from field: repeated k8s.io.api.core.v1.Pod items = 2;
   */
  items: PodValid[];
};

/**
 * Describes the message k8s.io.api.core.v1.PodList.
 * Use `create(PodListSchema)` to create a new message.
 */
export declare const PodListSchema: GenMessage<PodList, {validType: PodListValid}>;

/**
 * PodLogOptions is the query options for a Pod's logs REST call.
 *
 * @generated from message k8s.io.api.core.v1.PodLogOptions
 */
export declare type PodLogOptions = Message<"k8s.io.api.core.v1.PodLogOptions"> & {
  /**
   * The container for which to stream logs. Defaults to only container if there is one container in the pod.
   * +optional
   *
   * @generated from field: optional string container = 1;
   */
  container: string;

  /**
   * Follow the log stream of the pod. Defaults to false.
   * +optional
   *
   * @generated from field: optional bool follow = 2;
   */
  follow: boolean;

  /**
   * Return previous terminated container logs. Defaults to false.
   * +optional
   *
   * @generated from field: optional bool previous = 3;
   */
  previous: boolean;

  /**
   * A relative time in seconds before the current time from which to show logs. If this value
   * precedes the time a pod was started, only logs since the pod start will be returned.
   * If this value is in the future, no logs will be returned.
   * Only one of sinceSeconds or sinceTime may be specified.
   * +optional
   *
   * @generated from field: optional int64 sinceSeconds = 4;
   */
  sinceSeconds: bigint;

  /**
   * An RFC3339 timestamp from which to show logs. If this value
   * precedes the time a pod was started, only logs since the pod start will be returned.
   * If this value is in the future, no logs will be returned.
   * Only one of sinceSeconds or sinceTime may be specified.
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time sinceTime = 5;
   */
  sinceTime?: Time;

  /**
   * If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line
   * of log output. Defaults to false.
   * +optional
   *
   * @generated from field: optional bool timestamps = 6;
   */
  timestamps: boolean;

  /**
   * If set, the number of lines from the end of the logs to show. If not specified,
   * logs are shown from the creation of the container or sinceSeconds or sinceTime
   * +optional
   *
   * @generated from field: optional int64 tailLines = 7;
   */
  tailLines: bigint;

  /**
   * If set, the number of bytes to read from the server before terminating the
   * log output. This may not display a complete final line of logging, and may return
   * slightly more or slightly less than the specified limit.
   * +optional
   *
   * @generated from field: optional int64 limitBytes = 8;
   */
  limitBytes: bigint;

  /**
   * insecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the
   * serving certificate of the backend it is connecting to.  This will make the HTTPS connection between the apiserver
   * and the backend insecure. This means the apiserver cannot verify the log data it is receiving came from the real
   * kubelet.  If the kubelet is configured to verify the apiserver's TLS credentials, it does not mean the
   * connection to the real kubelet is vulnerable to a man in the middle attack (e.g. an attacker could not intercept
   * the actual log data coming from the real kubelet).
   * +optional
   *
   * @generated from field: optional bool insecureSkipTLSVerifyBackend = 9;
   */
  insecureSkipTLSVerifyBackend: boolean;
};

/**
 * PodLogOptions is the query options for a Pod's logs REST call.
 *
 * @generated from message k8s.io.api.core.v1.PodLogOptions
 */
export declare type PodLogOptionsValid = Message<"k8s.io.api.core.v1.PodLogOptions"> & {
  /**
   * The container for which to stream logs. Defaults to only container if there is one container in the pod.
   * +optional
   *
   * @generated from field: optional string container = 1;
   */
  container: string;

  /**
   * Follow the log stream of the pod. Defaults to false.
   * +optional
   *
   * @generated from field: optional bool follow = 2;
   */
  follow: boolean;

  /**
   * Return previous terminated container logs. Defaults to false.
   * +optional
   *
   * @generated from field: optional bool previous = 3;
   */
  previous: boolean;

  /**
   * A relative time in seconds before the current time from which to show logs. If this value
   * precedes the time a pod was started, only logs since the pod start will be returned.
   * If this value is in the future, no logs will be returned.
   * Only one of sinceSeconds or sinceTime may be specified.
   * +optional
   *
   * @generated from field: optional int64 sinceSeconds = 4;
   */
  sinceSeconds: bigint;

  /**
   * An RFC3339 timestamp from which to show logs. If this value
   * precedes the time a pod was started, only logs since the pod start will be returned.
   * If this value is in the future, no logs will be returned.
   * Only one of sinceSeconds or sinceTime may be specified.
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time sinceTime = 5;
   */
  sinceTime?: TimeValid;

  /**
   * If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line
   * of log output. Defaults to false.
   * +optional
   *
   * @generated from field: optional bool timestamps = 6;
   */
  timestamps: boolean;

  /**
   * If set, the number of lines from the end of the logs to show. If not specified,
   * logs are shown from the creation of the container or sinceSeconds or sinceTime
   * +optional
   *
   * @generated from field: optional int64 tailLines = 7;
   */
  tailLines: bigint;

  /**
   * If set, the number of bytes to read from the server before terminating the
   * log output. This may not display a complete final line of logging, and may return
   * slightly more or slightly less than the specified limit.
   * +optional
   *
   * @generated from field: optional int64 limitBytes = 8;
   */
  limitBytes: bigint;

  /**
   * insecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the
   * serving certificate of the backend it is connecting to.  This will make the HTTPS connection between the apiserver
   * and the backend insecure. This means the apiserver cannot verify the log data it is receiving came from the real
   * kubelet.  If the kubelet is configured to verify the apiserver's TLS credentials, it does not mean the
   * connection to the real kubelet is vulnerable to a man in the middle attack (e.g. an attacker could not intercept
   * the actual log data coming from the real kubelet).
   * +optional
   *
   * @generated from field: optional bool insecureSkipTLSVerifyBackend = 9;
   */
  insecureSkipTLSVerifyBackend: boolean;
};

/**
 * Describes the message k8s.io.api.core.v1.PodLogOptions.
 * Use `create(PodLogOptionsSchema)` to create a new message.
 */
export declare const PodLogOptionsSchema: GenMessage<PodLogOptions, {validType: PodLogOptionsValid}>;

/**
 * PodOS defines the OS parameters of a pod.
 *
 * @generated from message k8s.io.api.core.v1.PodOS
 */
export declare type PodOS = Message<"k8s.io.api.core.v1.PodOS"> & {
  /**
   * Name is the name of the operating system. The currently supported values are linux and windows.
   * Additional value may be defined in future and can be one of:
   * https://github.com/opencontainers/runtime-spec/blob/master/config.md#platform-specific-configuration
   * Clients should expect to handle additional values and treat unrecognized values in this field as os: null
   *
   * @generated from field: optional string name = 1;
   */
  name: string;
};

/**
 * PodOS defines the OS parameters of a pod.
 *
 * @generated from message k8s.io.api.core.v1.PodOS
 */
export declare type PodOSValid = Message<"k8s.io.api.core.v1.PodOS"> & {
  /**
   * Name is the name of the operating system. The currently supported values are linux and windows.
   * Additional value may be defined in future and can be one of:
   * https://github.com/opencontainers/runtime-spec/blob/master/config.md#platform-specific-configuration
   * Clients should expect to handle additional values and treat unrecognized values in this field as os: null
   *
   * @generated from field: optional string name = 1;
   */
  name: string;
};

/**
 * Describes the message k8s.io.api.core.v1.PodOS.
 * Use `create(PodOSSchema)` to create a new message.
 */
export declare const PodOSSchema: GenMessage<PodOS, {validType: PodOSValid}>;

/**
 * PodPortForwardOptions is the query options to a Pod's port forward call
 * when using WebSockets.
 * The `port` query parameter must specify the port or
 * ports (comma separated) to forward over.
 * Port forwarding over SPDY does not use these options. It requires the port
 * to be passed in the `port` header as part of request.
 *
 * @generated from message k8s.io.api.core.v1.PodPortForwardOptions
 */
export declare type PodPortForwardOptions = Message<"k8s.io.api.core.v1.PodPortForwardOptions"> & {
  /**
   * List of ports to forward
   * Required when using WebSockets
   * +optional
   *
   * @generated from field: repeated int32 ports = 1;
   */
  ports: number[];
};

/**
 * PodPortForwardOptions is the query options to a Pod's port forward call
 * when using WebSockets.
 * The `port` query parameter must specify the port or
 * ports (comma separated) to forward over.
 * Port forwarding over SPDY does not use these options. It requires the port
 * to be passed in the `port` header as part of request.
 *
 * @generated from message k8s.io.api.core.v1.PodPortForwardOptions
 */
export declare type PodPortForwardOptionsValid = Message<"k8s.io.api.core.v1.PodPortForwardOptions"> & {
  /**
   * List of ports to forward
   * Required when using WebSockets
   * +optional
   *
   * @generated from field: repeated int32 ports = 1;
   */
  ports: number[];
};

/**
 * Describes the message k8s.io.api.core.v1.PodPortForwardOptions.
 * Use `create(PodPortForwardOptionsSchema)` to create a new message.
 */
export declare const PodPortForwardOptionsSchema: GenMessage<PodPortForwardOptions, {validType: PodPortForwardOptionsValid}>;

/**
 * PodProxyOptions is the query options to a Pod's proxy call.
 *
 * @generated from message k8s.io.api.core.v1.PodProxyOptions
 */
export declare type PodProxyOptions = Message<"k8s.io.api.core.v1.PodProxyOptions"> & {
  /**
   * Path is the URL path to use for the current proxy request to pod.
   * +optional
   *
   * @generated from field: optional string path = 1;
   */
  path: string;
};

/**
 * PodProxyOptions is the query options to a Pod's proxy call.
 *
 * @generated from message k8s.io.api.core.v1.PodProxyOptions
 */
export declare type PodProxyOptionsValid = Message<"k8s.io.api.core.v1.PodProxyOptions"> & {
  /**
   * Path is the URL path to use for the current proxy request to pod.
   * +optional
   *
   * @generated from field: optional string path = 1;
   */
  path: string;
};

/**
 * Describes the message k8s.io.api.core.v1.PodProxyOptions.
 * Use `create(PodProxyOptionsSchema)` to create a new message.
 */
export declare const PodProxyOptionsSchema: GenMessage<PodProxyOptions, {validType: PodProxyOptionsValid}>;

/**
 * PodReadinessGate contains the reference to a pod condition
 *
 * @generated from message k8s.io.api.core.v1.PodReadinessGate
 */
export declare type PodReadinessGate = Message<"k8s.io.api.core.v1.PodReadinessGate"> & {
  /**
   * ConditionType refers to a condition in the pod's condition list with matching type.
   *
   * @generated from field: optional string conditionType = 1;
   */
  conditionType: string;
};

/**
 * PodReadinessGate contains the reference to a pod condition
 *
 * @generated from message k8s.io.api.core.v1.PodReadinessGate
 */
export declare type PodReadinessGateValid = Message<"k8s.io.api.core.v1.PodReadinessGate"> & {
  /**
   * ConditionType refers to a condition in the pod's condition list with matching type.
   *
   * @generated from field: optional string conditionType = 1;
   */
  conditionType: string;
};

/**
 * Describes the message k8s.io.api.core.v1.PodReadinessGate.
 * Use `create(PodReadinessGateSchema)` to create a new message.
 */
export declare const PodReadinessGateSchema: GenMessage<PodReadinessGate, {validType: PodReadinessGateValid}>;

/**
 * PodSecurityContext holds pod-level security attributes and common container settings.
 * Some fields are also present in container.securityContext.  Field values of
 * container.securityContext take precedence over field values of PodSecurityContext.
 *
 * @generated from message k8s.io.api.core.v1.PodSecurityContext
 */
export declare type PodSecurityContext = Message<"k8s.io.api.core.v1.PodSecurityContext"> & {
  /**
   * The SELinux context to be applied to all containers.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in SecurityContext.  If set in
   * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
   * takes precedence for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.SELinuxOptions seLinuxOptions = 1;
   */
  seLinuxOptions?: SELinuxOptions;

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options within a container's SecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.WindowsSecurityContextOptions windowsOptions = 8;
   */
  windowsOptions?: WindowsSecurityContextOptions;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   *
   * @generated from field: optional int64 runAsUser = 2;
   */
  runAsUser: bigint;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   *
   * @generated from field: optional int64 runAsGroup = 6;
   */
  runAsGroup: bigint;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * +optional
   *
   * @generated from field: optional bool runAsNonRoot = 3;
   */
  runAsNonRoot: boolean;

  /**
   * A list of groups applied to the first process run in each container, in addition
   * to the container's primary GID.  If unspecified, no groups will be added to
   * any container.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   *
   * @generated from field: repeated int64 supplementalGroups = 4;
   */
  supplementalGroups: bigint[];

  /**
   * A special supplemental group that applies to all containers in a pod.
   * Some volume types allow the Kubelet to change the ownership of that volume
   * to be owned by the pod:
   *
   * 1. The owning GID will be the FSGroup
   * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
   * 3. The permission bits are OR'd with rw-rw----
   *
   * If unset, the Kubelet will not modify the ownership and permissions of any volume.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   *
   * @generated from field: optional int64 fsGroup = 5;
   */
  fsGroup: bigint;

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
   * sysctls (by the container runtime) might fail to launch.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.Sysctl sysctls = 7;
   */
  sysctls: Sysctl[];

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
   * before being exposed inside Pod. This field will only apply to
   * volume types which support fsGroup based ownership(and permissions).
   * It will have no effect on ephemeral volume types such as: secret, configmaps
   * and emptydir.
   * Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   *
   * @generated from field: optional string fsGroupChangePolicy = 9;
   */
  fsGroupChangePolicy: string;

  /**
   * The seccomp options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.SeccompProfile seccompProfile = 10;
   */
  seccompProfile?: SeccompProfile;
};

/**
 * PodSecurityContext holds pod-level security attributes and common container settings.
 * Some fields are also present in container.securityContext.  Field values of
 * container.securityContext take precedence over field values of PodSecurityContext.
 *
 * @generated from message k8s.io.api.core.v1.PodSecurityContext
 */
export declare type PodSecurityContextValid = Message<"k8s.io.api.core.v1.PodSecurityContext"> & {
  /**
   * The SELinux context to be applied to all containers.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in SecurityContext.  If set in
   * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
   * takes precedence for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.SELinuxOptions seLinuxOptions = 1;
   */
  seLinuxOptions?: SELinuxOptionsValid;

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options within a container's SecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.WindowsSecurityContextOptions windowsOptions = 8;
   */
  windowsOptions?: WindowsSecurityContextOptionsValid;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   *
   * @generated from field: optional int64 runAsUser = 2;
   */
  runAsUser: bigint;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence
   * for that container.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   *
   * @generated from field: optional int64 runAsGroup = 6;
   */
  runAsGroup: bigint;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in SecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * +optional
   *
   * @generated from field: optional bool runAsNonRoot = 3;
   */
  runAsNonRoot: boolean;

  /**
   * A list of groups applied to the first process run in each container, in addition
   * to the container's primary GID.  If unspecified, no groups will be added to
   * any container.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   *
   * @generated from field: repeated int64 supplementalGroups = 4;
   */
  supplementalGroups: bigint[];

  /**
   * A special supplemental group that applies to all containers in a pod.
   * Some volume types allow the Kubelet to change the ownership of that volume
   * to be owned by the pod:
   *
   * 1. The owning GID will be the FSGroup
   * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
   * 3. The permission bits are OR'd with rw-rw----
   *
   * If unset, the Kubelet will not modify the ownership and permissions of any volume.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   *
   * @generated from field: optional int64 fsGroup = 5;
   */
  fsGroup: bigint;

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
   * sysctls (by the container runtime) might fail to launch.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.Sysctl sysctls = 7;
   */
  sysctls: SysctlValid[];

  /**
   * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
   * before being exposed inside Pod. This field will only apply to
   * volume types which support fsGroup based ownership(and permissions).
   * It will have no effect on ephemeral volume types such as: secret, configmaps
   * and emptydir.
   * Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   *
   * @generated from field: optional string fsGroupChangePolicy = 9;
   */
  fsGroupChangePolicy: string;

  /**
   * The seccomp options to use by the containers in this pod.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.SeccompProfile seccompProfile = 10;
   */
  seccompProfile?: SeccompProfileValid;
};

/**
 * Describes the message k8s.io.api.core.v1.PodSecurityContext.
 * Use `create(PodSecurityContextSchema)` to create a new message.
 */
export declare const PodSecurityContextSchema: GenMessage<PodSecurityContext, {validType: PodSecurityContextValid}>;

/**
 * Describes the class of pods that should avoid this node.
 * Exactly one field should be set.
 *
 * @generated from message k8s.io.api.core.v1.PodSignature
 */
export declare type PodSignature = Message<"k8s.io.api.core.v1.PodSignature"> & {
  /**
   * Reference to controller whose pods should avoid this node.
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference podController = 1;
   */
  podController?: OwnerReference;
};

/**
 * Describes the class of pods that should avoid this node.
 * Exactly one field should be set.
 *
 * @generated from message k8s.io.api.core.v1.PodSignature
 */
export declare type PodSignatureValid = Message<"k8s.io.api.core.v1.PodSignature"> & {
  /**
   * Reference to controller whose pods should avoid this node.
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference podController = 1;
   */
  podController?: OwnerReferenceValid;
};

/**
 * Describes the message k8s.io.api.core.v1.PodSignature.
 * Use `create(PodSignatureSchema)` to create a new message.
 */
export declare const PodSignatureSchema: GenMessage<PodSignature, {validType: PodSignatureValid}>;

/**
 * PodSpec is a description of a pod.
 *
 * @generated from message k8s.io.api.core.v1.PodSpec
 */
export declare type PodSpec = Message<"k8s.io.api.core.v1.PodSpec"> & {
  /**
   * List of volumes that can be mounted by containers belonging to the pod.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes
   * +optional
   * +patchMergeKey=name
   * +patchStrategy=merge,retainKeys
   *
   * @generated from field: repeated k8s.io.api.core.v1.Volume volumes = 1;
   */
  volumes: Volume[];

  /**
   * List of initialization containers belonging to the pod.
   * Init containers are executed in order prior to containers being started. If any
   * init container fails, the pod is considered to have failed and is handled according
   * to its restartPolicy. The name for an init container or normal container must be
   * unique among all containers.
   * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
   * The resourceRequirements of an init container are taken into account during scheduling
   * by finding the highest request/limit for each resource type, and then using the max of
   * of that value or the sum of the normal containers. Limits are applied to init containers
   * in a similar fashion.
   * Init containers cannot currently be added or removed.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
   * +patchMergeKey=name
   * +patchStrategy=merge
   *
   * @generated from field: repeated k8s.io.api.core.v1.Container initContainers = 20;
   */
  initContainers: Container[];

  /**
   * List of containers belonging to the pod.
   * Containers cannot currently be added or removed.
   * There must be at least one container in a Pod.
   * Cannot be updated.
   * +patchMergeKey=name
   * +patchStrategy=merge
   *
   * @generated from field: repeated k8s.io.api.core.v1.Container containers = 2;
   */
  containers: Container[];

  /**
   * List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing
   * pod to perform user-initiated actions such as debugging. This list cannot be specified when
   * creating a pod, and it cannot be modified by updating the pod spec. In order to add an
   * ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.
   * This field is beta-level and available on clusters that haven't disabled the EphemeralContainers feature gate.
   * +optional
   * +patchMergeKey=name
   * +patchStrategy=merge
   *
   * @generated from field: repeated k8s.io.api.core.v1.EphemeralContainer ephemeralContainers = 34;
   */
  ephemeralContainers: EphemeralContainer[];

  /**
   * Restart policy for all containers within the pod.
   * One of Always, OnFailure, Never.
   * Default to Always.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
   * +optional
   *
   * @generated from field: optional string restartPolicy = 3;
   */
  restartPolicy: string;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * If this value is nil, the default grace period will be used instead.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * Defaults to 30 seconds.
   * +optional
   *
   * @generated from field: optional int64 terminationGracePeriodSeconds = 4;
   */
  terminationGracePeriodSeconds: bigint;

  /**
   * Optional duration in seconds the pod may be active on the node relative to
   * StartTime before the system will actively try to mark it failed and kill associated containers.
   * Value must be a positive integer.
   * +optional
   *
   * @generated from field: optional int64 activeDeadlineSeconds = 5;
   */
  activeDeadlineSeconds: bigint;

  /**
   * Set DNS policy for the pod.
   * Defaults to "ClusterFirst".
   * Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
   * DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
   * To have DNS options set along with hostNetwork, you have to specify DNS policy
   * explicitly to 'ClusterFirstWithHostNet'.
   * +optional
   *
   * @generated from field: optional string dnsPolicy = 6;
   */
  dnsPolicy: string;

  /**
   * NodeSelector is a selector which must be true for the pod to fit on a node.
   * Selector which must match a node's labels for the pod to be scheduled on that node.
   * More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
   * +optional
   * +mapType=atomic
   *
   * @generated from field: map<string, string> nodeSelector = 7;
   */
  nodeSelector: { [key: string]: string };

  /**
   * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
   * More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
   * +optional
   *
   * @generated from field: optional string serviceAccountName = 8;
   */
  serviceAccountName: string;

  /**
   * DeprecatedServiceAccount is a depreciated alias for ServiceAccountName.
   * Deprecated: Use serviceAccountName instead.
   * +k8s:conversion-gen=false
   * +optional
   *
   * @generated from field: optional string serviceAccount = 9;
   */
  serviceAccount: string;

  /**
   * AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
   * +optional
   *
   * @generated from field: optional bool automountServiceAccountToken = 21;
   */
  automountServiceAccountToken: boolean;

  /**
   * NodeName is a request to schedule this pod onto a specific node. If it is non-empty,
   * the scheduler simply schedules this pod onto that node, assuming that it fits resource
   * requirements.
   * +optional
   *
   * @generated from field: optional string nodeName = 10;
   */
  nodeName: string;

  /**
   * Host networking requested for this pod. Use the host's network namespace.
   * If this option is set, the ports that will be used must be specified.
   * Default to false.
   * +k8s:conversion-gen=false
   * +optional
   *
   * @generated from field: optional bool hostNetwork = 11;
   */
  hostNetwork: boolean;

  /**
   * Use the host's pid namespace.
   * Optional: Default to false.
   * +k8s:conversion-gen=false
   * +optional
   *
   * @generated from field: optional bool hostPID = 12;
   */
  hostPID: boolean;

  /**
   * Use the host's ipc namespace.
   * Optional: Default to false.
   * +k8s:conversion-gen=false
   * +optional
   *
   * @generated from field: optional bool hostIPC = 13;
   */
  hostIPC: boolean;

  /**
   * Share a single process namespace between all of the containers in a pod.
   * When this is set containers will be able to view and signal processes from other containers
   * in the same pod, and the first process in each container will not be assigned PID 1.
   * HostPID and ShareProcessNamespace cannot both be set.
   * Optional: Default to false.
   * +k8s:conversion-gen=false
   * +optional
   *
   * @generated from field: optional bool shareProcessNamespace = 27;
   */
  shareProcessNamespace: boolean;

  /**
   * SecurityContext holds pod-level security attributes and common container settings.
   * Optional: Defaults to empty.  See type description for default values of each field.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.PodSecurityContext securityContext = 14;
   */
  securityContext?: PodSecurityContext;

  /**
   * ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
   * If specified, these secrets will be passed to individual puller implementations for them to use. For example,
   * in the case of docker, only DockerConfig type secrets are honored.
   * More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
   * +optional
   * +patchMergeKey=name
   * +patchStrategy=merge
   *
   * @generated from field: repeated k8s.io.api.core.v1.LocalObjectReference imagePullSecrets = 15;
   */
  imagePullSecrets: LocalObjectReference[];

  /**
   * Specifies the hostname of the Pod
   * If not specified, the pod's hostname will be set to a system-defined value.
   * +optional
   *
   * @generated from field: optional string hostname = 16;
   */
  hostname: string;

  /**
   * If specified, the fully qualified Pod hostname will be "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>".
   * If not specified, the pod will not have a domainname at all.
   * +optional
   *
   * @generated from field: optional string subdomain = 17;
   */
  subdomain: string;

  /**
   * If specified, the pod's scheduling constraints
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.Affinity affinity = 18;
   */
  affinity?: Affinity;

  /**
   * If specified, the pod will be dispatched by specified scheduler.
   * If not specified, the pod will be dispatched by default scheduler.
   * +optional
   *
   * @generated from field: optional string schedulerName = 19;
   */
  schedulerName: string;

  /**
   * If specified, the pod's tolerations.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.Toleration tolerations = 22;
   */
  tolerations: Toleration[];

  /**
   * HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts
   * file if specified. This is only valid for non-hostNetwork pods.
   * +optional
   * +patchMergeKey=ip
   * +patchStrategy=merge
   *
   * @generated from field: repeated k8s.io.api.core.v1.HostAlias hostAliases = 23;
   */
  hostAliases: HostAlias[];

  /**
   * If specified, indicates the pod's priority. "system-node-critical" and
   * "system-cluster-critical" are two special keywords which indicate the
   * highest priorities with the former being the highest priority. Any other
   * name must be defined by creating a PriorityClass object with that name.
   * If not specified, the pod priority will be default or zero if there is no
   * default.
   * +optional
   *
   * @generated from field: optional string priorityClassName = 24;
   */
  priorityClassName: string;

  /**
   * The priority value. Various system components use this field to find the
   * priority of the pod. When Priority Admission Controller is enabled, it
   * prevents users from setting this field. The admission controller populates
   * this field from PriorityClassName.
   * The higher the value, the higher the priority.
   * +optional
   *
   * @generated from field: optional int32 priority = 25;
   */
  priority: number;

  /**
   * Specifies the DNS parameters of a pod.
   * Parameters specified here will be merged to the generated DNS
   * configuration based on DNSPolicy.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.PodDNSConfig dnsConfig = 26;
   */
  dnsConfig?: PodDNSConfig;

  /**
   * If specified, all readiness gates will be evaluated for pod readiness.
   * A pod is ready when all its containers are ready AND
   * all conditions specified in the readiness gates have status equal to "True"
   * More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.PodReadinessGate readinessGates = 28;
   */
  readinessGates: PodReadinessGate[];

  /**
   * RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used
   * to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run.
   * If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an
   * empty definition that uses the default runtime handler.
   * More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class
   * +optional
   *
   * @generated from field: optional string runtimeClassName = 29;
   */
  runtimeClassName: string;

  /**
   * EnableServiceLinks indicates whether information about services should be injected into pod's
   * environment variables, matching the syntax of Docker links.
   * Optional: Defaults to true.
   * +optional
   *
   * @generated from field: optional bool enableServiceLinks = 30;
   */
  enableServiceLinks: boolean;

  /**
   * PreemptionPolicy is the Policy for preempting pods with lower priority.
   * One of Never, PreemptLowerPriority.
   * Defaults to PreemptLowerPriority if unset.
   * +optional
   *
   * @generated from field: optional string preemptionPolicy = 31;
   */
  preemptionPolicy: string;

  /**
   * Overhead represents the resource overhead associated with running a pod for a given RuntimeClass.
   * This field will be autopopulated at admission time by the RuntimeClass admission controller. If
   * the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests.
   * The RuntimeClass admission controller will reject Pod create requests which have the overhead already
   * set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value
   * defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero.
   * More info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md
   * This field is beta-level as of Kubernetes v1.18, and is only honored by servers that enable the PodOverhead feature.
   * +optional
   *
   * @generated from field: map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> overhead = 32;
   */
  overhead: { [key: string]: Quantity };

  /**
   * TopologySpreadConstraints describes how a group of pods ought to spread across topology
   * domains. Scheduler will schedule pods in a way which abides by the constraints.
   * All topologySpreadConstraints are ANDed.
   * +optional
   * +patchMergeKey=topologyKey
   * +patchStrategy=merge
   * +listType=map
   * +listMapKey=topologyKey
   * +listMapKey=whenUnsatisfiable
   *
   * @generated from field: repeated k8s.io.api.core.v1.TopologySpreadConstraint topologySpreadConstraints = 33;
   */
  topologySpreadConstraints: TopologySpreadConstraint[];

  /**
   * If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default).
   * In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname).
   * In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN.
   * If a pod does not have FQDN, this has no effect.
   * Default to false.
   * +optional
   *
   * @generated from field: optional bool setHostnameAsFQDN = 35;
   */
  setHostnameAsFQDN: boolean;

  /**
   * Specifies the OS of the containers in the pod.
   * Some pod and container fields are restricted if this is set.
   *
   * If the OS field is set to linux, the following fields must be unset:
   * -securityContext.windowsOptions
   *
   * If the OS field is set to windows, following fields must be unset:
   * - spec.hostPID
   * - spec.hostIPC
   * - spec.securityContext.seLinuxOptions
   * - spec.securityContext.seccompProfile
   * - spec.securityContext.fsGroup
   * - spec.securityContext.fsGroupChangePolicy
   * - spec.securityContext.sysctls
   * - spec.shareProcessNamespace
   * - spec.securityContext.runAsUser
   * - spec.securityContext.runAsGroup
   * - spec.securityContext.supplementalGroups
   * - spec.containers[*].securityContext.seLinuxOptions
   * - spec.containers[*].securityContext.seccompProfile
   * - spec.containers[*].securityContext.capabilities
   * - spec.containers[*].securityContext.readOnlyRootFilesystem
   * - spec.containers[*].securityContext.privileged
   * - spec.containers[*].securityContext.allowPrivilegeEscalation
   * - spec.containers[*].securityContext.procMount
   * - spec.containers[*].securityContext.runAsUser
   * - spec.containers[*].securityContext.runAsGroup
   * +optional
   * This is an alpha field and requires the IdentifyPodOS feature
   *
   * @generated from field: optional k8s.io.api.core.v1.PodOS os = 36;
   */
  os?: PodOS;
};

/**
 * PodSpec is a description of a pod.
 *
 * @generated from message k8s.io.api.core.v1.PodSpec
 */
export declare type PodSpecValid = Message<"k8s.io.api.core.v1.PodSpec"> & {
  /**
   * List of volumes that can be mounted by containers belonging to the pod.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes
   * +optional
   * +patchMergeKey=name
   * +patchStrategy=merge,retainKeys
   *
   * @generated from field: repeated k8s.io.api.core.v1.Volume volumes = 1;
   */
  volumes: VolumeValid[];

  /**
   * List of initialization containers belonging to the pod.
   * Init containers are executed in order prior to containers being started. If any
   * init container fails, the pod is considered to have failed and is handled according
   * to its restartPolicy. The name for an init container or normal container must be
   * unique among all containers.
   * Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
   * The resourceRequirements of an init container are taken into account during scheduling
   * by finding the highest request/limit for each resource type, and then using the max of
   * of that value or the sum of the normal containers. Limits are applied to init containers
   * in a similar fashion.
   * Init containers cannot currently be added or removed.
   * Cannot be updated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
   * +patchMergeKey=name
   * +patchStrategy=merge
   *
   * @generated from field: repeated k8s.io.api.core.v1.Container initContainers = 20;
   */
  initContainers: ContainerValid[];

  /**
   * List of containers belonging to the pod.
   * Containers cannot currently be added or removed.
   * There must be at least one container in a Pod.
   * Cannot be updated.
   * +patchMergeKey=name
   * +patchStrategy=merge
   *
   * @generated from field: repeated k8s.io.api.core.v1.Container containers = 2;
   */
  containers: ContainerValid[];

  /**
   * List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing
   * pod to perform user-initiated actions such as debugging. This list cannot be specified when
   * creating a pod, and it cannot be modified by updating the pod spec. In order to add an
   * ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.
   * This field is beta-level and available on clusters that haven't disabled the EphemeralContainers feature gate.
   * +optional
   * +patchMergeKey=name
   * +patchStrategy=merge
   *
   * @generated from field: repeated k8s.io.api.core.v1.EphemeralContainer ephemeralContainers = 34;
   */
  ephemeralContainers: EphemeralContainerValid[];

  /**
   * Restart policy for all containers within the pod.
   * One of Always, OnFailure, Never.
   * Default to Always.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
   * +optional
   *
   * @generated from field: optional string restartPolicy = 3;
   */
  restartPolicy: string;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * If this value is nil, the default grace period will be used instead.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * Defaults to 30 seconds.
   * +optional
   *
   * @generated from field: optional int64 terminationGracePeriodSeconds = 4;
   */
  terminationGracePeriodSeconds: bigint;

  /**
   * Optional duration in seconds the pod may be active on the node relative to
   * StartTime before the system will actively try to mark it failed and kill associated containers.
   * Value must be a positive integer.
   * +optional
   *
   * @generated from field: optional int64 activeDeadlineSeconds = 5;
   */
  activeDeadlineSeconds: bigint;

  /**
   * Set DNS policy for the pod.
   * Defaults to "ClusterFirst".
   * Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
   * DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
   * To have DNS options set along with hostNetwork, you have to specify DNS policy
   * explicitly to 'ClusterFirstWithHostNet'.
   * +optional
   *
   * @generated from field: optional string dnsPolicy = 6;
   */
  dnsPolicy: string;

  /**
   * NodeSelector is a selector which must be true for the pod to fit on a node.
   * Selector which must match a node's labels for the pod to be scheduled on that node.
   * More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
   * +optional
   * +mapType=atomic
   *
   * @generated from field: map<string, string> nodeSelector = 7;
   */
  nodeSelector: { [key: string]: string };

  /**
   * ServiceAccountName is the name of the ServiceAccount to use to run this pod.
   * More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
   * +optional
   *
   * @generated from field: optional string serviceAccountName = 8;
   */
  serviceAccountName: string;

  /**
   * DeprecatedServiceAccount is a depreciated alias for ServiceAccountName.
   * Deprecated: Use serviceAccountName instead.
   * +k8s:conversion-gen=false
   * +optional
   *
   * @generated from field: optional string serviceAccount = 9;
   */
  serviceAccount: string;

  /**
   * AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
   * +optional
   *
   * @generated from field: optional bool automountServiceAccountToken = 21;
   */
  automountServiceAccountToken: boolean;

  /**
   * NodeName is a request to schedule this pod onto a specific node. If it is non-empty,
   * the scheduler simply schedules this pod onto that node, assuming that it fits resource
   * requirements.
   * +optional
   *
   * @generated from field: optional string nodeName = 10;
   */
  nodeName: string;

  /**
   * Host networking requested for this pod. Use the host's network namespace.
   * If this option is set, the ports that will be used must be specified.
   * Default to false.
   * +k8s:conversion-gen=false
   * +optional
   *
   * @generated from field: optional bool hostNetwork = 11;
   */
  hostNetwork: boolean;

  /**
   * Use the host's pid namespace.
   * Optional: Default to false.
   * +k8s:conversion-gen=false
   * +optional
   *
   * @generated from field: optional bool hostPID = 12;
   */
  hostPID: boolean;

  /**
   * Use the host's ipc namespace.
   * Optional: Default to false.
   * +k8s:conversion-gen=false
   * +optional
   *
   * @generated from field: optional bool hostIPC = 13;
   */
  hostIPC: boolean;

  /**
   * Share a single process namespace between all of the containers in a pod.
   * When this is set containers will be able to view and signal processes from other containers
   * in the same pod, and the first process in each container will not be assigned PID 1.
   * HostPID and ShareProcessNamespace cannot both be set.
   * Optional: Default to false.
   * +k8s:conversion-gen=false
   * +optional
   *
   * @generated from field: optional bool shareProcessNamespace = 27;
   */
  shareProcessNamespace: boolean;

  /**
   * SecurityContext holds pod-level security attributes and common container settings.
   * Optional: Defaults to empty.  See type description for default values of each field.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.PodSecurityContext securityContext = 14;
   */
  securityContext?: PodSecurityContextValid;

  /**
   * ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
   * If specified, these secrets will be passed to individual puller implementations for them to use. For example,
   * in the case of docker, only DockerConfig type secrets are honored.
   * More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
   * +optional
   * +patchMergeKey=name
   * +patchStrategy=merge
   *
   * @generated from field: repeated k8s.io.api.core.v1.LocalObjectReference imagePullSecrets = 15;
   */
  imagePullSecrets: LocalObjectReferenceValid[];

  /**
   * Specifies the hostname of the Pod
   * If not specified, the pod's hostname will be set to a system-defined value.
   * +optional
   *
   * @generated from field: optional string hostname = 16;
   */
  hostname: string;

  /**
   * If specified, the fully qualified Pod hostname will be "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>".
   * If not specified, the pod will not have a domainname at all.
   * +optional
   *
   * @generated from field: optional string subdomain = 17;
   */
  subdomain: string;

  /**
   * If specified, the pod's scheduling constraints
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.Affinity affinity = 18;
   */
  affinity?: AffinityValid;

  /**
   * If specified, the pod will be dispatched by specified scheduler.
   * If not specified, the pod will be dispatched by default scheduler.
   * +optional
   *
   * @generated from field: optional string schedulerName = 19;
   */
  schedulerName: string;

  /**
   * If specified, the pod's tolerations.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.Toleration tolerations = 22;
   */
  tolerations: TolerationValid[];

  /**
   * HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts
   * file if specified. This is only valid for non-hostNetwork pods.
   * +optional
   * +patchMergeKey=ip
   * +patchStrategy=merge
   *
   * @generated from field: repeated k8s.io.api.core.v1.HostAlias hostAliases = 23;
   */
  hostAliases: HostAliasValid[];

  /**
   * If specified, indicates the pod's priority. "system-node-critical" and
   * "system-cluster-critical" are two special keywords which indicate the
   * highest priorities with the former being the highest priority. Any other
   * name must be defined by creating a PriorityClass object with that name.
   * If not specified, the pod priority will be default or zero if there is no
   * default.
   * +optional
   *
   * @generated from field: optional string priorityClassName = 24;
   */
  priorityClassName: string;

  /**
   * The priority value. Various system components use this field to find the
   * priority of the pod. When Priority Admission Controller is enabled, it
   * prevents users from setting this field. The admission controller populates
   * this field from PriorityClassName.
   * The higher the value, the higher the priority.
   * +optional
   *
   * @generated from field: optional int32 priority = 25;
   */
  priority: number;

  /**
   * Specifies the DNS parameters of a pod.
   * Parameters specified here will be merged to the generated DNS
   * configuration based on DNSPolicy.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.PodDNSConfig dnsConfig = 26;
   */
  dnsConfig?: PodDNSConfigValid;

  /**
   * If specified, all readiness gates will be evaluated for pod readiness.
   * A pod is ready when all its containers are ready AND
   * all conditions specified in the readiness gates have status equal to "True"
   * More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.PodReadinessGate readinessGates = 28;
   */
  readinessGates: PodReadinessGateValid[];

  /**
   * RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used
   * to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run.
   * If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an
   * empty definition that uses the default runtime handler.
   * More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class
   * +optional
   *
   * @generated from field: optional string runtimeClassName = 29;
   */
  runtimeClassName: string;

  /**
   * EnableServiceLinks indicates whether information about services should be injected into pod's
   * environment variables, matching the syntax of Docker links.
   * Optional: Defaults to true.
   * +optional
   *
   * @generated from field: optional bool enableServiceLinks = 30;
   */
  enableServiceLinks: boolean;

  /**
   * PreemptionPolicy is the Policy for preempting pods with lower priority.
   * One of Never, PreemptLowerPriority.
   * Defaults to PreemptLowerPriority if unset.
   * +optional
   *
   * @generated from field: optional string preemptionPolicy = 31;
   */
  preemptionPolicy: string;

  /**
   * Overhead represents the resource overhead associated with running a pod for a given RuntimeClass.
   * This field will be autopopulated at admission time by the RuntimeClass admission controller. If
   * the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests.
   * The RuntimeClass admission controller will reject Pod create requests which have the overhead already
   * set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value
   * defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero.
   * More info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md
   * This field is beta-level as of Kubernetes v1.18, and is only honored by servers that enable the PodOverhead feature.
   * +optional
   *
   * @generated from field: map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> overhead = 32;
   */
  overhead: { [key: string]: QuantityValid };

  /**
   * TopologySpreadConstraints describes how a group of pods ought to spread across topology
   * domains. Scheduler will schedule pods in a way which abides by the constraints.
   * All topologySpreadConstraints are ANDed.
   * +optional
   * +patchMergeKey=topologyKey
   * +patchStrategy=merge
   * +listType=map
   * +listMapKey=topologyKey
   * +listMapKey=whenUnsatisfiable
   *
   * @generated from field: repeated k8s.io.api.core.v1.TopologySpreadConstraint topologySpreadConstraints = 33;
   */
  topologySpreadConstraints: TopologySpreadConstraintValid[];

  /**
   * If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default).
   * In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname).
   * In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN.
   * If a pod does not have FQDN, this has no effect.
   * Default to false.
   * +optional
   *
   * @generated from field: optional bool setHostnameAsFQDN = 35;
   */
  setHostnameAsFQDN: boolean;

  /**
   * Specifies the OS of the containers in the pod.
   * Some pod and container fields are restricted if this is set.
   *
   * If the OS field is set to linux, the following fields must be unset:
   * -securityContext.windowsOptions
   *
   * If the OS field is set to windows, following fields must be unset:
   * - spec.hostPID
   * - spec.hostIPC
   * - spec.securityContext.seLinuxOptions
   * - spec.securityContext.seccompProfile
   * - spec.securityContext.fsGroup
   * - spec.securityContext.fsGroupChangePolicy
   * - spec.securityContext.sysctls
   * - spec.shareProcessNamespace
   * - spec.securityContext.runAsUser
   * - spec.securityContext.runAsGroup
   * - spec.securityContext.supplementalGroups
   * - spec.containers[*].securityContext.seLinuxOptions
   * - spec.containers[*].securityContext.seccompProfile
   * - spec.containers[*].securityContext.capabilities
   * - spec.containers[*].securityContext.readOnlyRootFilesystem
   * - spec.containers[*].securityContext.privileged
   * - spec.containers[*].securityContext.allowPrivilegeEscalation
   * - spec.containers[*].securityContext.procMount
   * - spec.containers[*].securityContext.runAsUser
   * - spec.containers[*].securityContext.runAsGroup
   * +optional
   * This is an alpha field and requires the IdentifyPodOS feature
   *
   * @generated from field: optional k8s.io.api.core.v1.PodOS os = 36;
   */
  os?: PodOSValid;
};

/**
 * Describes the message k8s.io.api.core.v1.PodSpec.
 * Use `create(PodSpecSchema)` to create a new message.
 */
export declare const PodSpecSchema: GenMessage<PodSpec, {validType: PodSpecValid}>;

/**
 * PodStatus represents information about the status of a pod. Status may trail the actual
 * state of a system, especially if the node that hosts the pod cannot contact the control
 * plane.
 *
 * @generated from message k8s.io.api.core.v1.PodStatus
 */
export declare type PodStatus = Message<"k8s.io.api.core.v1.PodStatus"> & {
  /**
   * The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle.
   * The conditions array, the reason and message fields, and the individual container status
   * arrays contain more detail about the pod's status.
   * There are five possible phase values:
   *
   * Pending: The pod has been accepted by the Kubernetes system, but one or more of the
   * container images has not been created. This includes time before being scheduled as
   * well as time spent downloading images over the network, which could take a while.
   * Running: The pod has been bound to a node, and all of the containers have been created.
   * At least one container is still running, or is in the process of starting or restarting.
   * Succeeded: All containers in the pod have terminated in success, and will not be restarted.
   * Failed: All containers in the pod have terminated, and at least one container has
   * terminated in failure. The container either exited with non-zero status or was terminated
   * by the system.
   * Unknown: For some reason the state of the pod could not be obtained, typically due to an
   * error in communicating with the host of the pod.
   *
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase
   * +optional
   *
   * @generated from field: optional string phase = 1;
   */
  phase: string;

  /**
   * Current service state of pod.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
   * +optional
   * +patchMergeKey=type
   * +patchStrategy=merge
   *
   * @generated from field: repeated k8s.io.api.core.v1.PodCondition conditions = 2;
   */
  conditions: PodCondition[];

  /**
   * A human readable message indicating details about why the pod is in this condition.
   * +optional
   *
   * @generated from field: optional string message = 3;
   */
  message: string;

  /**
   * A brief CamelCase message indicating details about why the pod is in this state.
   * e.g. 'Evicted'
   * +optional
   *
   * @generated from field: optional string reason = 4;
   */
  reason: string;

  /**
   * nominatedNodeName is set only when this pod preempts other pods on the node, but it cannot be
   * scheduled right away as preemption victims receive their graceful termination periods.
   * This field does not guarantee that the pod will be scheduled on this node. Scheduler may decide
   * to place the pod elsewhere if other nodes become available sooner. Scheduler may also decide to
   * give the resources on this node to a higher priority pod that is created after preemption.
   * As a result, this field may be different than PodSpec.nodeName when the pod is
   * scheduled.
   * +optional
   *
   * @generated from field: optional string nominatedNodeName = 11;
   */
  nominatedNodeName: string;

  /**
   * IP address of the host to which the pod is assigned. Empty if not yet scheduled.
   * +optional
   *
   * @generated from field: optional string hostIP = 5;
   */
  hostIP: string;

  /**
   * IP address allocated to the pod. Routable at least within the cluster.
   * Empty if not yet allocated.
   * +optional
   *
   * @generated from field: optional string podIP = 6;
   */
  podIP: string;

  /**
   * podIPs holds the IP addresses allocated to the pod. If this field is specified, the 0th entry must
   * match the podIP field. Pods may be allocated at most 1 value for each of IPv4 and IPv6. This list
   * is empty if no IPs have been allocated yet.
   * +optional
   * +patchStrategy=merge
   * +patchMergeKey=ip
   *
   * @generated from field: repeated k8s.io.api.core.v1.PodIP podIPs = 12;
   */
  podIPs: PodIP[];

  /**
   * RFC 3339 date and time at which the object was acknowledged by the Kubelet.
   * This is before the Kubelet pulled the container image(s) for the pod.
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time startTime = 7;
   */
  startTime?: Time;

  /**
   * The list has one entry per init container in the manifest. The most recent successful
   * init container will have ready = true, the most recently started container will have
   * startTime set.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
   *
   * @generated from field: repeated k8s.io.api.core.v1.ContainerStatus initContainerStatuses = 10;
   */
  initContainerStatuses: ContainerStatus[];

  /**
   * The list has one entry per container in the manifest.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.ContainerStatus containerStatuses = 8;
   */
  containerStatuses: ContainerStatus[];

  /**
   * The Quality of Service (QOS) classification assigned to the pod based on resource requirements
   * See PodQOSClass type for available QOS classes
   * More info: https://git.k8s.io/community/contributors/design-proposals/node/resource-qos.md
   * +optional
   *
   * @generated from field: optional string qosClass = 9;
   */
  qosClass: string;

  /**
   * Status for any ephemeral containers that have run in this pod.
   * This field is beta-level and available on clusters that haven't disabled the EphemeralContainers feature gate.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.ContainerStatus ephemeralContainerStatuses = 13;
   */
  ephemeralContainerStatuses: ContainerStatus[];
};

/**
 * PodStatus represents information about the status of a pod. Status may trail the actual
 * state of a system, especially if the node that hosts the pod cannot contact the control
 * plane.
 *
 * @generated from message k8s.io.api.core.v1.PodStatus
 */
export declare type PodStatusValid = Message<"k8s.io.api.core.v1.PodStatus"> & {
  /**
   * The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle.
   * The conditions array, the reason and message fields, and the individual container status
   * arrays contain more detail about the pod's status.
   * There are five possible phase values:
   *
   * Pending: The pod has been accepted by the Kubernetes system, but one or more of the
   * container images has not been created. This includes time before being scheduled as
   * well as time spent downloading images over the network, which could take a while.
   * Running: The pod has been bound to a node, and all of the containers have been created.
   * At least one container is still running, or is in the process of starting or restarting.
   * Succeeded: All containers in the pod have terminated in success, and will not be restarted.
   * Failed: All containers in the pod have terminated, and at least one container has
   * terminated in failure. The container either exited with non-zero status or was terminated
   * by the system.
   * Unknown: For some reason the state of the pod could not be obtained, typically due to an
   * error in communicating with the host of the pod.
   *
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase
   * +optional
   *
   * @generated from field: optional string phase = 1;
   */
  phase: string;

  /**
   * Current service state of pod.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
   * +optional
   * +patchMergeKey=type
   * +patchStrategy=merge
   *
   * @generated from field: repeated k8s.io.api.core.v1.PodCondition conditions = 2;
   */
  conditions: PodConditionValid[];

  /**
   * A human readable message indicating details about why the pod is in this condition.
   * +optional
   *
   * @generated from field: optional string message = 3;
   */
  message: string;

  /**
   * A brief CamelCase message indicating details about why the pod is in this state.
   * e.g. 'Evicted'
   * +optional
   *
   * @generated from field: optional string reason = 4;
   */
  reason: string;

  /**
   * nominatedNodeName is set only when this pod preempts other pods on the node, but it cannot be
   * scheduled right away as preemption victims receive their graceful termination periods.
   * This field does not guarantee that the pod will be scheduled on this node. Scheduler may decide
   * to place the pod elsewhere if other nodes become available sooner. Scheduler may also decide to
   * give the resources on this node to a higher priority pod that is created after preemption.
   * As a result, this field may be different than PodSpec.nodeName when the pod is
   * scheduled.
   * +optional
   *
   * @generated from field: optional string nominatedNodeName = 11;
   */
  nominatedNodeName: string;

  /**
   * IP address of the host to which the pod is assigned. Empty if not yet scheduled.
   * +optional
   *
   * @generated from field: optional string hostIP = 5;
   */
  hostIP: string;

  /**
   * IP address allocated to the pod. Routable at least within the cluster.
   * Empty if not yet allocated.
   * +optional
   *
   * @generated from field: optional string podIP = 6;
   */
  podIP: string;

  /**
   * podIPs holds the IP addresses allocated to the pod. If this field is specified, the 0th entry must
   * match the podIP field. Pods may be allocated at most 1 value for each of IPv4 and IPv6. This list
   * is empty if no IPs have been allocated yet.
   * +optional
   * +patchStrategy=merge
   * +patchMergeKey=ip
   *
   * @generated from field: repeated k8s.io.api.core.v1.PodIP podIPs = 12;
   */
  podIPs: PodIPValid[];

  /**
   * RFC 3339 date and time at which the object was acknowledged by the Kubelet.
   * This is before the Kubelet pulled the container image(s) for the pod.
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time startTime = 7;
   */
  startTime?: TimeValid;

  /**
   * The list has one entry per init container in the manifest. The most recent successful
   * init container will have ready = true, the most recently started container will have
   * startTime set.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
   *
   * @generated from field: repeated k8s.io.api.core.v1.ContainerStatus initContainerStatuses = 10;
   */
  initContainerStatuses: ContainerStatusValid[];

  /**
   * The list has one entry per container in the manifest.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.ContainerStatus containerStatuses = 8;
   */
  containerStatuses: ContainerStatusValid[];

  /**
   * The Quality of Service (QOS) classification assigned to the pod based on resource requirements
   * See PodQOSClass type for available QOS classes
   * More info: https://git.k8s.io/community/contributors/design-proposals/node/resource-qos.md
   * +optional
   *
   * @generated from field: optional string qosClass = 9;
   */
  qosClass: string;

  /**
   * Status for any ephemeral containers that have run in this pod.
   * This field is beta-level and available on clusters that haven't disabled the EphemeralContainers feature gate.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.ContainerStatus ephemeralContainerStatuses = 13;
   */
  ephemeralContainerStatuses: ContainerStatusValid[];
};

/**
 * Describes the message k8s.io.api.core.v1.PodStatus.
 * Use `create(PodStatusSchema)` to create a new message.
 */
export declare const PodStatusSchema: GenMessage<PodStatus, {validType: PodStatusValid}>;

/**
 * PodStatusResult is a wrapper for PodStatus returned by kubelet that can be encode/decoded
 *
 * @generated from message k8s.io.api.core.v1.PodStatusResult
 */
export declare type PodStatusResult = Message<"k8s.io.api.core.v1.PodStatusResult"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMeta;

  /**
   * Most recently observed status of the pod.
   * This data may not be up to date.
   * Populated by the system.
   * Read-only.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.PodStatus status = 2;
   */
  status?: PodStatus;
};

/**
 * PodStatusResult is a wrapper for PodStatus returned by kubelet that can be encode/decoded
 *
 * @generated from message k8s.io.api.core.v1.PodStatusResult
 */
export declare type PodStatusResultValid = Message<"k8s.io.api.core.v1.PodStatusResult"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMetaValid;

  /**
   * Most recently observed status of the pod.
   * This data may not be up to date.
   * Populated by the system.
   * Read-only.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.PodStatus status = 2;
   */
  status?: PodStatusValid;
};

/**
 * Describes the message k8s.io.api.core.v1.PodStatusResult.
 * Use `create(PodStatusResultSchema)` to create a new message.
 */
export declare const PodStatusResultSchema: GenMessage<PodStatusResult, {validType: PodStatusResultValid}>;

/**
 * PodTemplate describes a template for creating copies of a predefined pod.
 *
 * @generated from message k8s.io.api.core.v1.PodTemplate
 */
export declare type PodTemplate = Message<"k8s.io.api.core.v1.PodTemplate"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMeta;

  /**
   * Template defines the pods that will be created from this pod template.
   * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.PodTemplateSpec template = 2;
   */
  template?: PodTemplateSpec;
};

/**
 * PodTemplate describes a template for creating copies of a predefined pod.
 *
 * @generated from message k8s.io.api.core.v1.PodTemplate
 */
export declare type PodTemplateValid = Message<"k8s.io.api.core.v1.PodTemplate"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMetaValid;

  /**
   * Template defines the pods that will be created from this pod template.
   * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.PodTemplateSpec template = 2;
   */
  template?: PodTemplateSpecValid;
};

/**
 * Describes the message k8s.io.api.core.v1.PodTemplate.
 * Use `create(PodTemplateSchema)` to create a new message.
 */
export declare const PodTemplateSchema: GenMessage<PodTemplate, {validType: PodTemplateValid}>;

/**
 * PodTemplateList is a list of PodTemplates.
 *
 * @generated from message k8s.io.api.core.v1.PodTemplateList
 */
export declare type PodTemplateList = Message<"k8s.io.api.core.v1.PodTemplateList"> & {
  /**
   * Standard list metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMeta;

  /**
   * List of pod templates
   *
   * @generated from field: repeated k8s.io.api.core.v1.PodTemplate items = 2;
   */
  items: PodTemplate[];
};

/**
 * PodTemplateList is a list of PodTemplates.
 *
 * @generated from message k8s.io.api.core.v1.PodTemplateList
 */
export declare type PodTemplateListValid = Message<"k8s.io.api.core.v1.PodTemplateList"> & {
  /**
   * Standard list metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMetaValid;

  /**
   * List of pod templates
   *
   * @generated from field: repeated k8s.io.api.core.v1.PodTemplate items = 2;
   */
  items: PodTemplateValid[];
};

/**
 * Describes the message k8s.io.api.core.v1.PodTemplateList.
 * Use `create(PodTemplateListSchema)` to create a new message.
 */
export declare const PodTemplateListSchema: GenMessage<PodTemplateList, {validType: PodTemplateListValid}>;

/**
 * PodTemplateSpec describes the data a pod should have when created from a template
 *
 * @generated from message k8s.io.api.core.v1.PodTemplateSpec
 */
export declare type PodTemplateSpec = Message<"k8s.io.api.core.v1.PodTemplateSpec"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMeta;

  /**
   * Specification of the desired behavior of the pod.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.PodSpec spec = 2;
   */
  spec?: PodSpec;
};

/**
 * PodTemplateSpec describes the data a pod should have when created from a template
 *
 * @generated from message k8s.io.api.core.v1.PodTemplateSpec
 */
export declare type PodTemplateSpecValid = Message<"k8s.io.api.core.v1.PodTemplateSpec"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMetaValid;

  /**
   * Specification of the desired behavior of the pod.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.PodSpec spec = 2;
   */
  spec?: PodSpecValid;
};

/**
 * Describes the message k8s.io.api.core.v1.PodTemplateSpec.
 * Use `create(PodTemplateSpecSchema)` to create a new message.
 */
export declare const PodTemplateSpecSchema: GenMessage<PodTemplateSpec, {validType: PodTemplateSpecValid}>;

/**
 * @generated from message k8s.io.api.core.v1.PortStatus
 */
export declare type PortStatus = Message<"k8s.io.api.core.v1.PortStatus"> & {
  /**
   * Port is the port number of the service port of which status is recorded here
   *
   * @generated from field: optional int32 port = 1;
   */
  port: number;

  /**
   * Protocol is the protocol of the service port of which status is recorded here
   * The supported values are: "TCP", "UDP", "SCTP"
   *
   * @generated from field: optional string protocol = 2;
   */
  protocol: string;

  /**
   * Error is to record the problem with the service port
   * The format of the error shall comply with the following rules:
   * - built-in error values shall be specified in this file and those shall use
   *   CamelCase names
   * - cloud provider specific error values must have names that comply with the
   *   format foo.example.com/CamelCase.
   * ---
   * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
   * +optional
   * +kubebuilder:validation:Required
   * +kubebuilder:validation:Pattern=`^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*\/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$`
   * +kubebuilder:validation:MaxLength=316
   *
   * @generated from field: optional string error = 3;
   */
  error: string;
};

/**
 * @generated from message k8s.io.api.core.v1.PortStatus
 */
export declare type PortStatusValid = Message<"k8s.io.api.core.v1.PortStatus"> & {
  /**
   * Port is the port number of the service port of which status is recorded here
   *
   * @generated from field: optional int32 port = 1;
   */
  port: number;

  /**
   * Protocol is the protocol of the service port of which status is recorded here
   * The supported values are: "TCP", "UDP", "SCTP"
   *
   * @generated from field: optional string protocol = 2;
   */
  protocol: string;

  /**
   * Error is to record the problem with the service port
   * The format of the error shall comply with the following rules:
   * - built-in error values shall be specified in this file and those shall use
   *   CamelCase names
   * - cloud provider specific error values must have names that comply with the
   *   format foo.example.com/CamelCase.
   * ---
   * The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
   * +optional
   * +kubebuilder:validation:Required
   * +kubebuilder:validation:Pattern=`^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*\/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$`
   * +kubebuilder:validation:MaxLength=316
   *
   * @generated from field: optional string error = 3;
   */
  error: string;
};

/**
 * Describes the message k8s.io.api.core.v1.PortStatus.
 * Use `create(PortStatusSchema)` to create a new message.
 */
export declare const PortStatusSchema: GenMessage<PortStatus, {validType: PortStatusValid}>;

/**
 * PortworxVolumeSource represents a Portworx volume resource.
 *
 * @generated from message k8s.io.api.core.v1.PortworxVolumeSource
 */
export declare type PortworxVolumeSource = Message<"k8s.io.api.core.v1.PortworxVolumeSource"> & {
  /**
   * volumeID uniquely identifies a Portworx volume
   *
   * @generated from field: optional string volumeID = 1;
   */
  volumeID: string;

  /**
   * fSType represents the filesystem type to mount
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @generated from field: optional string fsType = 2;
   */
  fsType: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * +optional
   *
   * @generated from field: optional bool readOnly = 3;
   */
  readOnly: boolean;
};

/**
 * PortworxVolumeSource represents a Portworx volume resource.
 *
 * @generated from message k8s.io.api.core.v1.PortworxVolumeSource
 */
export declare type PortworxVolumeSourceValid = Message<"k8s.io.api.core.v1.PortworxVolumeSource"> & {
  /**
   * volumeID uniquely identifies a Portworx volume
   *
   * @generated from field: optional string volumeID = 1;
   */
  volumeID: string;

  /**
   * fSType represents the filesystem type to mount
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @generated from field: optional string fsType = 2;
   */
  fsType: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * +optional
   *
   * @generated from field: optional bool readOnly = 3;
   */
  readOnly: boolean;
};

/**
 * Describes the message k8s.io.api.core.v1.PortworxVolumeSource.
 * Use `create(PortworxVolumeSourceSchema)` to create a new message.
 */
export declare const PortworxVolumeSourceSchema: GenMessage<PortworxVolumeSource, {validType: PortworxVolumeSourceValid}>;

/**
 * Preconditions must be fulfilled before an operation (update, delete, etc.) is carried out.
 * +k8s:openapi-gen=false
 *
 * @generated from message k8s.io.api.core.v1.Preconditions
 */
export declare type Preconditions = Message<"k8s.io.api.core.v1.Preconditions"> & {
  /**
   * Specifies the target UID.
   * +optional
   *
   * @generated from field: optional string uid = 1;
   */
  uid: string;
};

/**
 * Preconditions must be fulfilled before an operation (update, delete, etc.) is carried out.
 * +k8s:openapi-gen=false
 *
 * @generated from message k8s.io.api.core.v1.Preconditions
 */
export declare type PreconditionsValid = Message<"k8s.io.api.core.v1.Preconditions"> & {
  /**
   * Specifies the target UID.
   * +optional
   *
   * @generated from field: optional string uid = 1;
   */
  uid: string;
};

/**
 * Describes the message k8s.io.api.core.v1.Preconditions.
 * Use `create(PreconditionsSchema)` to create a new message.
 */
export declare const PreconditionsSchema: GenMessage<Preconditions, {validType: PreconditionsValid}>;

/**
 * Describes a class of pods that should avoid this node.
 *
 * @generated from message k8s.io.api.core.v1.PreferAvoidPodsEntry
 */
export declare type PreferAvoidPodsEntry = Message<"k8s.io.api.core.v1.PreferAvoidPodsEntry"> & {
  /**
   * The class of pods.
   *
   * @generated from field: optional k8s.io.api.core.v1.PodSignature podSignature = 1;
   */
  podSignature?: PodSignature;

  /**
   * Time at which this entry was added to the list.
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time evictionTime = 2;
   */
  evictionTime?: Time;

  /**
   * (brief) reason why this entry was added to the list.
   * +optional
   *
   * @generated from field: optional string reason = 3;
   */
  reason: string;

  /**
   * Human readable message indicating why this entry was added to the list.
   * +optional
   *
   * @generated from field: optional string message = 4;
   */
  message: string;
};

/**
 * Describes a class of pods that should avoid this node.
 *
 * @generated from message k8s.io.api.core.v1.PreferAvoidPodsEntry
 */
export declare type PreferAvoidPodsEntryValid = Message<"k8s.io.api.core.v1.PreferAvoidPodsEntry"> & {
  /**
   * The class of pods.
   *
   * @generated from field: optional k8s.io.api.core.v1.PodSignature podSignature = 1;
   */
  podSignature?: PodSignatureValid;

  /**
   * Time at which this entry was added to the list.
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time evictionTime = 2;
   */
  evictionTime?: TimeValid;

  /**
   * (brief) reason why this entry was added to the list.
   * +optional
   *
   * @generated from field: optional string reason = 3;
   */
  reason: string;

  /**
   * Human readable message indicating why this entry was added to the list.
   * +optional
   *
   * @generated from field: optional string message = 4;
   */
  message: string;
};

/**
 * Describes the message k8s.io.api.core.v1.PreferAvoidPodsEntry.
 * Use `create(PreferAvoidPodsEntrySchema)` to create a new message.
 */
export declare const PreferAvoidPodsEntrySchema: GenMessage<PreferAvoidPodsEntry, {validType: PreferAvoidPodsEntryValid}>;

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0
 * (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @generated from message k8s.io.api.core.v1.PreferredSchedulingTerm
 */
export declare type PreferredSchedulingTerm = Message<"k8s.io.api.core.v1.PreferredSchedulingTerm"> & {
  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @generated from field: optional int32 weight = 1;
   */
  weight: number;

  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @generated from field: optional k8s.io.api.core.v1.NodeSelectorTerm preference = 2;
   */
  preference?: NodeSelectorTerm;
};

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0
 * (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @generated from message k8s.io.api.core.v1.PreferredSchedulingTerm
 */
export declare type PreferredSchedulingTermValid = Message<"k8s.io.api.core.v1.PreferredSchedulingTerm"> & {
  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @generated from field: optional int32 weight = 1;
   */
  weight: number;

  /**
   * A node selector term, associated with the corresponding weight.
   *
   * @generated from field: optional k8s.io.api.core.v1.NodeSelectorTerm preference = 2;
   */
  preference?: NodeSelectorTermValid;
};

/**
 * Describes the message k8s.io.api.core.v1.PreferredSchedulingTerm.
 * Use `create(PreferredSchedulingTermSchema)` to create a new message.
 */
export declare const PreferredSchedulingTermSchema: GenMessage<PreferredSchedulingTerm, {validType: PreferredSchedulingTermValid}>;

/**
 * Probe describes a health check to be performed against a container to determine whether it is
 * alive or ready to receive traffic.
 *
 * @generated from message k8s.io.api.core.v1.Probe
 */
export declare type Probe = Message<"k8s.io.api.core.v1.Probe"> & {
  /**
   * The action taken to determine the health of a container
   *
   * @generated from field: optional k8s.io.api.core.v1.ProbeHandler handler = 1;
   */
  handler?: ProbeHandler;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * +optional
   *
   * @generated from field: optional int32 initialDelaySeconds = 2;
   */
  initialDelaySeconds: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * +optional
   *
   * @generated from field: optional int32 timeoutSeconds = 3;
   */
  timeoutSeconds: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   * +optional
   *
   * @generated from field: optional int32 periodSeconds = 4;
   */
  periodSeconds: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   * +optional
   *
   * @generated from field: optional int32 successThreshold = 5;
   */
  successThreshold: number;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   * +optional
   *
   * @generated from field: optional int32 failureThreshold = 6;
   */
  failureThreshold: number;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   * +optional
   *
   * @generated from field: optional int64 terminationGracePeriodSeconds = 7;
   */
  terminationGracePeriodSeconds: bigint;
};

/**
 * Probe describes a health check to be performed against a container to determine whether it is
 * alive or ready to receive traffic.
 *
 * @generated from message k8s.io.api.core.v1.Probe
 */
export declare type ProbeValid = Message<"k8s.io.api.core.v1.Probe"> & {
  /**
   * The action taken to determine the health of a container
   *
   * @generated from field: optional k8s.io.api.core.v1.ProbeHandler handler = 1;
   */
  handler?: ProbeHandlerValid;

  /**
   * Number of seconds after the container has started before liveness probes are initiated.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * +optional
   *
   * @generated from field: optional int32 initialDelaySeconds = 2;
   */
  initialDelaySeconds: number;

  /**
   * Number of seconds after which the probe times out.
   * Defaults to 1 second. Minimum value is 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * +optional
   *
   * @generated from field: optional int32 timeoutSeconds = 3;
   */
  timeoutSeconds: number;

  /**
   * How often (in seconds) to perform the probe.
   * Default to 10 seconds. Minimum value is 1.
   * +optional
   *
   * @generated from field: optional int32 periodSeconds = 4;
   */
  periodSeconds: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed.
   * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
   * +optional
   *
   * @generated from field: optional int32 successThreshold = 5;
   */
  successThreshold: number;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded.
   * Defaults to 3. Minimum value is 1.
   * +optional
   *
   * @generated from field: optional int32 failureThreshold = 6;
   */
  failureThreshold: number;

  /**
   * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
   * The grace period is the duration in seconds after the processes running in the pod are sent
   * a termination signal and the time when the processes are forcibly halted with a kill signal.
   * Set this value longer than the expected cleanup time for your process.
   * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
   * value overrides the value provided by the pod spec.
   * Value must be non-negative integer. The value zero indicates stop immediately via
   * the kill signal (no opportunity to shut down).
   * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
   * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
   * +optional
   *
   * @generated from field: optional int64 terminationGracePeriodSeconds = 7;
   */
  terminationGracePeriodSeconds: bigint;
};

/**
 * Describes the message k8s.io.api.core.v1.Probe.
 * Use `create(ProbeSchema)` to create a new message.
 */
export declare const ProbeSchema: GenMessage<Probe, {validType: ProbeValid}>;

/**
 * ProbeHandler defines a specific action that should be taken in a probe.
 * One and only one of the fields must be specified.
 *
 * @generated from message k8s.io.api.core.v1.ProbeHandler
 */
export declare type ProbeHandler = Message<"k8s.io.api.core.v1.ProbeHandler"> & {
  /**
   * Exec specifies the action to take.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ExecAction exec = 1;
   */
  exec?: ExecAction;

  /**
   * HTTPGet specifies the http request to perform.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.HTTPGetAction httpGet = 2;
   */
  httpGet?: HTTPGetAction;

  /**
   * TCPSocket specifies an action involving a TCP port.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.TCPSocketAction tcpSocket = 3;
   */
  tcpSocket?: TCPSocketAction;

  /**
   * GRPC specifies an action involving a GRPC port.
   * This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   * +featureGate=GRPCContainerProbe
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.GRPCAction grpc = 4;
   */
  grpc?: GRPCAction;
};

/**
 * ProbeHandler defines a specific action that should be taken in a probe.
 * One and only one of the fields must be specified.
 *
 * @generated from message k8s.io.api.core.v1.ProbeHandler
 */
export declare type ProbeHandlerValid = Message<"k8s.io.api.core.v1.ProbeHandler"> & {
  /**
   * Exec specifies the action to take.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ExecAction exec = 1;
   */
  exec?: ExecActionValid;

  /**
   * HTTPGet specifies the http request to perform.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.HTTPGetAction httpGet = 2;
   */
  httpGet?: HTTPGetActionValid;

  /**
   * TCPSocket specifies an action involving a TCP port.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.TCPSocketAction tcpSocket = 3;
   */
  tcpSocket?: TCPSocketActionValid;

  /**
   * GRPC specifies an action involving a GRPC port.
   * This is an alpha field and requires enabling GRPCContainerProbe feature gate.
   * +featureGate=GRPCContainerProbe
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.GRPCAction grpc = 4;
   */
  grpc?: GRPCActionValid;
};

/**
 * Describes the message k8s.io.api.core.v1.ProbeHandler.
 * Use `create(ProbeHandlerSchema)` to create a new message.
 */
export declare const ProbeHandlerSchema: GenMessage<ProbeHandler, {validType: ProbeHandlerValid}>;

/**
 * Represents a projected volume source
 *
 * @generated from message k8s.io.api.core.v1.ProjectedVolumeSource
 */
export declare type ProjectedVolumeSource = Message<"k8s.io.api.core.v1.ProjectedVolumeSource"> & {
  /**
   * sources is the list of volume projections
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.VolumeProjection sources = 1;
   */
  sources: VolumeProjection[];

  /**
   * defaultMode are the mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   * +optional
   *
   * @generated from field: optional int32 defaultMode = 2;
   */
  defaultMode: number;
};

/**
 * Represents a projected volume source
 *
 * @generated from message k8s.io.api.core.v1.ProjectedVolumeSource
 */
export declare type ProjectedVolumeSourceValid = Message<"k8s.io.api.core.v1.ProjectedVolumeSource"> & {
  /**
   * sources is the list of volume projections
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.VolumeProjection sources = 1;
   */
  sources: VolumeProjectionValid[];

  /**
   * defaultMode are the mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   * +optional
   *
   * @generated from field: optional int32 defaultMode = 2;
   */
  defaultMode: number;
};

/**
 * Describes the message k8s.io.api.core.v1.ProjectedVolumeSource.
 * Use `create(ProjectedVolumeSourceSchema)` to create a new message.
 */
export declare const ProjectedVolumeSourceSchema: GenMessage<ProjectedVolumeSource, {validType: ProjectedVolumeSourceValid}>;

/**
 * Represents a Quobyte mount that lasts the lifetime of a pod.
 * Quobyte volumes do not support ownership management or SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.QuobyteVolumeSource
 */
export declare type QuobyteVolumeSource = Message<"k8s.io.api.core.v1.QuobyteVolumeSource"> & {
  /**
   * registry represents a single or multiple Quobyte Registry services
   * specified as a string as host:port pair (multiple entries are separated with commas)
   * which acts as the central registry for volumes
   *
   * @generated from field: optional string registry = 1;
   */
  registry: string;

  /**
   * volume is a string that references an already created Quobyte volume by name.
   *
   * @generated from field: optional string volume = 2;
   */
  volume: string;

  /**
   * readOnly here will force the Quobyte volume to be mounted with read-only permissions.
   * Defaults to false.
   * +optional
   *
   * @generated from field: optional bool readOnly = 3;
   */
  readOnly: boolean;

  /**
   * user to map volume access to
   * Defaults to serivceaccount user
   * +optional
   *
   * @generated from field: optional string user = 4;
   */
  user: string;

  /**
   * group to map volume access to
   * Default is no group
   * +optional
   *
   * @generated from field: optional string group = 5;
   */
  group: string;

  /**
   * tenant owning the given Quobyte volume in the Backend
   * Used with dynamically provisioned Quobyte volumes, value is set by the plugin
   * +optional
   *
   * @generated from field: optional string tenant = 6;
   */
  tenant: string;
};

/**
 * Represents a Quobyte mount that lasts the lifetime of a pod.
 * Quobyte volumes do not support ownership management or SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.QuobyteVolumeSource
 */
export declare type QuobyteVolumeSourceValid = Message<"k8s.io.api.core.v1.QuobyteVolumeSource"> & {
  /**
   * registry represents a single or multiple Quobyte Registry services
   * specified as a string as host:port pair (multiple entries are separated with commas)
   * which acts as the central registry for volumes
   *
   * @generated from field: optional string registry = 1;
   */
  registry: string;

  /**
   * volume is a string that references an already created Quobyte volume by name.
   *
   * @generated from field: optional string volume = 2;
   */
  volume: string;

  /**
   * readOnly here will force the Quobyte volume to be mounted with read-only permissions.
   * Defaults to false.
   * +optional
   *
   * @generated from field: optional bool readOnly = 3;
   */
  readOnly: boolean;

  /**
   * user to map volume access to
   * Defaults to serivceaccount user
   * +optional
   *
   * @generated from field: optional string user = 4;
   */
  user: string;

  /**
   * group to map volume access to
   * Default is no group
   * +optional
   *
   * @generated from field: optional string group = 5;
   */
  group: string;

  /**
   * tenant owning the given Quobyte volume in the Backend
   * Used with dynamically provisioned Quobyte volumes, value is set by the plugin
   * +optional
   *
   * @generated from field: optional string tenant = 6;
   */
  tenant: string;
};

/**
 * Describes the message k8s.io.api.core.v1.QuobyteVolumeSource.
 * Use `create(QuobyteVolumeSourceSchema)` to create a new message.
 */
export declare const QuobyteVolumeSourceSchema: GenMessage<QuobyteVolumeSource, {validType: QuobyteVolumeSourceValid}>;

/**
 * Represents a Rados Block Device mount that lasts the lifetime of a pod.
 * RBD volumes support ownership management and SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.RBDPersistentVolumeSource
 */
export declare type RBDPersistentVolumeSource = Message<"k8s.io.api.core.v1.RBDPersistentVolumeSource"> & {
  /**
   * monitors is a collection of Ceph monitors.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @generated from field: repeated string monitors = 1;
   */
  monitors: string[];

  /**
   * image is the rados image name.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @generated from field: optional string image = 2;
   */
  image: string;

  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   * +optional
   *
   * @generated from field: optional string fsType = 3;
   */
  fsType: string;

  /**
   * pool is the rados pool name.
   * Default is rbd.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * +optional
   *
   * @generated from field: optional string pool = 4;
   */
  pool: string;

  /**
   * user is the rados user name.
   * Default is admin.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * +optional
   *
   * @generated from field: optional string user = 5;
   */
  user: string;

  /**
   * keyring is the path to key ring for RBDUser.
   * Default is /etc/ceph/keyring.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * +optional
   *
   * @generated from field: optional string keyring = 6;
   */
  keyring: string;

  /**
   * secretRef is name of the authentication secret for RBDUser. If provided
   * overrides keyring.
   * Default is nil.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.SecretReference secretRef = 7;
   */
  secretRef?: SecretReference;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * +optional
   *
   * @generated from field: optional bool readOnly = 8;
   */
  readOnly: boolean;
};

/**
 * Represents a Rados Block Device mount that lasts the lifetime of a pod.
 * RBD volumes support ownership management and SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.RBDPersistentVolumeSource
 */
export declare type RBDPersistentVolumeSourceValid = Message<"k8s.io.api.core.v1.RBDPersistentVolumeSource"> & {
  /**
   * monitors is a collection of Ceph monitors.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @generated from field: repeated string monitors = 1;
   */
  monitors: string[];

  /**
   * image is the rados image name.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @generated from field: optional string image = 2;
   */
  image: string;

  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   * +optional
   *
   * @generated from field: optional string fsType = 3;
   */
  fsType: string;

  /**
   * pool is the rados pool name.
   * Default is rbd.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * +optional
   *
   * @generated from field: optional string pool = 4;
   */
  pool: string;

  /**
   * user is the rados user name.
   * Default is admin.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * +optional
   *
   * @generated from field: optional string user = 5;
   */
  user: string;

  /**
   * keyring is the path to key ring for RBDUser.
   * Default is /etc/ceph/keyring.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * +optional
   *
   * @generated from field: optional string keyring = 6;
   */
  keyring: string;

  /**
   * secretRef is name of the authentication secret for RBDUser. If provided
   * overrides keyring.
   * Default is nil.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.SecretReference secretRef = 7;
   */
  secretRef?: SecretReferenceValid;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * +optional
   *
   * @generated from field: optional bool readOnly = 8;
   */
  readOnly: boolean;
};

/**
 * Describes the message k8s.io.api.core.v1.RBDPersistentVolumeSource.
 * Use `create(RBDPersistentVolumeSourceSchema)` to create a new message.
 */
export declare const RBDPersistentVolumeSourceSchema: GenMessage<RBDPersistentVolumeSource, {validType: RBDPersistentVolumeSourceValid}>;

/**
 * Represents a Rados Block Device mount that lasts the lifetime of a pod.
 * RBD volumes support ownership management and SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.RBDVolumeSource
 */
export declare type RBDVolumeSource = Message<"k8s.io.api.core.v1.RBDVolumeSource"> & {
  /**
   * monitors is a collection of Ceph monitors.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @generated from field: repeated string monitors = 1;
   */
  monitors: string[];

  /**
   * image is the rados image name.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @generated from field: optional string image = 2;
   */
  image: string;

  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   * +optional
   *
   * @generated from field: optional string fsType = 3;
   */
  fsType: string;

  /**
   * pool is the rados pool name.
   * Default is rbd.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * +optional
   *
   * @generated from field: optional string pool = 4;
   */
  pool: string;

  /**
   * user is the rados user name.
   * Default is admin.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * +optional
   *
   * @generated from field: optional string user = 5;
   */
  user: string;

  /**
   * keyring is the path to key ring for RBDUser.
   * Default is /etc/ceph/keyring.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * +optional
   *
   * @generated from field: optional string keyring = 6;
   */
  keyring: string;

  /**
   * secretRef is name of the authentication secret for RBDUser. If provided
   * overrides keyring.
   * Default is nil.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.LocalObjectReference secretRef = 7;
   */
  secretRef?: LocalObjectReference;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * +optional
   *
   * @generated from field: optional bool readOnly = 8;
   */
  readOnly: boolean;
};

/**
 * Represents a Rados Block Device mount that lasts the lifetime of a pod.
 * RBD volumes support ownership management and SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.RBDVolumeSource
 */
export declare type RBDVolumeSourceValid = Message<"k8s.io.api.core.v1.RBDVolumeSource"> & {
  /**
   * monitors is a collection of Ceph monitors.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @generated from field: repeated string monitors = 1;
   */
  monitors: string[];

  /**
   * image is the rados image name.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   *
   * @generated from field: optional string image = 2;
   */
  image: string;

  /**
   * fsType is the filesystem type of the volume that you want to mount.
   * Tip: Ensure that the filesystem type is supported by the host operating system.
   * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
   * TODO: how do we prevent errors in the filesystem from compromising the machine
   * +optional
   *
   * @generated from field: optional string fsType = 3;
   */
  fsType: string;

  /**
   * pool is the rados pool name.
   * Default is rbd.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * +optional
   *
   * @generated from field: optional string pool = 4;
   */
  pool: string;

  /**
   * user is the rados user name.
   * Default is admin.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * +optional
   *
   * @generated from field: optional string user = 5;
   */
  user: string;

  /**
   * keyring is the path to key ring for RBDUser.
   * Default is /etc/ceph/keyring.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * +optional
   *
   * @generated from field: optional string keyring = 6;
   */
  keyring: string;

  /**
   * secretRef is name of the authentication secret for RBDUser. If provided
   * overrides keyring.
   * Default is nil.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.LocalObjectReference secretRef = 7;
   */
  secretRef?: LocalObjectReferenceValid;

  /**
   * readOnly here will force the ReadOnly setting in VolumeMounts.
   * Defaults to false.
   * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
   * +optional
   *
   * @generated from field: optional bool readOnly = 8;
   */
  readOnly: boolean;
};

/**
 * Describes the message k8s.io.api.core.v1.RBDVolumeSource.
 * Use `create(RBDVolumeSourceSchema)` to create a new message.
 */
export declare const RBDVolumeSourceSchema: GenMessage<RBDVolumeSource, {validType: RBDVolumeSourceValid}>;

/**
 * RangeAllocation is not a public type.
 *
 * @generated from message k8s.io.api.core.v1.RangeAllocation
 */
export declare type RangeAllocation = Message<"k8s.io.api.core.v1.RangeAllocation"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMeta;

  /**
   * Range is string that identifies the range represented by 'data'.
   *
   * @generated from field: optional string range = 2;
   */
  range: string;

  /**
   * Data is a bit array containing all allocated addresses in the previous segment.
   *
   * @generated from field: optional bytes data = 3;
   */
  data: Uint8Array;
};

/**
 * RangeAllocation is not a public type.
 *
 * @generated from message k8s.io.api.core.v1.RangeAllocation
 */
export declare type RangeAllocationValid = Message<"k8s.io.api.core.v1.RangeAllocation"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMetaValid;

  /**
   * Range is string that identifies the range represented by 'data'.
   *
   * @generated from field: optional string range = 2;
   */
  range: string;

  /**
   * Data is a bit array containing all allocated addresses in the previous segment.
   *
   * @generated from field: optional bytes data = 3;
   */
  data: Uint8Array;
};

/**
 * Describes the message k8s.io.api.core.v1.RangeAllocation.
 * Use `create(RangeAllocationSchema)` to create a new message.
 */
export declare const RangeAllocationSchema: GenMessage<RangeAllocation, {validType: RangeAllocationValid}>;

/**
 * ReplicationController represents the configuration of a replication controller.
 *
 * @generated from message k8s.io.api.core.v1.ReplicationController
 */
export declare type ReplicationController = Message<"k8s.io.api.core.v1.ReplicationController"> & {
  /**
   * If the Labels of a ReplicationController are empty, they are defaulted to
   * be the same as the Pod(s) that the replication controller manages.
   * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMeta;

  /**
   * Spec defines the specification of the desired behavior of the replication controller.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ReplicationControllerSpec spec = 2;
   */
  spec?: ReplicationControllerSpec;

  /**
   * Status is the most recently observed status of the replication controller.
   * This data may be out of date by some window of time.
   * Populated by the system.
   * Read-only.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ReplicationControllerStatus status = 3;
   */
  status?: ReplicationControllerStatus;
};

/**
 * ReplicationController represents the configuration of a replication controller.
 *
 * @generated from message k8s.io.api.core.v1.ReplicationController
 */
export declare type ReplicationControllerValid = Message<"k8s.io.api.core.v1.ReplicationController"> & {
  /**
   * If the Labels of a ReplicationController are empty, they are defaulted to
   * be the same as the Pod(s) that the replication controller manages.
   * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMetaValid;

  /**
   * Spec defines the specification of the desired behavior of the replication controller.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ReplicationControllerSpec spec = 2;
   */
  spec?: ReplicationControllerSpecValid;

  /**
   * Status is the most recently observed status of the replication controller.
   * This data may be out of date by some window of time.
   * Populated by the system.
   * Read-only.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ReplicationControllerStatus status = 3;
   */
  status?: ReplicationControllerStatusValid;
};

/**
 * Describes the message k8s.io.api.core.v1.ReplicationController.
 * Use `create(ReplicationControllerSchema)` to create a new message.
 */
export declare const ReplicationControllerSchema: GenMessage<ReplicationController, {validType: ReplicationControllerValid}>;

/**
 * ReplicationControllerCondition describes the state of a replication controller at a certain point.
 *
 * @generated from message k8s.io.api.core.v1.ReplicationControllerCondition
 */
export declare type ReplicationControllerCondition = Message<"k8s.io.api.core.v1.ReplicationControllerCondition"> & {
  /**
   * Type of replication controller condition.
   *
   * @generated from field: optional string type = 1;
   */
  type: string;

  /**
   * Status of the condition, one of True, False, Unknown.
   *
   * @generated from field: optional string status = 2;
   */
  status: string;

  /**
   * The last time the condition transitioned from one status to another.
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;
   */
  lastTransitionTime?: Time;

  /**
   * The reason for the condition's last transition.
   * +optional
   *
   * @generated from field: optional string reason = 4;
   */
  reason: string;

  /**
   * A human readable message indicating details about the transition.
   * +optional
   *
   * @generated from field: optional string message = 5;
   */
  message: string;
};

/**
 * ReplicationControllerCondition describes the state of a replication controller at a certain point.
 *
 * @generated from message k8s.io.api.core.v1.ReplicationControllerCondition
 */
export declare type ReplicationControllerConditionValid = Message<"k8s.io.api.core.v1.ReplicationControllerCondition"> & {
  /**
   * Type of replication controller condition.
   *
   * @generated from field: optional string type = 1;
   */
  type: string;

  /**
   * Status of the condition, one of True, False, Unknown.
   *
   * @generated from field: optional string status = 2;
   */
  status: string;

  /**
   * The last time the condition transitioned from one status to another.
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;
   */
  lastTransitionTime?: TimeValid;

  /**
   * The reason for the condition's last transition.
   * +optional
   *
   * @generated from field: optional string reason = 4;
   */
  reason: string;

  /**
   * A human readable message indicating details about the transition.
   * +optional
   *
   * @generated from field: optional string message = 5;
   */
  message: string;
};

/**
 * Describes the message k8s.io.api.core.v1.ReplicationControllerCondition.
 * Use `create(ReplicationControllerConditionSchema)` to create a new message.
 */
export declare const ReplicationControllerConditionSchema: GenMessage<ReplicationControllerCondition, {validType: ReplicationControllerConditionValid}>;

/**
 * ReplicationControllerList is a collection of replication controllers.
 *
 * @generated from message k8s.io.api.core.v1.ReplicationControllerList
 */
export declare type ReplicationControllerList = Message<"k8s.io.api.core.v1.ReplicationControllerList"> & {
  /**
   * Standard list metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMeta;

  /**
   * List of replication controllers.
   * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
   *
   * @generated from field: repeated k8s.io.api.core.v1.ReplicationController items = 2;
   */
  items: ReplicationController[];
};

/**
 * ReplicationControllerList is a collection of replication controllers.
 *
 * @generated from message k8s.io.api.core.v1.ReplicationControllerList
 */
export declare type ReplicationControllerListValid = Message<"k8s.io.api.core.v1.ReplicationControllerList"> & {
  /**
   * Standard list metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMetaValid;

  /**
   * List of replication controllers.
   * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
   *
   * @generated from field: repeated k8s.io.api.core.v1.ReplicationController items = 2;
   */
  items: ReplicationControllerValid[];
};

/**
 * Describes the message k8s.io.api.core.v1.ReplicationControllerList.
 * Use `create(ReplicationControllerListSchema)` to create a new message.
 */
export declare const ReplicationControllerListSchema: GenMessage<ReplicationControllerList, {validType: ReplicationControllerListValid}>;

/**
 * ReplicationControllerSpec is the specification of a replication controller.
 *
 * @generated from message k8s.io.api.core.v1.ReplicationControllerSpec
 */
export declare type ReplicationControllerSpec = Message<"k8s.io.api.core.v1.ReplicationControllerSpec"> & {
  /**
   * Replicas is the number of desired replicas.
   * This is a pointer to distinguish between explicit zero and unspecified.
   * Defaults to 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#what-is-a-replicationcontroller
   * +optional
   *
   * @generated from field: optional int32 replicas = 1;
   */
  replicas: number;

  /**
   * Minimum number of seconds for which a newly created pod should be ready
   * without any of its container crashing, for it to be considered available.
   * Defaults to 0 (pod will be considered available as soon as it is ready)
   * +optional
   *
   * @generated from field: optional int32 minReadySeconds = 4;
   */
  minReadySeconds: number;

  /**
   * Selector is a label query over pods that should match the Replicas count.
   * If Selector is empty, it is defaulted to the labels present on the Pod template.
   * Label keys and values that must match in order to be controlled by this replication
   * controller, if empty defaulted to labels on Pod template.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
   * +optional
   * +mapType=atomic
   *
   * @generated from field: map<string, string> selector = 2;
   */
  selector: { [key: string]: string };

  /**
   * Template is the object that describes the pod that will be created if
   * insufficient replicas are detected. This takes precedence over a TemplateRef.
   * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.PodTemplateSpec template = 3;
   */
  template?: PodTemplateSpec;
};

/**
 * ReplicationControllerSpec is the specification of a replication controller.
 *
 * @generated from message k8s.io.api.core.v1.ReplicationControllerSpec
 */
export declare type ReplicationControllerSpecValid = Message<"k8s.io.api.core.v1.ReplicationControllerSpec"> & {
  /**
   * Replicas is the number of desired replicas.
   * This is a pointer to distinguish between explicit zero and unspecified.
   * Defaults to 1.
   * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#what-is-a-replicationcontroller
   * +optional
   *
   * @generated from field: optional int32 replicas = 1;
   */
  replicas: number;

  /**
   * Minimum number of seconds for which a newly created pod should be ready
   * without any of its container crashing, for it to be considered available.
   * Defaults to 0 (pod will be considered available as soon as it is ready)
   * +optional
   *
   * @generated from field: optional int32 minReadySeconds = 4;
   */
  minReadySeconds: number;

  /**
   * Selector is a label query over pods that should match the Replicas count.
   * If Selector is empty, it is defaulted to the labels present on the Pod template.
   * Label keys and values that must match in order to be controlled by this replication
   * controller, if empty defaulted to labels on Pod template.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
   * +optional
   * +mapType=atomic
   *
   * @generated from field: map<string, string> selector = 2;
   */
  selector: { [key: string]: string };

  /**
   * Template is the object that describes the pod that will be created if
   * insufficient replicas are detected. This takes precedence over a TemplateRef.
   * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.PodTemplateSpec template = 3;
   */
  template?: PodTemplateSpecValid;
};

/**
 * Describes the message k8s.io.api.core.v1.ReplicationControllerSpec.
 * Use `create(ReplicationControllerSpecSchema)` to create a new message.
 */
export declare const ReplicationControllerSpecSchema: GenMessage<ReplicationControllerSpec, {validType: ReplicationControllerSpecValid}>;

/**
 * ReplicationControllerStatus represents the current status of a replication
 * controller.
 *
 * @generated from message k8s.io.api.core.v1.ReplicationControllerStatus
 */
export declare type ReplicationControllerStatus = Message<"k8s.io.api.core.v1.ReplicationControllerStatus"> & {
  /**
   * Replicas is the most recently oberved number of replicas.
   * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#what-is-a-replicationcontroller
   *
   * @generated from field: optional int32 replicas = 1;
   */
  replicas: number;

  /**
   * The number of pods that have labels matching the labels of the pod template of the replication controller.
   * +optional
   *
   * @generated from field: optional int32 fullyLabeledReplicas = 2;
   */
  fullyLabeledReplicas: number;

  /**
   * The number of ready replicas for this replication controller.
   * +optional
   *
   * @generated from field: optional int32 readyReplicas = 4;
   */
  readyReplicas: number;

  /**
   * The number of available replicas (ready for at least minReadySeconds) for this replication controller.
   * +optional
   *
   * @generated from field: optional int32 availableReplicas = 5;
   */
  availableReplicas: number;

  /**
   * ObservedGeneration reflects the generation of the most recently observed replication controller.
   * +optional
   *
   * @generated from field: optional int64 observedGeneration = 3;
   */
  observedGeneration: bigint;

  /**
   * Represents the latest available observations of a replication controller's current state.
   * +optional
   * +patchMergeKey=type
   * +patchStrategy=merge
   *
   * @generated from field: repeated k8s.io.api.core.v1.ReplicationControllerCondition conditions = 6;
   */
  conditions: ReplicationControllerCondition[];
};

/**
 * ReplicationControllerStatus represents the current status of a replication
 * controller.
 *
 * @generated from message k8s.io.api.core.v1.ReplicationControllerStatus
 */
export declare type ReplicationControllerStatusValid = Message<"k8s.io.api.core.v1.ReplicationControllerStatus"> & {
  /**
   * Replicas is the most recently oberved number of replicas.
   * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#what-is-a-replicationcontroller
   *
   * @generated from field: optional int32 replicas = 1;
   */
  replicas: number;

  /**
   * The number of pods that have labels matching the labels of the pod template of the replication controller.
   * +optional
   *
   * @generated from field: optional int32 fullyLabeledReplicas = 2;
   */
  fullyLabeledReplicas: number;

  /**
   * The number of ready replicas for this replication controller.
   * +optional
   *
   * @generated from field: optional int32 readyReplicas = 4;
   */
  readyReplicas: number;

  /**
   * The number of available replicas (ready for at least minReadySeconds) for this replication controller.
   * +optional
   *
   * @generated from field: optional int32 availableReplicas = 5;
   */
  availableReplicas: number;

  /**
   * ObservedGeneration reflects the generation of the most recently observed replication controller.
   * +optional
   *
   * @generated from field: optional int64 observedGeneration = 3;
   */
  observedGeneration: bigint;

  /**
   * Represents the latest available observations of a replication controller's current state.
   * +optional
   * +patchMergeKey=type
   * +patchStrategy=merge
   *
   * @generated from field: repeated k8s.io.api.core.v1.ReplicationControllerCondition conditions = 6;
   */
  conditions: ReplicationControllerConditionValid[];
};

/**
 * Describes the message k8s.io.api.core.v1.ReplicationControllerStatus.
 * Use `create(ReplicationControllerStatusSchema)` to create a new message.
 */
export declare const ReplicationControllerStatusSchema: GenMessage<ReplicationControllerStatus, {validType: ReplicationControllerStatusValid}>;

/**
 * ResourceFieldSelector represents container resources (cpu, memory) and their output format
 * +structType=atomic
 *
 * @generated from message k8s.io.api.core.v1.ResourceFieldSelector
 */
export declare type ResourceFieldSelector = Message<"k8s.io.api.core.v1.ResourceFieldSelector"> & {
  /**
   * Container name: required for volumes, optional for env vars
   * +optional
   *
   * @generated from field: optional string containerName = 1;
   */
  containerName: string;

  /**
   * Required: resource to select
   *
   * @generated from field: optional string resource = 2;
   */
  resource: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.api.resource.Quantity divisor = 3;
   */
  divisor?: Quantity;
};

/**
 * ResourceFieldSelector represents container resources (cpu, memory) and their output format
 * +structType=atomic
 *
 * @generated from message k8s.io.api.core.v1.ResourceFieldSelector
 */
export declare type ResourceFieldSelectorValid = Message<"k8s.io.api.core.v1.ResourceFieldSelector"> & {
  /**
   * Container name: required for volumes, optional for env vars
   * +optional
   *
   * @generated from field: optional string containerName = 1;
   */
  containerName: string;

  /**
   * Required: resource to select
   *
   * @generated from field: optional string resource = 2;
   */
  resource: string;

  /**
   * Specifies the output format of the exposed resources, defaults to "1"
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.api.resource.Quantity divisor = 3;
   */
  divisor?: QuantityValid;
};

/**
 * Describes the message k8s.io.api.core.v1.ResourceFieldSelector.
 * Use `create(ResourceFieldSelectorSchema)` to create a new message.
 */
export declare const ResourceFieldSelectorSchema: GenMessage<ResourceFieldSelector, {validType: ResourceFieldSelectorValid}>;

/**
 * ResourceQuota sets aggregate quota restrictions enforced per namespace
 *
 * @generated from message k8s.io.api.core.v1.ResourceQuota
 */
export declare type ResourceQuota = Message<"k8s.io.api.core.v1.ResourceQuota"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMeta;

  /**
   * Spec defines the desired quota.
   * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ResourceQuotaSpec spec = 2;
   */
  spec?: ResourceQuotaSpec;

  /**
   * Status defines the actual enforced quota and its current usage.
   * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ResourceQuotaStatus status = 3;
   */
  status?: ResourceQuotaStatus;
};

/**
 * ResourceQuota sets aggregate quota restrictions enforced per namespace
 *
 * @generated from message k8s.io.api.core.v1.ResourceQuota
 */
export declare type ResourceQuotaValid = Message<"k8s.io.api.core.v1.ResourceQuota"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMetaValid;

  /**
   * Spec defines the desired quota.
   * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ResourceQuotaSpec spec = 2;
   */
  spec?: ResourceQuotaSpecValid;

  /**
   * Status defines the actual enforced quota and its current usage.
   * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ResourceQuotaStatus status = 3;
   */
  status?: ResourceQuotaStatusValid;
};

/**
 * Describes the message k8s.io.api.core.v1.ResourceQuota.
 * Use `create(ResourceQuotaSchema)` to create a new message.
 */
export declare const ResourceQuotaSchema: GenMessage<ResourceQuota, {validType: ResourceQuotaValid}>;

/**
 * ResourceQuotaList is a list of ResourceQuota items.
 *
 * @generated from message k8s.io.api.core.v1.ResourceQuotaList
 */
export declare type ResourceQuotaList = Message<"k8s.io.api.core.v1.ResourceQuotaList"> & {
  /**
   * Standard list metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMeta;

  /**
   * Items is a list of ResourceQuota objects.
   * More info: https://kubernetes.io/docs/concepts/policy/resource-quotas/
   *
   * @generated from field: repeated k8s.io.api.core.v1.ResourceQuota items = 2;
   */
  items: ResourceQuota[];
};

/**
 * ResourceQuotaList is a list of ResourceQuota items.
 *
 * @generated from message k8s.io.api.core.v1.ResourceQuotaList
 */
export declare type ResourceQuotaListValid = Message<"k8s.io.api.core.v1.ResourceQuotaList"> & {
  /**
   * Standard list metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMetaValid;

  /**
   * Items is a list of ResourceQuota objects.
   * More info: https://kubernetes.io/docs/concepts/policy/resource-quotas/
   *
   * @generated from field: repeated k8s.io.api.core.v1.ResourceQuota items = 2;
   */
  items: ResourceQuotaValid[];
};

/**
 * Describes the message k8s.io.api.core.v1.ResourceQuotaList.
 * Use `create(ResourceQuotaListSchema)` to create a new message.
 */
export declare const ResourceQuotaListSchema: GenMessage<ResourceQuotaList, {validType: ResourceQuotaListValid}>;

/**
 * ResourceQuotaSpec defines the desired hard limits to enforce for Quota.
 *
 * @generated from message k8s.io.api.core.v1.ResourceQuotaSpec
 */
export declare type ResourceQuotaSpec = Message<"k8s.io.api.core.v1.ResourceQuotaSpec"> & {
  /**
   * hard is the set of desired hard limits for each named resource.
   * More info: https://kubernetes.io/docs/concepts/policy/resource-quotas/
   * +optional
   *
   * @generated from field: map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> hard = 1;
   */
  hard: { [key: string]: Quantity };

  /**
   * A collection of filters that must match each object tracked by a quota.
   * If not specified, the quota matches all objects.
   * +optional
   *
   * @generated from field: repeated string scopes = 2;
   */
  scopes: string[];

  /**
   * scopeSelector is also a collection of filters like scopes that must match each object tracked by a quota
   * but expressed using ScopeSelectorOperator in combination with possible values.
   * For a resource to match, both scopes AND scopeSelector (if specified in spec), must be matched.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ScopeSelector scopeSelector = 3;
   */
  scopeSelector?: ScopeSelector;
};

/**
 * ResourceQuotaSpec defines the desired hard limits to enforce for Quota.
 *
 * @generated from message k8s.io.api.core.v1.ResourceQuotaSpec
 */
export declare type ResourceQuotaSpecValid = Message<"k8s.io.api.core.v1.ResourceQuotaSpec"> & {
  /**
   * hard is the set of desired hard limits for each named resource.
   * More info: https://kubernetes.io/docs/concepts/policy/resource-quotas/
   * +optional
   *
   * @generated from field: map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> hard = 1;
   */
  hard: { [key: string]: QuantityValid };

  /**
   * A collection of filters that must match each object tracked by a quota.
   * If not specified, the quota matches all objects.
   * +optional
   *
   * @generated from field: repeated string scopes = 2;
   */
  scopes: string[];

  /**
   * scopeSelector is also a collection of filters like scopes that must match each object tracked by a quota
   * but expressed using ScopeSelectorOperator in combination with possible values.
   * For a resource to match, both scopes AND scopeSelector (if specified in spec), must be matched.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ScopeSelector scopeSelector = 3;
   */
  scopeSelector?: ScopeSelectorValid;
};

/**
 * Describes the message k8s.io.api.core.v1.ResourceQuotaSpec.
 * Use `create(ResourceQuotaSpecSchema)` to create a new message.
 */
export declare const ResourceQuotaSpecSchema: GenMessage<ResourceQuotaSpec, {validType: ResourceQuotaSpecValid}>;

/**
 * ResourceQuotaStatus defines the enforced hard limits and observed use.
 *
 * @generated from message k8s.io.api.core.v1.ResourceQuotaStatus
 */
export declare type ResourceQuotaStatus = Message<"k8s.io.api.core.v1.ResourceQuotaStatus"> & {
  /**
   * Hard is the set of enforced hard limits for each named resource.
   * More info: https://kubernetes.io/docs/concepts/policy/resource-quotas/
   * +optional
   *
   * @generated from field: map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> hard = 1;
   */
  hard: { [key: string]: Quantity };

  /**
   * Used is the current observed total usage of the resource in the namespace.
   * +optional
   *
   * @generated from field: map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> used = 2;
   */
  used: { [key: string]: Quantity };
};

/**
 * ResourceQuotaStatus defines the enforced hard limits and observed use.
 *
 * @generated from message k8s.io.api.core.v1.ResourceQuotaStatus
 */
export declare type ResourceQuotaStatusValid = Message<"k8s.io.api.core.v1.ResourceQuotaStatus"> & {
  /**
   * Hard is the set of enforced hard limits for each named resource.
   * More info: https://kubernetes.io/docs/concepts/policy/resource-quotas/
   * +optional
   *
   * @generated from field: map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> hard = 1;
   */
  hard: { [key: string]: QuantityValid };

  /**
   * Used is the current observed total usage of the resource in the namespace.
   * +optional
   *
   * @generated from field: map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> used = 2;
   */
  used: { [key: string]: QuantityValid };
};

/**
 * Describes the message k8s.io.api.core.v1.ResourceQuotaStatus.
 * Use `create(ResourceQuotaStatusSchema)` to create a new message.
 */
export declare const ResourceQuotaStatusSchema: GenMessage<ResourceQuotaStatus, {validType: ResourceQuotaStatusValid}>;

/**
 * ResourceRequirements describes the compute resource requirements.
 *
 * @generated from message k8s.io.api.core.v1.ResourceRequirements
 */
export declare type ResourceRequirements = Message<"k8s.io.api.core.v1.ResourceRequirements"> & {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   * +optional
   *
   * @generated from field: map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> limits = 1;
   */
  limits: { [key: string]: Quantity };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   * +optional
   *
   * @generated from field: map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> requests = 2;
   */
  requests: { [key: string]: Quantity };
};

/**
 * ResourceRequirements describes the compute resource requirements.
 *
 * @generated from message k8s.io.api.core.v1.ResourceRequirements
 */
export declare type ResourceRequirementsValid = Message<"k8s.io.api.core.v1.ResourceRequirements"> & {
  /**
   * Limits describes the maximum amount of compute resources allowed.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   * +optional
   *
   * @generated from field: map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> limits = 1;
   */
  limits: { [key: string]: QuantityValid };

  /**
   * Requests describes the minimum amount of compute resources required.
   * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
   * otherwise to an implementation-defined value.
   * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
   * +optional
   *
   * @generated from field: map<string, k8s.io.apimachinery.pkg.api.resource.Quantity> requests = 2;
   */
  requests: { [key: string]: QuantityValid };
};

/**
 * Describes the message k8s.io.api.core.v1.ResourceRequirements.
 * Use `create(ResourceRequirementsSchema)` to create a new message.
 */
export declare const ResourceRequirementsSchema: GenMessage<ResourceRequirements, {validType: ResourceRequirementsValid}>;

/**
 * SELinuxOptions are the labels to be applied to the container
 *
 * @generated from message k8s.io.api.core.v1.SELinuxOptions
 */
export declare type SELinuxOptions = Message<"k8s.io.api.core.v1.SELinuxOptions"> & {
  /**
   * User is a SELinux user label that applies to the container.
   * +optional
   *
   * @generated from field: optional string user = 1;
   */
  user: string;

  /**
   * Role is a SELinux role label that applies to the container.
   * +optional
   *
   * @generated from field: optional string role = 2;
   */
  role: string;

  /**
   * Type is a SELinux type label that applies to the container.
   * +optional
   *
   * @generated from field: optional string type = 3;
   */
  type: string;

  /**
   * Level is SELinux level label that applies to the container.
   * +optional
   *
   * @generated from field: optional string level = 4;
   */
  level: string;
};

/**
 * SELinuxOptions are the labels to be applied to the container
 *
 * @generated from message k8s.io.api.core.v1.SELinuxOptions
 */
export declare type SELinuxOptionsValid = Message<"k8s.io.api.core.v1.SELinuxOptions"> & {
  /**
   * User is a SELinux user label that applies to the container.
   * +optional
   *
   * @generated from field: optional string user = 1;
   */
  user: string;

  /**
   * Role is a SELinux role label that applies to the container.
   * +optional
   *
   * @generated from field: optional string role = 2;
   */
  role: string;

  /**
   * Type is a SELinux type label that applies to the container.
   * +optional
   *
   * @generated from field: optional string type = 3;
   */
  type: string;

  /**
   * Level is SELinux level label that applies to the container.
   * +optional
   *
   * @generated from field: optional string level = 4;
   */
  level: string;
};

/**
 * Describes the message k8s.io.api.core.v1.SELinuxOptions.
 * Use `create(SELinuxOptionsSchema)` to create a new message.
 */
export declare const SELinuxOptionsSchema: GenMessage<SELinuxOptions, {validType: SELinuxOptionsValid}>;

/**
 * ScaleIOPersistentVolumeSource represents a persistent ScaleIO volume
 *
 * @generated from message k8s.io.api.core.v1.ScaleIOPersistentVolumeSource
 */
export declare type ScaleIOPersistentVolumeSource = Message<"k8s.io.api.core.v1.ScaleIOPersistentVolumeSource"> & {
  /**
   * gateway is the host address of the ScaleIO API Gateway.
   *
   * @generated from field: optional string gateway = 1;
   */
  gateway: string;

  /**
   * system is the name of the storage system as configured in ScaleIO.
   *
   * @generated from field: optional string system = 2;
   */
  system: string;

  /**
   * secretRef references to the secret for ScaleIO user and other
   * sensitive information. If this is not provided, Login operation will fail.
   *
   * @generated from field: optional k8s.io.api.core.v1.SecretReference secretRef = 3;
   */
  secretRef?: SecretReference;

  /**
   * sslEnabled is the flag to enable/disable SSL communication with Gateway, default false
   * +optional
   *
   * @generated from field: optional bool sslEnabled = 4;
   */
  sslEnabled: boolean;

  /**
   * protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
   * +optional
   *
   * @generated from field: optional string protectionDomain = 5;
   */
  protectionDomain: string;

  /**
   * storagePool is the ScaleIO Storage Pool associated with the protection domain.
   * +optional
   *
   * @generated from field: optional string storagePool = 6;
   */
  storagePool: string;

  /**
   * storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
   * Default is ThinProvisioned.
   * +optional
   *
   * @generated from field: optional string storageMode = 7;
   */
  storageMode: string;

  /**
   * volumeName is the name of a volume already created in the ScaleIO system
   * that is associated with this volume source.
   *
   * @generated from field: optional string volumeName = 8;
   */
  volumeName: string;

  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs".
   * Default is "xfs"
   * +optional
   *
   * @generated from field: optional string fsType = 9;
   */
  fsType: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * +optional
   *
   * @generated from field: optional bool readOnly = 10;
   */
  readOnly: boolean;
};

/**
 * ScaleIOPersistentVolumeSource represents a persistent ScaleIO volume
 *
 * @generated from message k8s.io.api.core.v1.ScaleIOPersistentVolumeSource
 */
export declare type ScaleIOPersistentVolumeSourceValid = Message<"k8s.io.api.core.v1.ScaleIOPersistentVolumeSource"> & {
  /**
   * gateway is the host address of the ScaleIO API Gateway.
   *
   * @generated from field: optional string gateway = 1;
   */
  gateway: string;

  /**
   * system is the name of the storage system as configured in ScaleIO.
   *
   * @generated from field: optional string system = 2;
   */
  system: string;

  /**
   * secretRef references to the secret for ScaleIO user and other
   * sensitive information. If this is not provided, Login operation will fail.
   *
   * @generated from field: optional k8s.io.api.core.v1.SecretReference secretRef = 3;
   */
  secretRef?: SecretReferenceValid;

  /**
   * sslEnabled is the flag to enable/disable SSL communication with Gateway, default false
   * +optional
   *
   * @generated from field: optional bool sslEnabled = 4;
   */
  sslEnabled: boolean;

  /**
   * protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
   * +optional
   *
   * @generated from field: optional string protectionDomain = 5;
   */
  protectionDomain: string;

  /**
   * storagePool is the ScaleIO Storage Pool associated with the protection domain.
   * +optional
   *
   * @generated from field: optional string storagePool = 6;
   */
  storagePool: string;

  /**
   * storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
   * Default is ThinProvisioned.
   * +optional
   *
   * @generated from field: optional string storageMode = 7;
   */
  storageMode: string;

  /**
   * volumeName is the name of a volume already created in the ScaleIO system
   * that is associated with this volume source.
   *
   * @generated from field: optional string volumeName = 8;
   */
  volumeName: string;

  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs".
   * Default is "xfs"
   * +optional
   *
   * @generated from field: optional string fsType = 9;
   */
  fsType: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * +optional
   *
   * @generated from field: optional bool readOnly = 10;
   */
  readOnly: boolean;
};

/**
 * Describes the message k8s.io.api.core.v1.ScaleIOPersistentVolumeSource.
 * Use `create(ScaleIOPersistentVolumeSourceSchema)` to create a new message.
 */
export declare const ScaleIOPersistentVolumeSourceSchema: GenMessage<ScaleIOPersistentVolumeSource, {validType: ScaleIOPersistentVolumeSourceValid}>;

/**
 * ScaleIOVolumeSource represents a persistent ScaleIO volume
 *
 * @generated from message k8s.io.api.core.v1.ScaleIOVolumeSource
 */
export declare type ScaleIOVolumeSource = Message<"k8s.io.api.core.v1.ScaleIOVolumeSource"> & {
  /**
   * gateway is the host address of the ScaleIO API Gateway.
   *
   * @generated from field: optional string gateway = 1;
   */
  gateway: string;

  /**
   * system is the name of the storage system as configured in ScaleIO.
   *
   * @generated from field: optional string system = 2;
   */
  system: string;

  /**
   * secretRef references to the secret for ScaleIO user and other
   * sensitive information. If this is not provided, Login operation will fail.
   *
   * @generated from field: optional k8s.io.api.core.v1.LocalObjectReference secretRef = 3;
   */
  secretRef?: LocalObjectReference;

  /**
   * sslEnabled Flag enable/disable SSL communication with Gateway, default false
   * +optional
   *
   * @generated from field: optional bool sslEnabled = 4;
   */
  sslEnabled: boolean;

  /**
   * protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
   * +optional
   *
   * @generated from field: optional string protectionDomain = 5;
   */
  protectionDomain: string;

  /**
   * storagePool is the ScaleIO Storage Pool associated with the protection domain.
   * +optional
   *
   * @generated from field: optional string storagePool = 6;
   */
  storagePool: string;

  /**
   * storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
   * Default is ThinProvisioned.
   * +optional
   *
   * @generated from field: optional string storageMode = 7;
   */
  storageMode: string;

  /**
   * volumeName is the name of a volume already created in the ScaleIO system
   * that is associated with this volume source.
   *
   * @generated from field: optional string volumeName = 8;
   */
  volumeName: string;

  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs".
   * Default is "xfs".
   * +optional
   *
   * @generated from field: optional string fsType = 9;
   */
  fsType: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * +optional
   *
   * @generated from field: optional bool readOnly = 10;
   */
  readOnly: boolean;
};

/**
 * ScaleIOVolumeSource represents a persistent ScaleIO volume
 *
 * @generated from message k8s.io.api.core.v1.ScaleIOVolumeSource
 */
export declare type ScaleIOVolumeSourceValid = Message<"k8s.io.api.core.v1.ScaleIOVolumeSource"> & {
  /**
   * gateway is the host address of the ScaleIO API Gateway.
   *
   * @generated from field: optional string gateway = 1;
   */
  gateway: string;

  /**
   * system is the name of the storage system as configured in ScaleIO.
   *
   * @generated from field: optional string system = 2;
   */
  system: string;

  /**
   * secretRef references to the secret for ScaleIO user and other
   * sensitive information. If this is not provided, Login operation will fail.
   *
   * @generated from field: optional k8s.io.api.core.v1.LocalObjectReference secretRef = 3;
   */
  secretRef?: LocalObjectReferenceValid;

  /**
   * sslEnabled Flag enable/disable SSL communication with Gateway, default false
   * +optional
   *
   * @generated from field: optional bool sslEnabled = 4;
   */
  sslEnabled: boolean;

  /**
   * protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
   * +optional
   *
   * @generated from field: optional string protectionDomain = 5;
   */
  protectionDomain: string;

  /**
   * storagePool is the ScaleIO Storage Pool associated with the protection domain.
   * +optional
   *
   * @generated from field: optional string storagePool = 6;
   */
  storagePool: string;

  /**
   * storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
   * Default is ThinProvisioned.
   * +optional
   *
   * @generated from field: optional string storageMode = 7;
   */
  storageMode: string;

  /**
   * volumeName is the name of a volume already created in the ScaleIO system
   * that is associated with this volume source.
   *
   * @generated from field: optional string volumeName = 8;
   */
  volumeName: string;

  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs".
   * Default is "xfs".
   * +optional
   *
   * @generated from field: optional string fsType = 9;
   */
  fsType: string;

  /**
   * readOnly Defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * +optional
   *
   * @generated from field: optional bool readOnly = 10;
   */
  readOnly: boolean;
};

/**
 * Describes the message k8s.io.api.core.v1.ScaleIOVolumeSource.
 * Use `create(ScaleIOVolumeSourceSchema)` to create a new message.
 */
export declare const ScaleIOVolumeSourceSchema: GenMessage<ScaleIOVolumeSource, {validType: ScaleIOVolumeSourceValid}>;

/**
 * A scope selector represents the AND of the selectors represented
 * by the scoped-resource selector requirements.
 * +structType=atomic
 *
 * @generated from message k8s.io.api.core.v1.ScopeSelector
 */
export declare type ScopeSelector = Message<"k8s.io.api.core.v1.ScopeSelector"> & {
  /**
   * A list of scope selector requirements by scope of the resources.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.ScopedResourceSelectorRequirement matchExpressions = 1;
   */
  matchExpressions: ScopedResourceSelectorRequirement[];
};

/**
 * A scope selector represents the AND of the selectors represented
 * by the scoped-resource selector requirements.
 * +structType=atomic
 *
 * @generated from message k8s.io.api.core.v1.ScopeSelector
 */
export declare type ScopeSelectorValid = Message<"k8s.io.api.core.v1.ScopeSelector"> & {
  /**
   * A list of scope selector requirements by scope of the resources.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.ScopedResourceSelectorRequirement matchExpressions = 1;
   */
  matchExpressions: ScopedResourceSelectorRequirementValid[];
};

/**
 * Describes the message k8s.io.api.core.v1.ScopeSelector.
 * Use `create(ScopeSelectorSchema)` to create a new message.
 */
export declare const ScopeSelectorSchema: GenMessage<ScopeSelector, {validType: ScopeSelectorValid}>;

/**
 * A scoped-resource selector requirement is a selector that contains values, a scope name, and an operator
 * that relates the scope name and values.
 *
 * @generated from message k8s.io.api.core.v1.ScopedResourceSelectorRequirement
 */
export declare type ScopedResourceSelectorRequirement = Message<"k8s.io.api.core.v1.ScopedResourceSelectorRequirement"> & {
  /**
   * The name of the scope that the selector applies to.
   *
   * @generated from field: optional string scopeName = 1;
   */
  scopeName: string;

  /**
   * Represents a scope's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist.
   *
   * @generated from field: optional string operator = 2;
   */
  operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty.
   * This array is replaced during a strategic merge patch.
   * +optional
   *
   * @generated from field: repeated string values = 3;
   */
  values: string[];
};

/**
 * A scoped-resource selector requirement is a selector that contains values, a scope name, and an operator
 * that relates the scope name and values.
 *
 * @generated from message k8s.io.api.core.v1.ScopedResourceSelectorRequirement
 */
export declare type ScopedResourceSelectorRequirementValid = Message<"k8s.io.api.core.v1.ScopedResourceSelectorRequirement"> & {
  /**
   * The name of the scope that the selector applies to.
   *
   * @generated from field: optional string scopeName = 1;
   */
  scopeName: string;

  /**
   * Represents a scope's relationship to a set of values.
   * Valid operators are In, NotIn, Exists, DoesNotExist.
   *
   * @generated from field: optional string operator = 2;
   */
  operator: string;

  /**
   * An array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty.
   * This array is replaced during a strategic merge patch.
   * +optional
   *
   * @generated from field: repeated string values = 3;
   */
  values: string[];
};

/**
 * Describes the message k8s.io.api.core.v1.ScopedResourceSelectorRequirement.
 * Use `create(ScopedResourceSelectorRequirementSchema)` to create a new message.
 */
export declare const ScopedResourceSelectorRequirementSchema: GenMessage<ScopedResourceSelectorRequirement, {validType: ScopedResourceSelectorRequirementValid}>;

/**
 * SeccompProfile defines a pod/container's seccomp profile settings.
 * Only one profile source may be set.
 * +union
 *
 * @generated from message k8s.io.api.core.v1.SeccompProfile
 */
export declare type SeccompProfile = Message<"k8s.io.api.core.v1.SeccompProfile"> & {
  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   * +unionDiscriminator
   *
   * @generated from field: optional string type = 1;
   */
  type: string;

  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must only be set if type is "Localhost".
   * +optional
   *
   * @generated from field: optional string localhostProfile = 2;
   */
  localhostProfile: string;
};

/**
 * SeccompProfile defines a pod/container's seccomp profile settings.
 * Only one profile source may be set.
 * +union
 *
 * @generated from message k8s.io.api.core.v1.SeccompProfile
 */
export declare type SeccompProfileValid = Message<"k8s.io.api.core.v1.SeccompProfile"> & {
  /**
   * type indicates which kind of seccomp profile will be applied.
   * Valid options are:
   *
   * Localhost - a profile defined in a file on the node should be used.
   * RuntimeDefault - the container runtime default profile should be used.
   * Unconfined - no profile should be applied.
   * +unionDiscriminator
   *
   * @generated from field: optional string type = 1;
   */
  type: string;

  /**
   * localhostProfile indicates a profile defined in a file on the node should be used.
   * The profile must be preconfigured on the node to work.
   * Must be a descending path, relative to the kubelet's configured seccomp profile location.
   * Must only be set if type is "Localhost".
   * +optional
   *
   * @generated from field: optional string localhostProfile = 2;
   */
  localhostProfile: string;
};

/**
 * Describes the message k8s.io.api.core.v1.SeccompProfile.
 * Use `create(SeccompProfileSchema)` to create a new message.
 */
export declare const SeccompProfileSchema: GenMessage<SeccompProfile, {validType: SeccompProfileValid}>;

/**
 * Secret holds secret data of a certain type. The total bytes of the values in
 * the Data field must be less than MaxSecretSize bytes.
 *
 * @generated from message k8s.io.api.core.v1.Secret
 */
export declare type Secret = Message<"k8s.io.api.core.v1.Secret"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMeta;

  /**
   * Immutable, if set to true, ensures that data stored in the Secret cannot
   * be updated (only object metadata can be modified).
   * If not set to true, the field can be modified at any time.
   * Defaulted to nil.
   * +optional
   *
   * @generated from field: optional bool immutable = 5;
   */
  immutable: boolean;

  /**
   * Data contains the secret data. Each key must consist of alphanumeric
   * characters, '-', '_' or '.'. The serialized form of the secret data is a
   * base64 encoded string, representing the arbitrary (possibly non-string)
   * data value here. Described in https://tools.ietf.org/html/rfc4648#section-4
   * +optional
   *
   * @generated from field: map<string, bytes> data = 2;
   */
  data: { [key: string]: Uint8Array };

  /**
   * stringData allows specifying non-binary secret data in string form.
   * It is provided as a write-only input field for convenience.
   * All keys and values are merged into the data field on write, overwriting any existing values.
   * The stringData field is never output when reading from the API.
   * +k8s:conversion-gen=false
   * +optional
   *
   * @generated from field: map<string, string> stringData = 4;
   */
  stringData: { [key: string]: string };

  /**
   * Used to facilitate programmatic handling of secret data.
   * More info: https://kubernetes.io/docs/concepts/configuration/secret/#secret-types
   * +optional
   *
   * @generated from field: optional string type = 3;
   */
  type: string;
};

/**
 * Secret holds secret data of a certain type. The total bytes of the values in
 * the Data field must be less than MaxSecretSize bytes.
 *
 * @generated from message k8s.io.api.core.v1.Secret
 */
export declare type SecretValid = Message<"k8s.io.api.core.v1.Secret"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMetaValid;

  /**
   * Immutable, if set to true, ensures that data stored in the Secret cannot
   * be updated (only object metadata can be modified).
   * If not set to true, the field can be modified at any time.
   * Defaulted to nil.
   * +optional
   *
   * @generated from field: optional bool immutable = 5;
   */
  immutable: boolean;

  /**
   * Data contains the secret data. Each key must consist of alphanumeric
   * characters, '-', '_' or '.'. The serialized form of the secret data is a
   * base64 encoded string, representing the arbitrary (possibly non-string)
   * data value here. Described in https://tools.ietf.org/html/rfc4648#section-4
   * +optional
   *
   * @generated from field: map<string, bytes> data = 2;
   */
  data: { [key: string]: Uint8Array };

  /**
   * stringData allows specifying non-binary secret data in string form.
   * It is provided as a write-only input field for convenience.
   * All keys and values are merged into the data field on write, overwriting any existing values.
   * The stringData field is never output when reading from the API.
   * +k8s:conversion-gen=false
   * +optional
   *
   * @generated from field: map<string, string> stringData = 4;
   */
  stringData: { [key: string]: string };

  /**
   * Used to facilitate programmatic handling of secret data.
   * More info: https://kubernetes.io/docs/concepts/configuration/secret/#secret-types
   * +optional
   *
   * @generated from field: optional string type = 3;
   */
  type: string;
};

/**
 * Describes the message k8s.io.api.core.v1.Secret.
 * Use `create(SecretSchema)` to create a new message.
 */
export declare const SecretSchema: GenMessage<Secret, {validType: SecretValid}>;

/**
 * SecretEnvSource selects a Secret to populate the environment
 * variables with.
 *
 * The contents of the target Secret's Data field will represent the
 * key-value pairs as environment variables.
 *
 * @generated from message k8s.io.api.core.v1.SecretEnvSource
 */
export declare type SecretEnvSource = Message<"k8s.io.api.core.v1.SecretEnvSource"> & {
  /**
   * The Secret to select from.
   *
   * @generated from field: optional k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;
   */
  localObjectReference?: LocalObjectReference;

  /**
   * Specify whether the Secret must be defined
   * +optional
   *
   * @generated from field: optional bool optional = 2;
   */
  optional: boolean;
};

/**
 * SecretEnvSource selects a Secret to populate the environment
 * variables with.
 *
 * The contents of the target Secret's Data field will represent the
 * key-value pairs as environment variables.
 *
 * @generated from message k8s.io.api.core.v1.SecretEnvSource
 */
export declare type SecretEnvSourceValid = Message<"k8s.io.api.core.v1.SecretEnvSource"> & {
  /**
   * The Secret to select from.
   *
   * @generated from field: optional k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;
   */
  localObjectReference?: LocalObjectReferenceValid;

  /**
   * Specify whether the Secret must be defined
   * +optional
   *
   * @generated from field: optional bool optional = 2;
   */
  optional: boolean;
};

/**
 * Describes the message k8s.io.api.core.v1.SecretEnvSource.
 * Use `create(SecretEnvSourceSchema)` to create a new message.
 */
export declare const SecretEnvSourceSchema: GenMessage<SecretEnvSource, {validType: SecretEnvSourceValid}>;

/**
 * SecretKeySelector selects a key of a Secret.
 * +structType=atomic
 *
 * @generated from message k8s.io.api.core.v1.SecretKeySelector
 */
export declare type SecretKeySelector = Message<"k8s.io.api.core.v1.SecretKeySelector"> & {
  /**
   * The name of the secret in the pod's namespace to select from.
   *
   * @generated from field: optional k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;
   */
  localObjectReference?: LocalObjectReference;

  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @generated from field: optional string key = 2;
   */
  key: string;

  /**
   * Specify whether the Secret or its key must be defined
   * +optional
   *
   * @generated from field: optional bool optional = 3;
   */
  optional: boolean;
};

/**
 * SecretKeySelector selects a key of a Secret.
 * +structType=atomic
 *
 * @generated from message k8s.io.api.core.v1.SecretKeySelector
 */
export declare type SecretKeySelectorValid = Message<"k8s.io.api.core.v1.SecretKeySelector"> & {
  /**
   * The name of the secret in the pod's namespace to select from.
   *
   * @generated from field: optional k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;
   */
  localObjectReference?: LocalObjectReferenceValid;

  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @generated from field: optional string key = 2;
   */
  key: string;

  /**
   * Specify whether the Secret or its key must be defined
   * +optional
   *
   * @generated from field: optional bool optional = 3;
   */
  optional: boolean;
};

/**
 * Describes the message k8s.io.api.core.v1.SecretKeySelector.
 * Use `create(SecretKeySelectorSchema)` to create a new message.
 */
export declare const SecretKeySelectorSchema: GenMessage<SecretKeySelector, {validType: SecretKeySelectorValid}>;

/**
 * SecretList is a list of Secret.
 *
 * @generated from message k8s.io.api.core.v1.SecretList
 */
export declare type SecretList = Message<"k8s.io.api.core.v1.SecretList"> & {
  /**
   * Standard list metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMeta;

  /**
   * Items is a list of secret objects.
   * More info: https://kubernetes.io/docs/concepts/configuration/secret
   *
   * @generated from field: repeated k8s.io.api.core.v1.Secret items = 2;
   */
  items: Secret[];
};

/**
 * SecretList is a list of Secret.
 *
 * @generated from message k8s.io.api.core.v1.SecretList
 */
export declare type SecretListValid = Message<"k8s.io.api.core.v1.SecretList"> & {
  /**
   * Standard list metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMetaValid;

  /**
   * Items is a list of secret objects.
   * More info: https://kubernetes.io/docs/concepts/configuration/secret
   *
   * @generated from field: repeated k8s.io.api.core.v1.Secret items = 2;
   */
  items: SecretValid[];
};

/**
 * Describes the message k8s.io.api.core.v1.SecretList.
 * Use `create(SecretListSchema)` to create a new message.
 */
export declare const SecretListSchema: GenMessage<SecretList, {validType: SecretListValid}>;

/**
 * Adapts a secret into a projected volume.
 *
 * The contents of the target Secret's Data field will be presented in a
 * projected volume as files using the keys in the Data field as the file names.
 * Note that this is identical to a secret volume source without the default
 * mode.
 *
 * @generated from message k8s.io.api.core.v1.SecretProjection
 */
export declare type SecretProjection = Message<"k8s.io.api.core.v1.SecretProjection"> & {
  /**
   * @generated from field: optional k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;
   */
  localObjectReference?: LocalObjectReference;

  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.KeyToPath items = 2;
   */
  items: KeyToPath[];

  /**
   * optional field specify whether the Secret or its key must be defined
   * +optional
   *
   * @generated from field: optional bool optional = 4;
   */
  optional: boolean;
};

/**
 * Adapts a secret into a projected volume.
 *
 * The contents of the target Secret's Data field will be presented in a
 * projected volume as files using the keys in the Data field as the file names.
 * Note that this is identical to a secret volume source without the default
 * mode.
 *
 * @generated from message k8s.io.api.core.v1.SecretProjection
 */
export declare type SecretProjectionValid = Message<"k8s.io.api.core.v1.SecretProjection"> & {
  /**
   * @generated from field: optional k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;
   */
  localObjectReference?: LocalObjectReferenceValid;

  /**
   * items if unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.KeyToPath items = 2;
   */
  items: KeyToPathValid[];

  /**
   * optional field specify whether the Secret or its key must be defined
   * +optional
   *
   * @generated from field: optional bool optional = 4;
   */
  optional: boolean;
};

/**
 * Describes the message k8s.io.api.core.v1.SecretProjection.
 * Use `create(SecretProjectionSchema)` to create a new message.
 */
export declare const SecretProjectionSchema: GenMessage<SecretProjection, {validType: SecretProjectionValid}>;

/**
 * SecretReference represents a Secret Reference. It has enough information to retrieve secret
 * in any namespace
 * +structType=atomic
 *
 * @generated from message k8s.io.api.core.v1.SecretReference
 */
export declare type SecretReference = Message<"k8s.io.api.core.v1.SecretReference"> & {
  /**
   * name is unique within a namespace to reference a secret resource.
   * +optional
   *
   * @generated from field: optional string name = 1;
   */
  name: string;

  /**
   * namespace defines the space within which the secret name must be unique.
   * +optional
   *
   * @generated from field: optional string namespace = 2;
   */
  namespace: string;
};

/**
 * SecretReference represents a Secret Reference. It has enough information to retrieve secret
 * in any namespace
 * +structType=atomic
 *
 * @generated from message k8s.io.api.core.v1.SecretReference
 */
export declare type SecretReferenceValid = Message<"k8s.io.api.core.v1.SecretReference"> & {
  /**
   * name is unique within a namespace to reference a secret resource.
   * +optional
   *
   * @generated from field: optional string name = 1;
   */
  name: string;

  /**
   * namespace defines the space within which the secret name must be unique.
   * +optional
   *
   * @generated from field: optional string namespace = 2;
   */
  namespace: string;
};

/**
 * Describes the message k8s.io.api.core.v1.SecretReference.
 * Use `create(SecretReferenceSchema)` to create a new message.
 */
export declare const SecretReferenceSchema: GenMessage<SecretReference, {validType: SecretReferenceValid}>;

/**
 * Adapts a Secret into a volume.
 *
 * The contents of the target Secret's Data field will be presented in a volume
 * as files using the keys in the Data field as the file names.
 * Secret volumes support ownership management and SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.SecretVolumeSource
 */
export declare type SecretVolumeSource = Message<"k8s.io.api.core.v1.SecretVolumeSource"> & {
  /**
   * secretName is the name of the secret in the pod's namespace to use.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   * +optional
   *
   * @generated from field: optional string secretName = 1;
   */
  secretName: string;

  /**
   * items If unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.KeyToPath items = 2;
   */
  items: KeyToPath[];

  /**
   * defaultMode is Optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values
   * for mode bits. Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   * +optional
   *
   * @generated from field: optional int32 defaultMode = 3;
   */
  defaultMode: number;

  /**
   * optional field specify whether the Secret or its keys must be defined
   * +optional
   *
   * @generated from field: optional bool optional = 4;
   */
  optional: boolean;
};

/**
 * Adapts a Secret into a volume.
 *
 * The contents of the target Secret's Data field will be presented in a volume
 * as files using the keys in the Data field as the file names.
 * Secret volumes support ownership management and SELinux relabeling.
 *
 * @generated from message k8s.io.api.core.v1.SecretVolumeSource
 */
export declare type SecretVolumeSourceValid = Message<"k8s.io.api.core.v1.SecretVolumeSource"> & {
  /**
   * secretName is the name of the secret in the pod's namespace to use.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   * +optional
   *
   * @generated from field: optional string secretName = 1;
   */
  secretName: string;

  /**
   * items If unspecified, each key-value pair in the Data field of the referenced
   * Secret will be projected into the volume as a file whose name is the
   * key and content is the value. If specified, the listed keys will be
   * projected into the specified paths, and unlisted keys will not be
   * present. If a key is specified which is not present in the Secret,
   * the volume setup will error unless it is marked optional. Paths must be
   * relative and may not contain the '..' path or start with '..'.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.KeyToPath items = 2;
   */
  items: KeyToPathValid[];

  /**
   * defaultMode is Optional: mode bits used to set permissions on created files by default.
   * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
   * YAML accepts both octal and decimal values, JSON requires decimal values
   * for mode bits. Defaults to 0644.
   * Directories within the path are not affected by this setting.
   * This might be in conflict with other options that affect the file
   * mode, like fsGroup, and the result can be other mode bits set.
   * +optional
   *
   * @generated from field: optional int32 defaultMode = 3;
   */
  defaultMode: number;

  /**
   * optional field specify whether the Secret or its keys must be defined
   * +optional
   *
   * @generated from field: optional bool optional = 4;
   */
  optional: boolean;
};

/**
 * Describes the message k8s.io.api.core.v1.SecretVolumeSource.
 * Use `create(SecretVolumeSourceSchema)` to create a new message.
 */
export declare const SecretVolumeSourceSchema: GenMessage<SecretVolumeSource, {validType: SecretVolumeSourceValid}>;

/**
 * SecurityContext holds security configuration that will be applied to a container.
 * Some fields are present in both SecurityContext and PodSecurityContext.  When both
 * are set, the values in SecurityContext take precedence.
 *
 * @generated from message k8s.io.api.core.v1.SecurityContext
 */
export declare type SecurityContext = Message<"k8s.io.api.core.v1.SecurityContext"> & {
  /**
   * The capabilities to add/drop when running containers.
   * Defaults to the default set of capabilities granted by the container runtime.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.Capabilities capabilities = 1;
   */
  capabilities?: Capabilities;

  /**
   * Run container in privileged mode.
   * Processes in privileged containers are essentially equivalent to root on the host.
   * Defaults to false.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   *
   * @generated from field: optional bool privileged = 2;
   */
  privileged: boolean;

  /**
   * The SELinux context to be applied to the container.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.SELinuxOptions seLinuxOptions = 3;
   */
  seLinuxOptions?: SELinuxOptions;

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options from the PodSecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.WindowsSecurityContextOptions windowsOptions = 10;
   */
  windowsOptions?: WindowsSecurityContextOptions;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   *
   * @generated from field: optional int64 runAsUser = 4;
   */
  runAsUser: bigint;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   *
   * @generated from field: optional int64 runAsGroup = 8;
   */
  runAsGroup: bigint;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * +optional
   *
   * @generated from field: optional bool runAsNonRoot = 5;
   */
  runAsNonRoot: boolean;

  /**
   * Whether this container has a read-only root filesystem.
   * Default is false.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   *
   * @generated from field: optional bool readOnlyRootFilesystem = 6;
   */
  readOnlyRootFilesystem: boolean;

  /**
   * AllowPrivilegeEscalation controls whether a process can gain more
   * privileges than its parent process. This bool directly controls if
   * the no_new_privs flag will be set on the container process.
   * AllowPrivilegeEscalation is true always when the container is:
   * 1) run as Privileged
   * 2) has CAP_SYS_ADMIN
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   *
   * @generated from field: optional bool allowPrivilegeEscalation = 7;
   */
  allowPrivilegeEscalation: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers.
   * The default is DefaultProcMount which uses the container runtime defaults for
   * readonly paths and masked paths.
   * This requires the ProcMountType feature flag to be enabled.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   *
   * @generated from field: optional string procMount = 9;
   */
  procMount: string;

  /**
   * The seccomp options to use by this container. If seccomp options are
   * provided at both the pod & container level, the container options
   * override the pod options.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.SeccompProfile seccompProfile = 11;
   */
  seccompProfile?: SeccompProfile;
};

/**
 * SecurityContext holds security configuration that will be applied to a container.
 * Some fields are present in both SecurityContext and PodSecurityContext.  When both
 * are set, the values in SecurityContext take precedence.
 *
 * @generated from message k8s.io.api.core.v1.SecurityContext
 */
export declare type SecurityContextValid = Message<"k8s.io.api.core.v1.SecurityContext"> & {
  /**
   * The capabilities to add/drop when running containers.
   * Defaults to the default set of capabilities granted by the container runtime.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.Capabilities capabilities = 1;
   */
  capabilities?: CapabilitiesValid;

  /**
   * Run container in privileged mode.
   * Processes in privileged containers are essentially equivalent to root on the host.
   * Defaults to false.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   *
   * @generated from field: optional bool privileged = 2;
   */
  privileged: boolean;

  /**
   * The SELinux context to be applied to the container.
   * If unspecified, the container runtime will allocate a random SELinux context for each
   * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.SELinuxOptions seLinuxOptions = 3;
   */
  seLinuxOptions?: SELinuxOptionsValid;

  /**
   * The Windows specific settings applied to all containers.
   * If unspecified, the options from the PodSecurityContext will be used.
   * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is linux.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.WindowsSecurityContextOptions windowsOptions = 10;
   */
  windowsOptions?: WindowsSecurityContextOptionsValid;

  /**
   * The UID to run the entrypoint of the container process.
   * Defaults to user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   *
   * @generated from field: optional int64 runAsUser = 4;
   */
  runAsUser: bigint;

  /**
   * The GID to run the entrypoint of the container process.
   * Uses runtime default if unset.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   *
   * @generated from field: optional int64 runAsGroup = 8;
   */
  runAsGroup: bigint;

  /**
   * Indicates that the container must run as a non-root user.
   * If true, the Kubelet will validate the image at runtime to ensure that it
   * does not run as UID 0 (root) and fail to start the container if it does.
   * If unset or false, no such validation will be performed.
   * May also be set in PodSecurityContext.  If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * +optional
   *
   * @generated from field: optional bool runAsNonRoot = 5;
   */
  runAsNonRoot: boolean;

  /**
   * Whether this container has a read-only root filesystem.
   * Default is false.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   *
   * @generated from field: optional bool readOnlyRootFilesystem = 6;
   */
  readOnlyRootFilesystem: boolean;

  /**
   * AllowPrivilegeEscalation controls whether a process can gain more
   * privileges than its parent process. This bool directly controls if
   * the no_new_privs flag will be set on the container process.
   * AllowPrivilegeEscalation is true always when the container is:
   * 1) run as Privileged
   * 2) has CAP_SYS_ADMIN
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   *
   * @generated from field: optional bool allowPrivilegeEscalation = 7;
   */
  allowPrivilegeEscalation: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers.
   * The default is DefaultProcMount which uses the container runtime defaults for
   * readonly paths and masked paths.
   * This requires the ProcMountType feature flag to be enabled.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   *
   * @generated from field: optional string procMount = 9;
   */
  procMount: string;

  /**
   * The seccomp options to use by this container. If seccomp options are
   * provided at both the pod & container level, the container options
   * override the pod options.
   * Note that this field cannot be set when spec.os.name is windows.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.SeccompProfile seccompProfile = 11;
   */
  seccompProfile?: SeccompProfileValid;
};

/**
 * Describes the message k8s.io.api.core.v1.SecurityContext.
 * Use `create(SecurityContextSchema)` to create a new message.
 */
export declare const SecurityContextSchema: GenMessage<SecurityContext, {validType: SecurityContextValid}>;

/**
 * SerializedReference is a reference to serialized object.
 *
 * @generated from message k8s.io.api.core.v1.SerializedReference
 */
export declare type SerializedReference = Message<"k8s.io.api.core.v1.SerializedReference"> & {
  /**
   * The reference to an object in the system.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ObjectReference reference = 1;
   */
  reference?: ObjectReference;
};

/**
 * SerializedReference is a reference to serialized object.
 *
 * @generated from message k8s.io.api.core.v1.SerializedReference
 */
export declare type SerializedReferenceValid = Message<"k8s.io.api.core.v1.SerializedReference"> & {
  /**
   * The reference to an object in the system.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ObjectReference reference = 1;
   */
  reference?: ObjectReferenceValid;
};

/**
 * Describes the message k8s.io.api.core.v1.SerializedReference.
 * Use `create(SerializedReferenceSchema)` to create a new message.
 */
export declare const SerializedReferenceSchema: GenMessage<SerializedReference, {validType: SerializedReferenceValid}>;

/**
 * Service is a named abstraction of software service (for example, mysql) consisting of local port
 * (for example 3306) that the proxy listens on, and the selector that determines which pods
 * will answer requests sent through the proxy.
 *
 * @generated from message k8s.io.api.core.v1.Service
 */
export declare type Service = Message<"k8s.io.api.core.v1.Service"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMeta;

  /**
   * Spec defines the behavior of a service.
   * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ServiceSpec spec = 2;
   */
  spec?: ServiceSpec;

  /**
   * Most recently observed status of the service.
   * Populated by the system.
   * Read-only.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ServiceStatus status = 3;
   */
  status?: ServiceStatus;
};

/**
 * Service is a named abstraction of software service (for example, mysql) consisting of local port
 * (for example 3306) that the proxy listens on, and the selector that determines which pods
 * will answer requests sent through the proxy.
 *
 * @generated from message k8s.io.api.core.v1.Service
 */
export declare type ServiceValid = Message<"k8s.io.api.core.v1.Service"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMetaValid;

  /**
   * Spec defines the behavior of a service.
   * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ServiceSpec spec = 2;
   */
  spec?: ServiceSpecValid;

  /**
   * Most recently observed status of the service.
   * Populated by the system.
   * Read-only.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ServiceStatus status = 3;
   */
  status?: ServiceStatusValid;
};

/**
 * Describes the message k8s.io.api.core.v1.Service.
 * Use `create(ServiceSchema)` to create a new message.
 */
export declare const ServiceSchema: GenMessage<Service, {validType: ServiceValid}>;

/**
 * ServiceAccount binds together:
 * * a name, understood by users, and perhaps by peripheral systems, for an identity
 * * a principal that can be authenticated and authorized
 * * a set of secrets
 *
 * @generated from message k8s.io.api.core.v1.ServiceAccount
 */
export declare type ServiceAccount = Message<"k8s.io.api.core.v1.ServiceAccount"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMeta;

  /**
   * Secrets is a list of the secrets in the same namespace that pods running using this ServiceAccount are allowed to use.
   * Pods are only limited to this list if this service account has a "kubernetes.io/enforce-mountable-secrets" annotation set to "true".
   * This field should not be used to find auto-generated service account token secrets for use outside of pods.
   * Instead, tokens can be requested directly using the TokenRequest API, or service account token secrets can be manually created.
   * More info: https://kubernetes.io/docs/concepts/configuration/secret
   * +optional
   * +patchMergeKey=name
   * +patchStrategy=merge
   *
   * @generated from field: repeated k8s.io.api.core.v1.ObjectReference secrets = 2;
   */
  secrets: ObjectReference[];

  /**
   * ImagePullSecrets is a list of references to secrets in the same namespace to use for pulling any images
   * in pods that reference this ServiceAccount. ImagePullSecrets are distinct from Secrets because Secrets
   * can be mounted in the pod, but ImagePullSecrets are only accessed by the kubelet.
   * More info: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.LocalObjectReference imagePullSecrets = 3;
   */
  imagePullSecrets: LocalObjectReference[];

  /**
   * AutomountServiceAccountToken indicates whether pods running as this service account should have an API token automatically mounted.
   * Can be overridden at the pod level.
   * +optional
   *
   * @generated from field: optional bool automountServiceAccountToken = 4;
   */
  automountServiceAccountToken: boolean;
};

/**
 * ServiceAccount binds together:
 * * a name, understood by users, and perhaps by peripheral systems, for an identity
 * * a principal that can be authenticated and authorized
 * * a set of secrets
 *
 * @generated from message k8s.io.api.core.v1.ServiceAccount
 */
export declare type ServiceAccountValid = Message<"k8s.io.api.core.v1.ServiceAccount"> & {
  /**
   * Standard object's metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;
   */
  metadata?: ObjectMetaValid;

  /**
   * Secrets is a list of the secrets in the same namespace that pods running using this ServiceAccount are allowed to use.
   * Pods are only limited to this list if this service account has a "kubernetes.io/enforce-mountable-secrets" annotation set to "true".
   * This field should not be used to find auto-generated service account token secrets for use outside of pods.
   * Instead, tokens can be requested directly using the TokenRequest API, or service account token secrets can be manually created.
   * More info: https://kubernetes.io/docs/concepts/configuration/secret
   * +optional
   * +patchMergeKey=name
   * +patchStrategy=merge
   *
   * @generated from field: repeated k8s.io.api.core.v1.ObjectReference secrets = 2;
   */
  secrets: ObjectReferenceValid[];

  /**
   * ImagePullSecrets is a list of references to secrets in the same namespace to use for pulling any images
   * in pods that reference this ServiceAccount. ImagePullSecrets are distinct from Secrets because Secrets
   * can be mounted in the pod, but ImagePullSecrets are only accessed by the kubelet.
   * More info: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.LocalObjectReference imagePullSecrets = 3;
   */
  imagePullSecrets: LocalObjectReferenceValid[];

  /**
   * AutomountServiceAccountToken indicates whether pods running as this service account should have an API token automatically mounted.
   * Can be overridden at the pod level.
   * +optional
   *
   * @generated from field: optional bool automountServiceAccountToken = 4;
   */
  automountServiceAccountToken: boolean;
};

/**
 * Describes the message k8s.io.api.core.v1.ServiceAccount.
 * Use `create(ServiceAccountSchema)` to create a new message.
 */
export declare const ServiceAccountSchema: GenMessage<ServiceAccount, {validType: ServiceAccountValid}>;

/**
 * ServiceAccountList is a list of ServiceAccount objects
 *
 * @generated from message k8s.io.api.core.v1.ServiceAccountList
 */
export declare type ServiceAccountList = Message<"k8s.io.api.core.v1.ServiceAccountList"> & {
  /**
   * Standard list metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMeta;

  /**
   * List of ServiceAccounts.
   * More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
   *
   * @generated from field: repeated k8s.io.api.core.v1.ServiceAccount items = 2;
   */
  items: ServiceAccount[];
};

/**
 * ServiceAccountList is a list of ServiceAccount objects
 *
 * @generated from message k8s.io.api.core.v1.ServiceAccountList
 */
export declare type ServiceAccountListValid = Message<"k8s.io.api.core.v1.ServiceAccountList"> & {
  /**
   * Standard list metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMetaValid;

  /**
   * List of ServiceAccounts.
   * More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
   *
   * @generated from field: repeated k8s.io.api.core.v1.ServiceAccount items = 2;
   */
  items: ServiceAccountValid[];
};

/**
 * Describes the message k8s.io.api.core.v1.ServiceAccountList.
 * Use `create(ServiceAccountListSchema)` to create a new message.
 */
export declare const ServiceAccountListSchema: GenMessage<ServiceAccountList, {validType: ServiceAccountListValid}>;

/**
 * ServiceAccountTokenProjection represents a projected service account token
 * volume. This projection can be used to insert a service account token into
 * the pods runtime filesystem for use against APIs (Kubernetes API Server or
 * otherwise).
 *
 * @generated from message k8s.io.api.core.v1.ServiceAccountTokenProjection
 */
export declare type ServiceAccountTokenProjection = Message<"k8s.io.api.core.v1.ServiceAccountTokenProjection"> & {
  /**
   * audience is the intended audience of the token. A recipient of a token
   * must identify itself with an identifier specified in the audience of the
   * token, and otherwise should reject the token. The audience defaults to the
   * identifier of the apiserver.
   * +optional
   *
   * @generated from field: optional string audience = 1;
   */
  audience: string;

  /**
   * expirationSeconds is the requested duration of validity of the service
   * account token. As the token approaches expiration, the kubelet volume
   * plugin will proactively rotate the service account token. The kubelet will
   * start trying to rotate the token if the token is older than 80 percent of
   * its time to live or if the token is older than 24 hours.Defaults to 1 hour
   * and must be at least 10 minutes.
   * +optional
   *
   * @generated from field: optional int64 expirationSeconds = 2;
   */
  expirationSeconds: bigint;

  /**
   * path is the path relative to the mount point of the file to project the
   * token into.
   *
   * @generated from field: optional string path = 3;
   */
  path: string;
};

/**
 * ServiceAccountTokenProjection represents a projected service account token
 * volume. This projection can be used to insert a service account token into
 * the pods runtime filesystem for use against APIs (Kubernetes API Server or
 * otherwise).
 *
 * @generated from message k8s.io.api.core.v1.ServiceAccountTokenProjection
 */
export declare type ServiceAccountTokenProjectionValid = Message<"k8s.io.api.core.v1.ServiceAccountTokenProjection"> & {
  /**
   * audience is the intended audience of the token. A recipient of a token
   * must identify itself with an identifier specified in the audience of the
   * token, and otherwise should reject the token. The audience defaults to the
   * identifier of the apiserver.
   * +optional
   *
   * @generated from field: optional string audience = 1;
   */
  audience: string;

  /**
   * expirationSeconds is the requested duration of validity of the service
   * account token. As the token approaches expiration, the kubelet volume
   * plugin will proactively rotate the service account token. The kubelet will
   * start trying to rotate the token if the token is older than 80 percent of
   * its time to live or if the token is older than 24 hours.Defaults to 1 hour
   * and must be at least 10 minutes.
   * +optional
   *
   * @generated from field: optional int64 expirationSeconds = 2;
   */
  expirationSeconds: bigint;

  /**
   * path is the path relative to the mount point of the file to project the
   * token into.
   *
   * @generated from field: optional string path = 3;
   */
  path: string;
};

/**
 * Describes the message k8s.io.api.core.v1.ServiceAccountTokenProjection.
 * Use `create(ServiceAccountTokenProjectionSchema)` to create a new message.
 */
export declare const ServiceAccountTokenProjectionSchema: GenMessage<ServiceAccountTokenProjection, {validType: ServiceAccountTokenProjectionValid}>;

/**
 * ServiceList holds a list of services.
 *
 * @generated from message k8s.io.api.core.v1.ServiceList
 */
export declare type ServiceList = Message<"k8s.io.api.core.v1.ServiceList"> & {
  /**
   * Standard list metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMeta;

  /**
   * List of services
   *
   * @generated from field: repeated k8s.io.api.core.v1.Service items = 2;
   */
  items: Service[];
};

/**
 * ServiceList holds a list of services.
 *
 * @generated from message k8s.io.api.core.v1.ServiceList
 */
export declare type ServiceListValid = Message<"k8s.io.api.core.v1.ServiceList"> & {
  /**
   * Standard list metadata.
   * More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;
   */
  metadata?: ListMetaValid;

  /**
   * List of services
   *
   * @generated from field: repeated k8s.io.api.core.v1.Service items = 2;
   */
  items: ServiceValid[];
};

/**
 * Describes the message k8s.io.api.core.v1.ServiceList.
 * Use `create(ServiceListSchema)` to create a new message.
 */
export declare const ServiceListSchema: GenMessage<ServiceList, {validType: ServiceListValid}>;

/**
 * ServicePort contains information on service's port.
 *
 * @generated from message k8s.io.api.core.v1.ServicePort
 */
export declare type ServicePort = Message<"k8s.io.api.core.v1.ServicePort"> & {
  /**
   * The name of this port within the service. This must be a DNS_LABEL.
   * All ports within a ServiceSpec must have unique names. When considering
   * the endpoints for a Service, this must match the 'name' field in the
   * EndpointPort.
   * Optional if only one ServicePort is defined on this service.
   * +optional
   *
   * @generated from field: optional string name = 1;
   */
  name: string;

  /**
   * The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
   * Default is TCP.
   * +default="TCP"
   * +optional
   *
   * @generated from field: optional string protocol = 2;
   */
  protocol: string;

  /**
   * The application protocol for this port.
   * This field follows standard Kubernetes label syntax.
   * Un-prefixed names are reserved for IANA standard service names (as per
   * RFC-6335 and https://www.iana.org/assignments/service-names).
   * Non-standard protocols should use prefixed names such as
   * mycompany.com/my-custom-protocol.
   * +optional
   *
   * @generated from field: optional string appProtocol = 6;
   */
  appProtocol: string;

  /**
   * The port that will be exposed by this service.
   *
   * @generated from field: optional int32 port = 3;
   */
  port: number;

  /**
   * Number or name of the port to access on the pods targeted by the service.
   * Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   * If this is a string, it will be looked up as a named port in the
   * target Pod's container ports. If this is not specified, the value
   * of the 'port' field is used (an identity map).
   * This field is ignored for services with clusterIP=None, and should be
   * omitted or set equal to the 'port' field.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.util.intstr.IntOrString targetPort = 4;
   */
  targetPort?: IntOrString;

  /**
   * The port on each node on which this service is exposed when type is
   * NodePort or LoadBalancer.  Usually assigned by the system. If a value is
   * specified, in-range, and not in use it will be used, otherwise the
   * operation will fail.  If not specified, a port will be allocated if this
   * Service requires one.  If this field is specified when creating a
   * Service which does not need it, creation will fail. This field will be
   * wiped when updating a Service to no longer need it (e.g. changing type
   * from NodePort to ClusterIP).
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
   * +optional
   *
   * @generated from field: optional int32 nodePort = 5;
   */
  nodePort: number;
};

/**
 * ServicePort contains information on service's port.
 *
 * @generated from message k8s.io.api.core.v1.ServicePort
 */
export declare type ServicePortValid = Message<"k8s.io.api.core.v1.ServicePort"> & {
  /**
   * The name of this port within the service. This must be a DNS_LABEL.
   * All ports within a ServiceSpec must have unique names. When considering
   * the endpoints for a Service, this must match the 'name' field in the
   * EndpointPort.
   * Optional if only one ServicePort is defined on this service.
   * +optional
   *
   * @generated from field: optional string name = 1;
   */
  name: string;

  /**
   * The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
   * Default is TCP.
   * +default="TCP"
   * +optional
   *
   * @generated from field: optional string protocol = 2;
   */
  protocol: string;

  /**
   * The application protocol for this port.
   * This field follows standard Kubernetes label syntax.
   * Un-prefixed names are reserved for IANA standard service names (as per
   * RFC-6335 and https://www.iana.org/assignments/service-names).
   * Non-standard protocols should use prefixed names such as
   * mycompany.com/my-custom-protocol.
   * +optional
   *
   * @generated from field: optional string appProtocol = 6;
   */
  appProtocol: string;

  /**
   * The port that will be exposed by this service.
   *
   * @generated from field: optional int32 port = 3;
   */
  port: number;

  /**
   * Number or name of the port to access on the pods targeted by the service.
   * Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
   * If this is a string, it will be looked up as a named port in the
   * target Pod's container ports. If this is not specified, the value
   * of the 'port' field is used (an identity map).
   * This field is ignored for services with clusterIP=None, and should be
   * omitted or set equal to the 'port' field.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.util.intstr.IntOrString targetPort = 4;
   */
  targetPort?: IntOrStringValid;

  /**
   * The port on each node on which this service is exposed when type is
   * NodePort or LoadBalancer.  Usually assigned by the system. If a value is
   * specified, in-range, and not in use it will be used, otherwise the
   * operation will fail.  If not specified, a port will be allocated if this
   * Service requires one.  If this field is specified when creating a
   * Service which does not need it, creation will fail. This field will be
   * wiped when updating a Service to no longer need it (e.g. changing type
   * from NodePort to ClusterIP).
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
   * +optional
   *
   * @generated from field: optional int32 nodePort = 5;
   */
  nodePort: number;
};

/**
 * Describes the message k8s.io.api.core.v1.ServicePort.
 * Use `create(ServicePortSchema)` to create a new message.
 */
export declare const ServicePortSchema: GenMessage<ServicePort, {validType: ServicePortValid}>;

/**
 * ServiceProxyOptions is the query options to a Service's proxy call.
 *
 * @generated from message k8s.io.api.core.v1.ServiceProxyOptions
 */
export declare type ServiceProxyOptions = Message<"k8s.io.api.core.v1.ServiceProxyOptions"> & {
  /**
   * Path is the part of URLs that include service endpoints, suffixes,
   * and parameters to use for the current proxy request to service.
   * For example, the whole request URL is
   * http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
   * Path is _search?q=user:kimchy.
   * +optional
   *
   * @generated from field: optional string path = 1;
   */
  path: string;
};

/**
 * ServiceProxyOptions is the query options to a Service's proxy call.
 *
 * @generated from message k8s.io.api.core.v1.ServiceProxyOptions
 */
export declare type ServiceProxyOptionsValid = Message<"k8s.io.api.core.v1.ServiceProxyOptions"> & {
  /**
   * Path is the part of URLs that include service endpoints, suffixes,
   * and parameters to use for the current proxy request to service.
   * For example, the whole request URL is
   * http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
   * Path is _search?q=user:kimchy.
   * +optional
   *
   * @generated from field: optional string path = 1;
   */
  path: string;
};

/**
 * Describes the message k8s.io.api.core.v1.ServiceProxyOptions.
 * Use `create(ServiceProxyOptionsSchema)` to create a new message.
 */
export declare const ServiceProxyOptionsSchema: GenMessage<ServiceProxyOptions, {validType: ServiceProxyOptionsValid}>;

/**
 * ServiceSpec describes the attributes that a user creates on a service.
 *
 * @generated from message k8s.io.api.core.v1.ServiceSpec
 */
export declare type ServiceSpec = Message<"k8s.io.api.core.v1.ServiceSpec"> & {
  /**
   * The list of ports that are exposed by this service.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
   * +patchMergeKey=port
   * +patchStrategy=merge
   * +listType=map
   * +listMapKey=port
   * +listMapKey=protocol
   *
   * @generated from field: repeated k8s.io.api.core.v1.ServicePort ports = 1;
   */
  ports: ServicePort[];

  /**
   * Route service traffic to pods with label keys and values matching this
   * selector. If empty or not present, the service is assumed to have an
   * external process managing its endpoints, which Kubernetes will not
   * modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
   * Ignored if type is ExternalName.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/
   * +optional
   * +mapType=atomic
   *
   * @generated from field: map<string, string> selector = 2;
   */
  selector: { [key: string]: string };

  /**
   * clusterIP is the IP address of the service and is usually assigned
   * randomly. If an address is specified manually, is in-range (as per
   * system configuration), and is not in use, it will be allocated to the
   * service; otherwise creation of the service will fail. This field may not
   * be changed through updates unless the type field is also being changed
   * to ExternalName (which requires this field to be blank) or the type
   * field is being changed from ExternalName (in which case this field may
   * optionally be specified, as describe above).  Valid values are "None",
   * empty string (""), or a valid IP address. Setting this to "None" makes a
   * "headless service" (no virtual IP), which is useful when direct endpoint
   * connections are preferred and proxying is not required.  Only applies to
   * types ClusterIP, NodePort, and LoadBalancer. If this field is specified
   * when creating a Service of type ExternalName, creation will fail. This
   * field will be wiped when updating a Service to type ExternalName.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
   * +optional
   *
   * @generated from field: optional string clusterIP = 3;
   */
  clusterIP: string;

  /**
   * ClusterIPs is a list of IP addresses assigned to this service, and are
   * usually assigned randomly.  If an address is specified manually, is
   * in-range (as per system configuration), and is not in use, it will be
   * allocated to the service; otherwise creation of the service will fail.
   * This field may not be changed through updates unless the type field is
   * also being changed to ExternalName (which requires this field to be
   * empty) or the type field is being changed from ExternalName (in which
   * case this field may optionally be specified, as describe above).  Valid
   * values are "None", empty string (""), or a valid IP address.  Setting
   * this to "None" makes a "headless service" (no virtual IP), which is
   * useful when direct endpoint connections are preferred and proxying is
   * not required.  Only applies to types ClusterIP, NodePort, and
   * LoadBalancer. If this field is specified when creating a Service of type
   * ExternalName, creation will fail. This field will be wiped when updating
   * a Service to type ExternalName.  If this field is not specified, it will
   * be initialized from the clusterIP field.  If this field is specified,
   * clients must ensure that clusterIPs[0] and clusterIP have the same
   * value.
   *
   * This field may hold a maximum of two entries (dual-stack IPs, in either order).
   * These IPs must correspond to the values of the ipFamilies field. Both
   * clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
   * +listType=atomic
   * +optional
   *
   * @generated from field: repeated string clusterIPs = 18;
   */
  clusterIPs: string[];

  /**
   * type determines how the Service is exposed. Defaults to ClusterIP. Valid
   * options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
   * "ClusterIP" allocates a cluster-internal IP address for load-balancing
   * to endpoints. Endpoints are determined by the selector or if that is not
   * specified, by manual construction of an Endpoints object or
   * EndpointSlice objects. If clusterIP is "None", no virtual IP is
   * allocated and the endpoints are published as a set of endpoints rather
   * than a virtual IP.
   * "NodePort" builds on ClusterIP and allocates a port on every node which
   * routes to the same endpoints as the clusterIP.
   * "LoadBalancer" builds on NodePort and creates an external load-balancer
   * (if supported in the current cloud) which routes to the same endpoints
   * as the clusterIP.
   * "ExternalName" aliases this service to the specified externalName.
   * Several other fields do not apply to ExternalName services.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
   * +optional
   *
   * @generated from field: optional string type = 4;
   */
  type: string;

  /**
   * externalIPs is a list of IP addresses for which nodes in the cluster
   * will also accept traffic for this service.  These IPs are not managed by
   * Kubernetes.  The user is responsible for ensuring that traffic arrives
   * at a node with this IP.  A common example is external load-balancers
   * that are not part of the Kubernetes system.
   * +optional
   *
   * @generated from field: repeated string externalIPs = 5;
   */
  externalIPs: string[];

  /**
   * Supports "ClientIP" and "None". Used to maintain session affinity.
   * Enable client IP based session affinity.
   * Must be ClientIP or None.
   * Defaults to None.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
   * +optional
   *
   * @generated from field: optional string sessionAffinity = 7;
   */
  sessionAffinity: string;

  /**
   * Only applies to Service Type: LoadBalancer.
   * This feature depends on whether the underlying cloud-provider supports specifying
   * the loadBalancerIP when a load balancer is created.
   * This field will be ignored if the cloud-provider does not support the feature.
   * Deprecated: This field was under-specified and its meaning varies across implementations,
   * and it cannot support dual-stack.
   * As of Kubernetes v1.24, users are encouraged to use implementation-specific annotations when available.
   * This field may be removed in a future API version.
   * +optional
   *
   * @generated from field: optional string loadBalancerIP = 8;
   */
  loadBalancerIP: string;

  /**
   * If specified and supported by the platform, this will restrict traffic through the cloud-provider
   * load-balancer will be restricted to the specified client IPs. This field will be ignored if the
   * cloud-provider does not support the feature."
   * More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
   * +optional
   *
   * @generated from field: repeated string loadBalancerSourceRanges = 9;
   */
  loadBalancerSourceRanges: string[];

  /**
   * externalName is the external reference that discovery mechanisms will
   * return as an alias for this service (e.g. a DNS CNAME record). No
   * proxying will be involved.  Must be a lowercase RFC-1123 hostname
   * (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
   * +optional
   *
   * @generated from field: optional string externalName = 10;
   */
  externalName: string;

  /**
   * externalTrafficPolicy denotes if this Service desires to route external
   * traffic to node-local or cluster-wide endpoints. "Local" preserves the
   * client source IP and avoids a second hop for LoadBalancer and Nodeport
   * type services, but risks potentially imbalanced traffic spreading.
   * "Cluster" obscures the client source IP and may cause a second hop to
   * another node, but should have good overall load-spreading.
   * +optional
   *
   * @generated from field: optional string externalTrafficPolicy = 11;
   */
  externalTrafficPolicy: string;

  /**
   * healthCheckNodePort specifies the healthcheck nodePort for the service.
   * This only applies when type is set to LoadBalancer and
   * externalTrafficPolicy is set to Local. If a value is specified, is
   * in-range, and is not in use, it will be used.  If not specified, a value
   * will be automatically allocated.  External systems (e.g. load-balancers)
   * can use this port to determine if a given node holds endpoints for this
   * service or not.  If this field is specified when creating a Service
   * which does not need it, creation will fail. This field will be wiped
   * when updating a Service to no longer need it (e.g. changing type).
   * +optional
   *
   * @generated from field: optional int32 healthCheckNodePort = 12;
   */
  healthCheckNodePort: number;

  /**
   * publishNotReadyAddresses indicates that any agent which deals with endpoints for this
   * Service should disregard any indications of ready/not-ready.
   * The primary use case for setting this field is for a StatefulSet's Headless Service to
   * propagate SRV DNS records for its Pods for the purpose of peer discovery.
   * The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
   * Services interpret this to mean that all endpoints are considered "ready" even if the
   * Pods themselves are not. Agents which consume only Kubernetes generated endpoints
   * through the Endpoints or EndpointSlice resources can safely assume this behavior.
   * +optional
   *
   * @generated from field: optional bool publishNotReadyAddresses = 13;
   */
  publishNotReadyAddresses: boolean;

  /**
   * sessionAffinityConfig contains the configurations of session affinity.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.SessionAffinityConfig sessionAffinityConfig = 14;
   */
  sessionAffinityConfig?: SessionAffinityConfig;

  /**
   * IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
   * service. This field is usually assigned automatically based on cluster
   * configuration and the ipFamilyPolicy field. If this field is specified
   * manually, the requested family is available in the cluster,
   * and ipFamilyPolicy allows it, it will be used; otherwise creation of
   * the service will fail. This field is conditionally mutable: it allows
   * for adding or removing a secondary IP family, but it does not allow
   * changing the primary IP family of the Service. Valid values are "IPv4"
   * and "IPv6".  This field only applies to Services of types ClusterIP,
   * NodePort, and LoadBalancer, and does apply to "headless" services.
   * This field will be wiped when updating a Service to type ExternalName.
   *
   * This field may hold a maximum of two entries (dual-stack families, in
   * either order).  These families must correspond to the values of the
   * clusterIPs field, if specified. Both clusterIPs and ipFamilies are
   * governed by the ipFamilyPolicy field.
   * +listType=atomic
   * +optional
   *
   * @generated from field: repeated string ipFamilies = 19;
   */
  ipFamilies: string[];

  /**
   * IPFamilyPolicy represents the dual-stack-ness requested or required by
   * this Service. If there is no value provided, then this field will be set
   * to SingleStack. Services can be "SingleStack" (a single IP family),
   * "PreferDualStack" (two IP families on dual-stack configured clusters or
   * a single IP family on single-stack clusters), or "RequireDualStack"
   * (two IP families on dual-stack configured clusters, otherwise fail). The
   * ipFamilies and clusterIPs fields depend on the value of this field. This
   * field will be wiped when updating a service to type ExternalName.
   * +optional
   *
   * @generated from field: optional string ipFamilyPolicy = 17;
   */
  ipFamilyPolicy: string;

  /**
   * allocateLoadBalancerNodePorts defines if NodePorts will be automatically
   * allocated for services with type LoadBalancer.  Default is "true". It
   * may be set to "false" if the cluster load-balancer does not rely on
   * NodePorts.  If the caller requests specific NodePorts (by specifying a
   * value), those requests will be respected, regardless of this field.
   * This field may only be set for services with type LoadBalancer and will
   * be cleared if the type is changed to any other type.
   * +optional
   *
   * @generated from field: optional bool allocateLoadBalancerNodePorts = 20;
   */
  allocateLoadBalancerNodePorts: boolean;

  /**
   * loadBalancerClass is the class of the load balancer implementation this Service belongs to.
   * If specified, the value of this field must be a label-style identifier, with an optional prefix,
   * e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
   * This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
   * balancer implementation is used, today this is typically done through the cloud provider integration,
   * but should apply for any default implementation. If set, it is assumed that a load balancer
   * implementation is watching for Services with a matching class. Any default load balancer
   * implementation (e.g. cloud providers) should ignore Services that set this field.
   * This field can only be set when creating or updating a Service to type 'LoadBalancer'.
   * Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
   * +featureGate=LoadBalancerClass
   * +optional
   *
   * @generated from field: optional string loadBalancerClass = 21;
   */
  loadBalancerClass: string;

  /**
   * InternalTrafficPolicy specifies if the cluster internal traffic
   * should be routed to all endpoints or node-local endpoints only.
   * "Cluster" routes internal traffic to a Service to all endpoints.
   * "Local" routes traffic to node-local endpoints only, traffic is
   * dropped if no node-local endpoints are ready.
   * The default value is "Cluster".
   * +featureGate=ServiceInternalTrafficPolicy
   * +optional
   *
   * @generated from field: optional string internalTrafficPolicy = 22;
   */
  internalTrafficPolicy: string;
};

/**
 * ServiceSpec describes the attributes that a user creates on a service.
 *
 * @generated from message k8s.io.api.core.v1.ServiceSpec
 */
export declare type ServiceSpecValid = Message<"k8s.io.api.core.v1.ServiceSpec"> & {
  /**
   * The list of ports that are exposed by this service.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
   * +patchMergeKey=port
   * +patchStrategy=merge
   * +listType=map
   * +listMapKey=port
   * +listMapKey=protocol
   *
   * @generated from field: repeated k8s.io.api.core.v1.ServicePort ports = 1;
   */
  ports: ServicePortValid[];

  /**
   * Route service traffic to pods with label keys and values matching this
   * selector. If empty or not present, the service is assumed to have an
   * external process managing its endpoints, which Kubernetes will not
   * modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
   * Ignored if type is ExternalName.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/
   * +optional
   * +mapType=atomic
   *
   * @generated from field: map<string, string> selector = 2;
   */
  selector: { [key: string]: string };

  /**
   * clusterIP is the IP address of the service and is usually assigned
   * randomly. If an address is specified manually, is in-range (as per
   * system configuration), and is not in use, it will be allocated to the
   * service; otherwise creation of the service will fail. This field may not
   * be changed through updates unless the type field is also being changed
   * to ExternalName (which requires this field to be blank) or the type
   * field is being changed from ExternalName (in which case this field may
   * optionally be specified, as describe above).  Valid values are "None",
   * empty string (""), or a valid IP address. Setting this to "None" makes a
   * "headless service" (no virtual IP), which is useful when direct endpoint
   * connections are preferred and proxying is not required.  Only applies to
   * types ClusterIP, NodePort, and LoadBalancer. If this field is specified
   * when creating a Service of type ExternalName, creation will fail. This
   * field will be wiped when updating a Service to type ExternalName.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
   * +optional
   *
   * @generated from field: optional string clusterIP = 3;
   */
  clusterIP: string;

  /**
   * ClusterIPs is a list of IP addresses assigned to this service, and are
   * usually assigned randomly.  If an address is specified manually, is
   * in-range (as per system configuration), and is not in use, it will be
   * allocated to the service; otherwise creation of the service will fail.
   * This field may not be changed through updates unless the type field is
   * also being changed to ExternalName (which requires this field to be
   * empty) or the type field is being changed from ExternalName (in which
   * case this field may optionally be specified, as describe above).  Valid
   * values are "None", empty string (""), or a valid IP address.  Setting
   * this to "None" makes a "headless service" (no virtual IP), which is
   * useful when direct endpoint connections are preferred and proxying is
   * not required.  Only applies to types ClusterIP, NodePort, and
   * LoadBalancer. If this field is specified when creating a Service of type
   * ExternalName, creation will fail. This field will be wiped when updating
   * a Service to type ExternalName.  If this field is not specified, it will
   * be initialized from the clusterIP field.  If this field is specified,
   * clients must ensure that clusterIPs[0] and clusterIP have the same
   * value.
   *
   * This field may hold a maximum of two entries (dual-stack IPs, in either order).
   * These IPs must correspond to the values of the ipFamilies field. Both
   * clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
   * +listType=atomic
   * +optional
   *
   * @generated from field: repeated string clusterIPs = 18;
   */
  clusterIPs: string[];

  /**
   * type determines how the Service is exposed. Defaults to ClusterIP. Valid
   * options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
   * "ClusterIP" allocates a cluster-internal IP address for load-balancing
   * to endpoints. Endpoints are determined by the selector or if that is not
   * specified, by manual construction of an Endpoints object or
   * EndpointSlice objects. If clusterIP is "None", no virtual IP is
   * allocated and the endpoints are published as a set of endpoints rather
   * than a virtual IP.
   * "NodePort" builds on ClusterIP and allocates a port on every node which
   * routes to the same endpoints as the clusterIP.
   * "LoadBalancer" builds on NodePort and creates an external load-balancer
   * (if supported in the current cloud) which routes to the same endpoints
   * as the clusterIP.
   * "ExternalName" aliases this service to the specified externalName.
   * Several other fields do not apply to ExternalName services.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
   * +optional
   *
   * @generated from field: optional string type = 4;
   */
  type: string;

  /**
   * externalIPs is a list of IP addresses for which nodes in the cluster
   * will also accept traffic for this service.  These IPs are not managed by
   * Kubernetes.  The user is responsible for ensuring that traffic arrives
   * at a node with this IP.  A common example is external load-balancers
   * that are not part of the Kubernetes system.
   * +optional
   *
   * @generated from field: repeated string externalIPs = 5;
   */
  externalIPs: string[];

  /**
   * Supports "ClientIP" and "None". Used to maintain session affinity.
   * Enable client IP based session affinity.
   * Must be ClientIP or None.
   * Defaults to None.
   * More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
   * +optional
   *
   * @generated from field: optional string sessionAffinity = 7;
   */
  sessionAffinity: string;

  /**
   * Only applies to Service Type: LoadBalancer.
   * This feature depends on whether the underlying cloud-provider supports specifying
   * the loadBalancerIP when a load balancer is created.
   * This field will be ignored if the cloud-provider does not support the feature.
   * Deprecated: This field was under-specified and its meaning varies across implementations,
   * and it cannot support dual-stack.
   * As of Kubernetes v1.24, users are encouraged to use implementation-specific annotations when available.
   * This field may be removed in a future API version.
   * +optional
   *
   * @generated from field: optional string loadBalancerIP = 8;
   */
  loadBalancerIP: string;

  /**
   * If specified and supported by the platform, this will restrict traffic through the cloud-provider
   * load-balancer will be restricted to the specified client IPs. This field will be ignored if the
   * cloud-provider does not support the feature."
   * More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
   * +optional
   *
   * @generated from field: repeated string loadBalancerSourceRanges = 9;
   */
  loadBalancerSourceRanges: string[];

  /**
   * externalName is the external reference that discovery mechanisms will
   * return as an alias for this service (e.g. a DNS CNAME record). No
   * proxying will be involved.  Must be a lowercase RFC-1123 hostname
   * (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
   * +optional
   *
   * @generated from field: optional string externalName = 10;
   */
  externalName: string;

  /**
   * externalTrafficPolicy denotes if this Service desires to route external
   * traffic to node-local or cluster-wide endpoints. "Local" preserves the
   * client source IP and avoids a second hop for LoadBalancer and Nodeport
   * type services, but risks potentially imbalanced traffic spreading.
   * "Cluster" obscures the client source IP and may cause a second hop to
   * another node, but should have good overall load-spreading.
   * +optional
   *
   * @generated from field: optional string externalTrafficPolicy = 11;
   */
  externalTrafficPolicy: string;

  /**
   * healthCheckNodePort specifies the healthcheck nodePort for the service.
   * This only applies when type is set to LoadBalancer and
   * externalTrafficPolicy is set to Local. If a value is specified, is
   * in-range, and is not in use, it will be used.  If not specified, a value
   * will be automatically allocated.  External systems (e.g. load-balancers)
   * can use this port to determine if a given node holds endpoints for this
   * service or not.  If this field is specified when creating a Service
   * which does not need it, creation will fail. This field will be wiped
   * when updating a Service to no longer need it (e.g. changing type).
   * +optional
   *
   * @generated from field: optional int32 healthCheckNodePort = 12;
   */
  healthCheckNodePort: number;

  /**
   * publishNotReadyAddresses indicates that any agent which deals with endpoints for this
   * Service should disregard any indications of ready/not-ready.
   * The primary use case for setting this field is for a StatefulSet's Headless Service to
   * propagate SRV DNS records for its Pods for the purpose of peer discovery.
   * The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
   * Services interpret this to mean that all endpoints are considered "ready" even if the
   * Pods themselves are not. Agents which consume only Kubernetes generated endpoints
   * through the Endpoints or EndpointSlice resources can safely assume this behavior.
   * +optional
   *
   * @generated from field: optional bool publishNotReadyAddresses = 13;
   */
  publishNotReadyAddresses: boolean;

  /**
   * sessionAffinityConfig contains the configurations of session affinity.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.SessionAffinityConfig sessionAffinityConfig = 14;
   */
  sessionAffinityConfig?: SessionAffinityConfigValid;

  /**
   * IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
   * service. This field is usually assigned automatically based on cluster
   * configuration and the ipFamilyPolicy field. If this field is specified
   * manually, the requested family is available in the cluster,
   * and ipFamilyPolicy allows it, it will be used; otherwise creation of
   * the service will fail. This field is conditionally mutable: it allows
   * for adding or removing a secondary IP family, but it does not allow
   * changing the primary IP family of the Service. Valid values are "IPv4"
   * and "IPv6".  This field only applies to Services of types ClusterIP,
   * NodePort, and LoadBalancer, and does apply to "headless" services.
   * This field will be wiped when updating a Service to type ExternalName.
   *
   * This field may hold a maximum of two entries (dual-stack families, in
   * either order).  These families must correspond to the values of the
   * clusterIPs field, if specified. Both clusterIPs and ipFamilies are
   * governed by the ipFamilyPolicy field.
   * +listType=atomic
   * +optional
   *
   * @generated from field: repeated string ipFamilies = 19;
   */
  ipFamilies: string[];

  /**
   * IPFamilyPolicy represents the dual-stack-ness requested or required by
   * this Service. If there is no value provided, then this field will be set
   * to SingleStack. Services can be "SingleStack" (a single IP family),
   * "PreferDualStack" (two IP families on dual-stack configured clusters or
   * a single IP family on single-stack clusters), or "RequireDualStack"
   * (two IP families on dual-stack configured clusters, otherwise fail). The
   * ipFamilies and clusterIPs fields depend on the value of this field. This
   * field will be wiped when updating a service to type ExternalName.
   * +optional
   *
   * @generated from field: optional string ipFamilyPolicy = 17;
   */
  ipFamilyPolicy: string;

  /**
   * allocateLoadBalancerNodePorts defines if NodePorts will be automatically
   * allocated for services with type LoadBalancer.  Default is "true". It
   * may be set to "false" if the cluster load-balancer does not rely on
   * NodePorts.  If the caller requests specific NodePorts (by specifying a
   * value), those requests will be respected, regardless of this field.
   * This field may only be set for services with type LoadBalancer and will
   * be cleared if the type is changed to any other type.
   * +optional
   *
   * @generated from field: optional bool allocateLoadBalancerNodePorts = 20;
   */
  allocateLoadBalancerNodePorts: boolean;

  /**
   * loadBalancerClass is the class of the load balancer implementation this Service belongs to.
   * If specified, the value of this field must be a label-style identifier, with an optional prefix,
   * e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
   * This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
   * balancer implementation is used, today this is typically done through the cloud provider integration,
   * but should apply for any default implementation. If set, it is assumed that a load balancer
   * implementation is watching for Services with a matching class. Any default load balancer
   * implementation (e.g. cloud providers) should ignore Services that set this field.
   * This field can only be set when creating or updating a Service to type 'LoadBalancer'.
   * Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
   * +featureGate=LoadBalancerClass
   * +optional
   *
   * @generated from field: optional string loadBalancerClass = 21;
   */
  loadBalancerClass: string;

  /**
   * InternalTrafficPolicy specifies if the cluster internal traffic
   * should be routed to all endpoints or node-local endpoints only.
   * "Cluster" routes internal traffic to a Service to all endpoints.
   * "Local" routes traffic to node-local endpoints only, traffic is
   * dropped if no node-local endpoints are ready.
   * The default value is "Cluster".
   * +featureGate=ServiceInternalTrafficPolicy
   * +optional
   *
   * @generated from field: optional string internalTrafficPolicy = 22;
   */
  internalTrafficPolicy: string;
};

/**
 * Describes the message k8s.io.api.core.v1.ServiceSpec.
 * Use `create(ServiceSpecSchema)` to create a new message.
 */
export declare const ServiceSpecSchema: GenMessage<ServiceSpec, {validType: ServiceSpecValid}>;

/**
 * ServiceStatus represents the current status of a service.
 *
 * @generated from message k8s.io.api.core.v1.ServiceStatus
 */
export declare type ServiceStatus = Message<"k8s.io.api.core.v1.ServiceStatus"> & {
  /**
   * LoadBalancer contains the current status of the load-balancer,
   * if one is present.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.LoadBalancerStatus loadBalancer = 1;
   */
  loadBalancer?: LoadBalancerStatus;

  /**
   * Current service state
   * +optional
   * +patchMergeKey=type
   * +patchStrategy=merge
   * +listType=map
   * +listMapKey=type
   *
   * @generated from field: repeated k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 2;
   */
  conditions: Condition[];
};

/**
 * ServiceStatus represents the current status of a service.
 *
 * @generated from message k8s.io.api.core.v1.ServiceStatus
 */
export declare type ServiceStatusValid = Message<"k8s.io.api.core.v1.ServiceStatus"> & {
  /**
   * LoadBalancer contains the current status of the load-balancer,
   * if one is present.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.LoadBalancerStatus loadBalancer = 1;
   */
  loadBalancer?: LoadBalancerStatusValid;

  /**
   * Current service state
   * +optional
   * +patchMergeKey=type
   * +patchStrategy=merge
   * +listType=map
   * +listMapKey=type
   *
   * @generated from field: repeated k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 2;
   */
  conditions: ConditionValid[];
};

/**
 * Describes the message k8s.io.api.core.v1.ServiceStatus.
 * Use `create(ServiceStatusSchema)` to create a new message.
 */
export declare const ServiceStatusSchema: GenMessage<ServiceStatus, {validType: ServiceStatusValid}>;

/**
 * SessionAffinityConfig represents the configurations of session affinity.
 *
 * @generated from message k8s.io.api.core.v1.SessionAffinityConfig
 */
export declare type SessionAffinityConfig = Message<"k8s.io.api.core.v1.SessionAffinityConfig"> & {
  /**
   * clientIP contains the configurations of Client IP based session affinity.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ClientIPConfig clientIP = 1;
   */
  clientIP?: ClientIPConfig;
};

/**
 * SessionAffinityConfig represents the configurations of session affinity.
 *
 * @generated from message k8s.io.api.core.v1.SessionAffinityConfig
 */
export declare type SessionAffinityConfigValid = Message<"k8s.io.api.core.v1.SessionAffinityConfig"> & {
  /**
   * clientIP contains the configurations of Client IP based session affinity.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ClientIPConfig clientIP = 1;
   */
  clientIP?: ClientIPConfigValid;
};

/**
 * Describes the message k8s.io.api.core.v1.SessionAffinityConfig.
 * Use `create(SessionAffinityConfigSchema)` to create a new message.
 */
export declare const SessionAffinityConfigSchema: GenMessage<SessionAffinityConfig, {validType: SessionAffinityConfigValid}>;

/**
 * Represents a StorageOS persistent volume resource.
 *
 * @generated from message k8s.io.api.core.v1.StorageOSPersistentVolumeSource
 */
export declare type StorageOSPersistentVolumeSource = Message<"k8s.io.api.core.v1.StorageOSPersistentVolumeSource"> & {
  /**
   * volumeName is the human-readable name of the StorageOS volume.  Volume
   * names are only unique within a namespace.
   *
   * @generated from field: optional string volumeName = 1;
   */
  volumeName: string;

  /**
   * volumeNamespace specifies the scope of the volume within StorageOS.  If no
   * namespace is specified then the Pod's namespace will be used.  This allows the
   * Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
   * Set VolumeName to any name to override the default behaviour.
   * Set to "default" if you are not using namespaces within StorageOS.
   * Namespaces that do not pre-exist within StorageOS will be created.
   * +optional
   *
   * @generated from field: optional string volumeNamespace = 2;
   */
  volumeNamespace: string;

  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * +optional
   *
   * @generated from field: optional string fsType = 3;
   */
  fsType: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * +optional
   *
   * @generated from field: optional bool readOnly = 4;
   */
  readOnly: boolean;

  /**
   * secretRef specifies the secret to use for obtaining the StorageOS API
   * credentials.  If not specified, default values will be attempted.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ObjectReference secretRef = 5;
   */
  secretRef?: ObjectReference;
};

/**
 * Represents a StorageOS persistent volume resource.
 *
 * @generated from message k8s.io.api.core.v1.StorageOSPersistentVolumeSource
 */
export declare type StorageOSPersistentVolumeSourceValid = Message<"k8s.io.api.core.v1.StorageOSPersistentVolumeSource"> & {
  /**
   * volumeName is the human-readable name of the StorageOS volume.  Volume
   * names are only unique within a namespace.
   *
   * @generated from field: optional string volumeName = 1;
   */
  volumeName: string;

  /**
   * volumeNamespace specifies the scope of the volume within StorageOS.  If no
   * namespace is specified then the Pod's namespace will be used.  This allows the
   * Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
   * Set VolumeName to any name to override the default behaviour.
   * Set to "default" if you are not using namespaces within StorageOS.
   * Namespaces that do not pre-exist within StorageOS will be created.
   * +optional
   *
   * @generated from field: optional string volumeNamespace = 2;
   */
  volumeNamespace: string;

  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * +optional
   *
   * @generated from field: optional string fsType = 3;
   */
  fsType: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * +optional
   *
   * @generated from field: optional bool readOnly = 4;
   */
  readOnly: boolean;

  /**
   * secretRef specifies the secret to use for obtaining the StorageOS API
   * credentials.  If not specified, default values will be attempted.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ObjectReference secretRef = 5;
   */
  secretRef?: ObjectReferenceValid;
};

/**
 * Describes the message k8s.io.api.core.v1.StorageOSPersistentVolumeSource.
 * Use `create(StorageOSPersistentVolumeSourceSchema)` to create a new message.
 */
export declare const StorageOSPersistentVolumeSourceSchema: GenMessage<StorageOSPersistentVolumeSource, {validType: StorageOSPersistentVolumeSourceValid}>;

/**
 * Represents a StorageOS persistent volume resource.
 *
 * @generated from message k8s.io.api.core.v1.StorageOSVolumeSource
 */
export declare type StorageOSVolumeSource = Message<"k8s.io.api.core.v1.StorageOSVolumeSource"> & {
  /**
   * volumeName is the human-readable name of the StorageOS volume.  Volume
   * names are only unique within a namespace.
   *
   * @generated from field: optional string volumeName = 1;
   */
  volumeName: string;

  /**
   * volumeNamespace specifies the scope of the volume within StorageOS.  If no
   * namespace is specified then the Pod's namespace will be used.  This allows the
   * Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
   * Set VolumeName to any name to override the default behaviour.
   * Set to "default" if you are not using namespaces within StorageOS.
   * Namespaces that do not pre-exist within StorageOS will be created.
   * +optional
   *
   * @generated from field: optional string volumeNamespace = 2;
   */
  volumeNamespace: string;

  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * +optional
   *
   * @generated from field: optional string fsType = 3;
   */
  fsType: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * +optional
   *
   * @generated from field: optional bool readOnly = 4;
   */
  readOnly: boolean;

  /**
   * secretRef specifies the secret to use for obtaining the StorageOS API
   * credentials.  If not specified, default values will be attempted.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.LocalObjectReference secretRef = 5;
   */
  secretRef?: LocalObjectReference;
};

/**
 * Represents a StorageOS persistent volume resource.
 *
 * @generated from message k8s.io.api.core.v1.StorageOSVolumeSource
 */
export declare type StorageOSVolumeSourceValid = Message<"k8s.io.api.core.v1.StorageOSVolumeSource"> & {
  /**
   * volumeName is the human-readable name of the StorageOS volume.  Volume
   * names are only unique within a namespace.
   *
   * @generated from field: optional string volumeName = 1;
   */
  volumeName: string;

  /**
   * volumeNamespace specifies the scope of the volume within StorageOS.  If no
   * namespace is specified then the Pod's namespace will be used.  This allows the
   * Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
   * Set VolumeName to any name to override the default behaviour.
   * Set to "default" if you are not using namespaces within StorageOS.
   * Namespaces that do not pre-exist within StorageOS will be created.
   * +optional
   *
   * @generated from field: optional string volumeNamespace = 2;
   */
  volumeNamespace: string;

  /**
   * fsType is the filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * +optional
   *
   * @generated from field: optional string fsType = 3;
   */
  fsType: string;

  /**
   * readOnly defaults to false (read/write). ReadOnly here will force
   * the ReadOnly setting in VolumeMounts.
   * +optional
   *
   * @generated from field: optional bool readOnly = 4;
   */
  readOnly: boolean;

  /**
   * secretRef specifies the secret to use for obtaining the StorageOS API
   * credentials.  If not specified, default values will be attempted.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.LocalObjectReference secretRef = 5;
   */
  secretRef?: LocalObjectReferenceValid;
};

/**
 * Describes the message k8s.io.api.core.v1.StorageOSVolumeSource.
 * Use `create(StorageOSVolumeSourceSchema)` to create a new message.
 */
export declare const StorageOSVolumeSourceSchema: GenMessage<StorageOSVolumeSource, {validType: StorageOSVolumeSourceValid}>;

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @generated from message k8s.io.api.core.v1.Sysctl
 */
export declare type Sysctl = Message<"k8s.io.api.core.v1.Sysctl"> & {
  /**
   * Name of a property to set
   *
   * @generated from field: optional string name = 1;
   */
  name: string;

  /**
   * Value of a property to set
   *
   * @generated from field: optional string value = 2;
   */
  value: string;
};

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @generated from message k8s.io.api.core.v1.Sysctl
 */
export declare type SysctlValid = Message<"k8s.io.api.core.v1.Sysctl"> & {
  /**
   * Name of a property to set
   *
   * @generated from field: optional string name = 1;
   */
  name: string;

  /**
   * Value of a property to set
   *
   * @generated from field: optional string value = 2;
   */
  value: string;
};

/**
 * Describes the message k8s.io.api.core.v1.Sysctl.
 * Use `create(SysctlSchema)` to create a new message.
 */
export declare const SysctlSchema: GenMessage<Sysctl, {validType: SysctlValid}>;

/**
 * TCPSocketAction describes an action based on opening a socket
 *
 * @generated from message k8s.io.api.core.v1.TCPSocketAction
 */
export declare type TCPSocketAction = Message<"k8s.io.api.core.v1.TCPSocketAction"> & {
  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 1;
   */
  port?: IntOrString;

  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   * +optional
   *
   * @generated from field: optional string host = 2;
   */
  host: string;
};

/**
 * TCPSocketAction describes an action based on opening a socket
 *
 * @generated from message k8s.io.api.core.v1.TCPSocketAction
 */
export declare type TCPSocketActionValid = Message<"k8s.io.api.core.v1.TCPSocketAction"> & {
  /**
   * Number or name of the port to access on the container.
   * Number must be in the range 1 to 65535.
   * Name must be an IANA_SVC_NAME.
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 1;
   */
  port?: IntOrStringValid;

  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   * +optional
   *
   * @generated from field: optional string host = 2;
   */
  host: string;
};

/**
 * Describes the message k8s.io.api.core.v1.TCPSocketAction.
 * Use `create(TCPSocketActionSchema)` to create a new message.
 */
export declare const TCPSocketActionSchema: GenMessage<TCPSocketAction, {validType: TCPSocketActionValid}>;

/**
 * The node this Taint is attached to has the "effect" on
 * any pod that does not tolerate the Taint.
 *
 * @generated from message k8s.io.api.core.v1.Taint
 */
export declare type Taint = Message<"k8s.io.api.core.v1.Taint"> & {
  /**
   * Required. The taint key to be applied to a node.
   *
   * @generated from field: optional string key = 1;
   */
  key: string;

  /**
   * The taint value corresponding to the taint key.
   * +optional
   *
   * @generated from field: optional string value = 2;
   */
  value: string;

  /**
   * Required. The effect of the taint on pods
   * that do not tolerate the taint.
   * Valid effects are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @generated from field: optional string effect = 3;
   */
  effect: string;

  /**
   * TimeAdded represents the time at which the taint was added.
   * It is only written for NoExecute taints.
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time timeAdded = 4;
   */
  timeAdded?: Time;
};

/**
 * The node this Taint is attached to has the "effect" on
 * any pod that does not tolerate the Taint.
 *
 * @generated from message k8s.io.api.core.v1.Taint
 */
export declare type TaintValid = Message<"k8s.io.api.core.v1.Taint"> & {
  /**
   * Required. The taint key to be applied to a node.
   *
   * @generated from field: optional string key = 1;
   */
  key: string;

  /**
   * The taint value corresponding to the taint key.
   * +optional
   *
   * @generated from field: optional string value = 2;
   */
  value: string;

  /**
   * Required. The effect of the taint on pods
   * that do not tolerate the taint.
   * Valid effects are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @generated from field: optional string effect = 3;
   */
  effect: string;

  /**
   * TimeAdded represents the time at which the taint was added.
   * It is only written for NoExecute taints.
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.Time timeAdded = 4;
   */
  timeAdded?: TimeValid;
};

/**
 * Describes the message k8s.io.api.core.v1.Taint.
 * Use `create(TaintSchema)` to create a new message.
 */
export declare const TaintSchema: GenMessage<Taint, {validType: TaintValid}>;

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @generated from message k8s.io.api.core.v1.Toleration
 */
export declare type Toleration = Message<"k8s.io.api.core.v1.Toleration"> & {
  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   * +optional
   *
   * @generated from field: optional string key = 1;
   */
  key: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   * +optional
   *
   * @generated from field: optional string operator = 2;
   */
  operator: string;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   * +optional
   *
   * @generated from field: optional string value = 3;
   */
  value: string;

  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   * +optional
   *
   * @generated from field: optional string effect = 4;
   */
  effect: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   * +optional
   *
   * @generated from field: optional int64 tolerationSeconds = 5;
   */
  tolerationSeconds: bigint;
};

/**
 * The pod this Toleration is attached to tolerates any taint that matches
 * the triple <key,value,effect> using the matching operator <operator>.
 *
 * @generated from message k8s.io.api.core.v1.Toleration
 */
export declare type TolerationValid = Message<"k8s.io.api.core.v1.Toleration"> & {
  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys.
   * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   * +optional
   *
   * @generated from field: optional string key = 1;
   */
  key: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   * Exists is equivalent to wildcard for value, so that a pod can
   * tolerate all taints of a particular category.
   * +optional
   *
   * @generated from field: optional string operator = 2;
   */
  operator: string;

  /**
   * Value is the taint value the toleration matches to.
   * If the operator is Exists, the value should be empty, otherwise just a regular string.
   * +optional
   *
   * @generated from field: optional string value = 3;
   */
  value: string;

  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects.
   * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   * +optional
   *
   * @generated from field: optional string effect = 4;
   */
  effect: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be
   * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
   * it is not set, which means tolerate the taint forever (do not evict). Zero and
   * negative values will be treated as 0 (evict immediately) by the system.
   * +optional
   *
   * @generated from field: optional int64 tolerationSeconds = 5;
   */
  tolerationSeconds: bigint;
};

/**
 * Describes the message k8s.io.api.core.v1.Toleration.
 * Use `create(TolerationSchema)` to create a new message.
 */
export declare const TolerationSchema: GenMessage<Toleration, {validType: TolerationValid}>;

/**
 * A topology selector requirement is a selector that matches given label.
 * This is an alpha feature and may change in the future.
 *
 * @generated from message k8s.io.api.core.v1.TopologySelectorLabelRequirement
 */
export declare type TopologySelectorLabelRequirement = Message<"k8s.io.api.core.v1.TopologySelectorLabelRequirement"> & {
  /**
   * The label key that the selector applies to.
   *
   * @generated from field: optional string key = 1;
   */
  key: string;

  /**
   * An array of string values. One value must match the label to be selected.
   * Each entry in Values is ORed.
   *
   * @generated from field: repeated string values = 2;
   */
  values: string[];
};

/**
 * A topology selector requirement is a selector that matches given label.
 * This is an alpha feature and may change in the future.
 *
 * @generated from message k8s.io.api.core.v1.TopologySelectorLabelRequirement
 */
export declare type TopologySelectorLabelRequirementValid = Message<"k8s.io.api.core.v1.TopologySelectorLabelRequirement"> & {
  /**
   * The label key that the selector applies to.
   *
   * @generated from field: optional string key = 1;
   */
  key: string;

  /**
   * An array of string values. One value must match the label to be selected.
   * Each entry in Values is ORed.
   *
   * @generated from field: repeated string values = 2;
   */
  values: string[];
};

/**
 * Describes the message k8s.io.api.core.v1.TopologySelectorLabelRequirement.
 * Use `create(TopologySelectorLabelRequirementSchema)` to create a new message.
 */
export declare const TopologySelectorLabelRequirementSchema: GenMessage<TopologySelectorLabelRequirement, {validType: TopologySelectorLabelRequirementValid}>;

/**
 * A topology selector term represents the result of label queries.
 * A null or empty topology selector term matches no objects.
 * The requirements of them are ANDed.
 * It provides a subset of functionality as NodeSelectorTerm.
 * This is an alpha feature and may change in the future.
 * +structType=atomic
 *
 * @generated from message k8s.io.api.core.v1.TopologySelectorTerm
 */
export declare type TopologySelectorTerm = Message<"k8s.io.api.core.v1.TopologySelectorTerm"> & {
  /**
   * A list of topology selector requirements by labels.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.TopologySelectorLabelRequirement matchLabelExpressions = 1;
   */
  matchLabelExpressions: TopologySelectorLabelRequirement[];
};

/**
 * A topology selector term represents the result of label queries.
 * A null or empty topology selector term matches no objects.
 * The requirements of them are ANDed.
 * It provides a subset of functionality as NodeSelectorTerm.
 * This is an alpha feature and may change in the future.
 * +structType=atomic
 *
 * @generated from message k8s.io.api.core.v1.TopologySelectorTerm
 */
export declare type TopologySelectorTermValid = Message<"k8s.io.api.core.v1.TopologySelectorTerm"> & {
  /**
   * A list of topology selector requirements by labels.
   * +optional
   *
   * @generated from field: repeated k8s.io.api.core.v1.TopologySelectorLabelRequirement matchLabelExpressions = 1;
   */
  matchLabelExpressions: TopologySelectorLabelRequirementValid[];
};

/**
 * Describes the message k8s.io.api.core.v1.TopologySelectorTerm.
 * Use `create(TopologySelectorTermSchema)` to create a new message.
 */
export declare const TopologySelectorTermSchema: GenMessage<TopologySelectorTerm, {validType: TopologySelectorTermValid}>;

/**
 * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
 *
 * @generated from message k8s.io.api.core.v1.TopologySpreadConstraint
 */
export declare type TopologySpreadConstraint = Message<"k8s.io.api.core.v1.TopologySpreadConstraint"> & {
  /**
   * MaxSkew describes the degree to which pods may be unevenly distributed.
   * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
   * between the number of matching pods in the target topology and the global minimum.
   * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
   * labelSelector spread as 1/1/0:
   * +-------+-------+-------+
   * | zone1 | zone2 | zone3 |
   * +-------+-------+-------+
   * |   P   |   P   |       |
   * +-------+-------+-------+
   * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 1/1/1;
   * scheduling it onto zone1(zone2) would make the ActualSkew(2-0) on zone1(zone2)
   * violate MaxSkew(1).
   * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
   * When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
   * to topologies that satisfy it.
   * It's a required field. Default value is 1 and 0 is not allowed.
   *
   * @generated from field: optional int32 maxSkew = 1;
   */
  maxSkew: number;

  /**
   * TopologyKey is the key of node labels. Nodes that have a label with this key
   * and identical values are considered to be in the same topology.
   * We consider each <key, value> as a "bucket", and try to put balanced number
   * of pods into each bucket.
   * It's a required field.
   *
   * @generated from field: optional string topologyKey = 2;
   */
  topologyKey: string;

  /**
   * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
   * the spread constraint.
   * - DoNotSchedule (default) tells the scheduler not to schedule it.
   * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
   *   but giving higher precedence to topologies that would help reduce the
   *   skew.
   * A constraint is considered "Unsatisfiable" for an incoming pod
   * if and only if every possible node assignment for that pod would violate
   * "MaxSkew" on some topology.
   * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
   * labelSelector spread as 3/1/1:
   * +-------+-------+-------+
   * | zone1 | zone2 | zone3 |
   * +-------+-------+-------+
   * | P P P |   P   |   P   |
   * +-------+-------+-------+
   * If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
   * to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
   * MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
   * won't make it *more* imbalanced.
   * It's a required field.
   *
   * @generated from field: optional string whenUnsatisfiable = 3;
   */
  whenUnsatisfiable: string;

  /**
   * LabelSelector is used to find matching pods.
   * Pods that match this label selector are counted to determine the number of pods
   * in their corresponding topology domain.
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector labelSelector = 4;
   */
  labelSelector?: LabelSelector;
};

/**
 * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
 *
 * @generated from message k8s.io.api.core.v1.TopologySpreadConstraint
 */
export declare type TopologySpreadConstraintValid = Message<"k8s.io.api.core.v1.TopologySpreadConstraint"> & {
  /**
   * MaxSkew describes the degree to which pods may be unevenly distributed.
   * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
   * between the number of matching pods in the target topology and the global minimum.
   * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
   * labelSelector spread as 1/1/0:
   * +-------+-------+-------+
   * | zone1 | zone2 | zone3 |
   * +-------+-------+-------+
   * |   P   |   P   |       |
   * +-------+-------+-------+
   * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 1/1/1;
   * scheduling it onto zone1(zone2) would make the ActualSkew(2-0) on zone1(zone2)
   * violate MaxSkew(1).
   * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
   * When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
   * to topologies that satisfy it.
   * It's a required field. Default value is 1 and 0 is not allowed.
   *
   * @generated from field: optional int32 maxSkew = 1;
   */
  maxSkew: number;

  /**
   * TopologyKey is the key of node labels. Nodes that have a label with this key
   * and identical values are considered to be in the same topology.
   * We consider each <key, value> as a "bucket", and try to put balanced number
   * of pods into each bucket.
   * It's a required field.
   *
   * @generated from field: optional string topologyKey = 2;
   */
  topologyKey: string;

  /**
   * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
   * the spread constraint.
   * - DoNotSchedule (default) tells the scheduler not to schedule it.
   * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
   *   but giving higher precedence to topologies that would help reduce the
   *   skew.
   * A constraint is considered "Unsatisfiable" for an incoming pod
   * if and only if every possible node assignment for that pod would violate
   * "MaxSkew" on some topology.
   * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
   * labelSelector spread as 3/1/1:
   * +-------+-------+-------+
   * | zone1 | zone2 | zone3 |
   * +-------+-------+-------+
   * | P P P |   P   |   P   |
   * +-------+-------+-------+
   * If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
   * to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
   * MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
   * won't make it *more* imbalanced.
   * It's a required field.
   *
   * @generated from field: optional string whenUnsatisfiable = 3;
   */
  whenUnsatisfiable: string;

  /**
   * LabelSelector is used to find matching pods.
   * Pods that match this label selector are counted to determine the number of pods
   * in their corresponding topology domain.
   * +optional
   *
   * @generated from field: optional k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector labelSelector = 4;
   */
  labelSelector?: LabelSelectorValid;
};

/**
 * Describes the message k8s.io.api.core.v1.TopologySpreadConstraint.
 * Use `create(TopologySpreadConstraintSchema)` to create a new message.
 */
export declare const TopologySpreadConstraintSchema: GenMessage<TopologySpreadConstraint, {validType: TopologySpreadConstraintValid}>;

/**
 * TypedLocalObjectReference contains enough information to let you locate the
 * typed referenced object inside the same namespace.
 * +structType=atomic
 *
 * @generated from message k8s.io.api.core.v1.TypedLocalObjectReference
 */
export declare type TypedLocalObjectReference = Message<"k8s.io.api.core.v1.TypedLocalObjectReference"> & {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   * +optional
   *
   * @generated from field: optional string apiGroup = 1;
   */
  apiGroup: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @generated from field: optional string kind = 2;
   */
  kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @generated from field: optional string name = 3;
   */
  name: string;
};

/**
 * TypedLocalObjectReference contains enough information to let you locate the
 * typed referenced object inside the same namespace.
 * +structType=atomic
 *
 * @generated from message k8s.io.api.core.v1.TypedLocalObjectReference
 */
export declare type TypedLocalObjectReferenceValid = Message<"k8s.io.api.core.v1.TypedLocalObjectReference"> & {
  /**
   * APIGroup is the group for the resource being referenced.
   * If APIGroup is not specified, the specified Kind must be in the core API group.
   * For any other third-party types, APIGroup is required.
   * +optional
   *
   * @generated from field: optional string apiGroup = 1;
   */
  apiGroup: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @generated from field: optional string kind = 2;
   */
  kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @generated from field: optional string name = 3;
   */
  name: string;
};

/**
 * Describes the message k8s.io.api.core.v1.TypedLocalObjectReference.
 * Use `create(TypedLocalObjectReferenceSchema)` to create a new message.
 */
export declare const TypedLocalObjectReferenceSchema: GenMessage<TypedLocalObjectReference, {validType: TypedLocalObjectReferenceValid}>;

/**
 * Volume represents a named volume in a pod that may be accessed by any container in the pod.
 *
 * @generated from message k8s.io.api.core.v1.Volume
 */
export declare type Volume = Message<"k8s.io.api.core.v1.Volume"> & {
  /**
   * name of the volume.
   * Must be a DNS_LABEL and unique within the pod.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @generated from field: optional string name = 1;
   */
  name: string;

  /**
   * volumeSource represents the location and type of the mounted volume.
   * If not specified, the Volume is implied to be an EmptyDir.
   * This implied behavior is deprecated and will be removed in a future version.
   *
   * @generated from field: optional k8s.io.api.core.v1.VolumeSource volumeSource = 2;
   */
  volumeSource?: VolumeSource;
};

/**
 * Volume represents a named volume in a pod that may be accessed by any container in the pod.
 *
 * @generated from message k8s.io.api.core.v1.Volume
 */
export declare type VolumeValid = Message<"k8s.io.api.core.v1.Volume"> & {
  /**
   * name of the volume.
   * Must be a DNS_LABEL and unique within the pod.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @generated from field: optional string name = 1;
   */
  name: string;

  /**
   * volumeSource represents the location and type of the mounted volume.
   * If not specified, the Volume is implied to be an EmptyDir.
   * This implied behavior is deprecated and will be removed in a future version.
   *
   * @generated from field: optional k8s.io.api.core.v1.VolumeSource volumeSource = 2;
   */
  volumeSource?: VolumeSourceValid;
};

/**
 * Describes the message k8s.io.api.core.v1.Volume.
 * Use `create(VolumeSchema)` to create a new message.
 */
export declare const VolumeSchema: GenMessage<Volume, {validType: VolumeValid}>;

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @generated from message k8s.io.api.core.v1.VolumeDevice
 */
export declare type VolumeDevice = Message<"k8s.io.api.core.v1.VolumeDevice"> & {
  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @generated from field: optional string name = 1;
   */
  name: string;

  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @generated from field: optional string devicePath = 2;
   */
  devicePath: string;
};

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @generated from message k8s.io.api.core.v1.VolumeDevice
 */
export declare type VolumeDeviceValid = Message<"k8s.io.api.core.v1.VolumeDevice"> & {
  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @generated from field: optional string name = 1;
   */
  name: string;

  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @generated from field: optional string devicePath = 2;
   */
  devicePath: string;
};

/**
 * Describes the message k8s.io.api.core.v1.VolumeDevice.
 * Use `create(VolumeDeviceSchema)` to create a new message.
 */
export declare const VolumeDeviceSchema: GenMessage<VolumeDevice, {validType: VolumeDeviceValid}>;

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @generated from message k8s.io.api.core.v1.VolumeMount
 */
export declare type VolumeMount = Message<"k8s.io.api.core.v1.VolumeMount"> & {
  /**
   * This must match the Name of a Volume.
   *
   * @generated from field: optional string name = 1;
   */
  name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   * +optional
   *
   * @generated from field: optional bool readOnly = 2;
   */
  readOnly: boolean;

  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @generated from field: optional string mountPath = 3;
   */
  mountPath: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   * +optional
   *
   * @generated from field: optional string subPath = 4;
   */
  subPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * +optional
   *
   * @generated from field: optional string mountPropagation = 5;
   */
  mountPropagation: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   * +optional
   *
   * @generated from field: optional string subPathExpr = 6;
   */
  subPathExpr: string;
};

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @generated from message k8s.io.api.core.v1.VolumeMount
 */
export declare type VolumeMountValid = Message<"k8s.io.api.core.v1.VolumeMount"> & {
  /**
   * This must match the Name of a Volume.
   *
   * @generated from field: optional string name = 1;
   */
  name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified).
   * Defaults to false.
   * +optional
   *
   * @generated from field: optional bool readOnly = 2;
   */
  readOnly: boolean;

  /**
   * Path within the container at which the volume should be mounted.  Must
   * not contain ':'.
   *
   * @generated from field: optional string mountPath = 3;
   */
  mountPath: string;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   * +optional
   *
   * @generated from field: optional string subPath = 4;
   */
  subPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host
   * to container and the other way around.
   * When not set, MountPropagationNone is used.
   * This field is beta in 1.10.
   * +optional
   *
   * @generated from field: optional string mountPropagation = 5;
   */
  mountPropagation: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted.
   * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
   * Defaults to "" (volume's root).
   * SubPathExpr and SubPath are mutually exclusive.
   * +optional
   *
   * @generated from field: optional string subPathExpr = 6;
   */
  subPathExpr: string;
};

/**
 * Describes the message k8s.io.api.core.v1.VolumeMount.
 * Use `create(VolumeMountSchema)` to create a new message.
 */
export declare const VolumeMountSchema: GenMessage<VolumeMount, {validType: VolumeMountValid}>;

/**
 * VolumeNodeAffinity defines constraints that limit what nodes this volume can be accessed from.
 *
 * @generated from message k8s.io.api.core.v1.VolumeNodeAffinity
 */
export declare type VolumeNodeAffinity = Message<"k8s.io.api.core.v1.VolumeNodeAffinity"> & {
  /**
   * required specifies hard node constraints that must be met.
   *
   * @generated from field: optional k8s.io.api.core.v1.NodeSelector required = 1;
   */
  required?: NodeSelector;
};

/**
 * VolumeNodeAffinity defines constraints that limit what nodes this volume can be accessed from.
 *
 * @generated from message k8s.io.api.core.v1.VolumeNodeAffinity
 */
export declare type VolumeNodeAffinityValid = Message<"k8s.io.api.core.v1.VolumeNodeAffinity"> & {
  /**
   * required specifies hard node constraints that must be met.
   *
   * @generated from field: optional k8s.io.api.core.v1.NodeSelector required = 1;
   */
  required?: NodeSelectorValid;
};

/**
 * Describes the message k8s.io.api.core.v1.VolumeNodeAffinity.
 * Use `create(VolumeNodeAffinitySchema)` to create a new message.
 */
export declare const VolumeNodeAffinitySchema: GenMessage<VolumeNodeAffinity, {validType: VolumeNodeAffinityValid}>;

/**
 * Projection that may be projected along with other supported volume types
 *
 * @generated from message k8s.io.api.core.v1.VolumeProjection
 */
export declare type VolumeProjection = Message<"k8s.io.api.core.v1.VolumeProjection"> & {
  /**
   * secret information about the secret data to project
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.SecretProjection secret = 1;
   */
  secret?: SecretProjection;

  /**
   * downwardAPI information about the downwardAPI data to project
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.DownwardAPIProjection downwardAPI = 2;
   */
  downwardAPI?: DownwardAPIProjection;

  /**
   * configMap information about the configMap data to project
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ConfigMapProjection configMap = 3;
   */
  configMap?: ConfigMapProjection;

  /**
   * serviceAccountToken is information about the serviceAccountToken data to project
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ServiceAccountTokenProjection serviceAccountToken = 4;
   */
  serviceAccountToken?: ServiceAccountTokenProjection;
};

/**
 * Projection that may be projected along with other supported volume types
 *
 * @generated from message k8s.io.api.core.v1.VolumeProjection
 */
export declare type VolumeProjectionValid = Message<"k8s.io.api.core.v1.VolumeProjection"> & {
  /**
   * secret information about the secret data to project
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.SecretProjection secret = 1;
   */
  secret?: SecretProjectionValid;

  /**
   * downwardAPI information about the downwardAPI data to project
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.DownwardAPIProjection downwardAPI = 2;
   */
  downwardAPI?: DownwardAPIProjectionValid;

  /**
   * configMap information about the configMap data to project
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ConfigMapProjection configMap = 3;
   */
  configMap?: ConfigMapProjectionValid;

  /**
   * serviceAccountToken is information about the serviceAccountToken data to project
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ServiceAccountTokenProjection serviceAccountToken = 4;
   */
  serviceAccountToken?: ServiceAccountTokenProjectionValid;
};

/**
 * Describes the message k8s.io.api.core.v1.VolumeProjection.
 * Use `create(VolumeProjectionSchema)` to create a new message.
 */
export declare const VolumeProjectionSchema: GenMessage<VolumeProjection, {validType: VolumeProjectionValid}>;

/**
 * Represents the source of a volume to mount.
 * Only one of its members may be specified.
 *
 * @generated from message k8s.io.api.core.v1.VolumeSource
 */
export declare type VolumeSource = Message<"k8s.io.api.core.v1.VolumeSource"> & {
  /**
   * hostPath represents a pre-existing file or directory on the host
   * machine that is directly exposed to the container. This is generally
   * used for system agents or other privileged things that are allowed
   * to see the host machine. Most containers will NOT need this.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * ---
   * TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not
   * mount host directories as read/write.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.HostPathVolumeSource hostPath = 1;
   */
  hostPath?: HostPathVolumeSource;

  /**
   * emptyDir represents a temporary directory that shares a pod's lifetime.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.EmptyDirVolumeSource emptyDir = 2;
   */
  emptyDir?: EmptyDirVolumeSource;

  /**
   * gcePersistentDisk represents a GCE Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.GCEPersistentDiskVolumeSource gcePersistentDisk = 3;
   */
  gcePersistentDisk?: GCEPersistentDiskVolumeSource;

  /**
   * awsElasticBlockStore represents an AWS Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.AWSElasticBlockStoreVolumeSource awsElasticBlockStore = 4;
   */
  awsElasticBlockStore?: AWSElasticBlockStoreVolumeSource;

  /**
   * gitRepo represents a git repository at a particular revision.
   * DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
   * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
   * into the Pod's container.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.GitRepoVolumeSource gitRepo = 5;
   */
  gitRepo?: GitRepoVolumeSource;

  /**
   * secret represents a secret that should populate this volume.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.SecretVolumeSource secret = 6;
   */
  secret?: SecretVolumeSource;

  /**
   * nfs represents an NFS mount on the host that shares a pod's lifetime
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.NFSVolumeSource nfs = 7;
   */
  nfs?: NFSVolumeSource;

  /**
   * iscsi represents an ISCSI Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://examples.k8s.io/volumes/iscsi/README.md
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ISCSIVolumeSource iscsi = 8;
   */
  iscsi?: ISCSIVolumeSource;

  /**
   * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.GlusterfsVolumeSource glusterfs = 9;
   */
  glusterfs?: GlusterfsVolumeSource;

  /**
   * persistentVolumeClaimVolumeSource represents a reference to a
   * PersistentVolumeClaim in the same namespace.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.PersistentVolumeClaimVolumeSource persistentVolumeClaim = 10;
   */
  persistentVolumeClaim?: PersistentVolumeClaimVolumeSource;

  /**
   * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
   * More info: https://examples.k8s.io/volumes/rbd/README.md
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.RBDVolumeSource rbd = 11;
   */
  rbd?: RBDVolumeSource;

  /**
   * flexVolume represents a generic volume resource that is
   * provisioned/attached using an exec based plugin.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.FlexVolumeSource flexVolume = 12;
   */
  flexVolume?: FlexVolumeSource;

  /**
   * cinder represents a cinder volume attached and mounted on kubelets host machine.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.CinderVolumeSource cinder = 13;
   */
  cinder?: CinderVolumeSource;

  /**
   * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.CephFSVolumeSource cephfs = 14;
   */
  cephfs?: CephFSVolumeSource;

  /**
   * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.FlockerVolumeSource flocker = 15;
   */
  flocker?: FlockerVolumeSource;

  /**
   * downwardAPI represents downward API about the pod that should populate this volume
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.DownwardAPIVolumeSource downwardAPI = 16;
   */
  downwardAPI?: DownwardAPIVolumeSource;

  /**
   * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.FCVolumeSource fc = 17;
   */
  fc?: FCVolumeSource;

  /**
   * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.AzureFileVolumeSource azureFile = 18;
   */
  azureFile?: AzureFileVolumeSource;

  /**
   * configMap represents a configMap that should populate this volume
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ConfigMapVolumeSource configMap = 19;
   */
  configMap?: ConfigMapVolumeSource;

  /**
   * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.VsphereVirtualDiskVolumeSource vsphereVolume = 20;
   */
  vsphereVolume?: VsphereVirtualDiskVolumeSource;

  /**
   * quobyte represents a Quobyte mount on the host that shares a pod's lifetime
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.QuobyteVolumeSource quobyte = 21;
   */
  quobyte?: QuobyteVolumeSource;

  /**
   * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.AzureDiskVolumeSource azureDisk = 22;
   */
  azureDisk?: AzureDiskVolumeSource;

  /**
   * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
   *
   * @generated from field: optional k8s.io.api.core.v1.PhotonPersistentDiskVolumeSource photonPersistentDisk = 23;
   */
  photonPersistentDisk?: PhotonPersistentDiskVolumeSource;

  /**
   * projected items for all in one resources secrets, configmaps, and downward API
   *
   * @generated from field: optional k8s.io.api.core.v1.ProjectedVolumeSource projected = 26;
   */
  projected?: ProjectedVolumeSource;

  /**
   * portworxVolume represents a portworx volume attached and mounted on kubelets host machine
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.PortworxVolumeSource portworxVolume = 24;
   */
  portworxVolume?: PortworxVolumeSource;

  /**
   * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ScaleIOVolumeSource scaleIO = 25;
   */
  scaleIO?: ScaleIOVolumeSource;

  /**
   * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.StorageOSVolumeSource storageos = 27;
   */
  storageos?: StorageOSVolumeSource;

  /**
   * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.CSIVolumeSource csi = 28;
   */
  csi?: CSIVolumeSource;

  /**
   * ephemeral represents a volume that is handled by a cluster storage driver.
   * The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
   * and deleted when the pod is removed.
   *
   * Use this if:
   * a) the volume is only needed while the pod runs,
   * b) features of normal volumes like restoring from snapshot or capacity
   *    tracking are needed,
   * c) the storage driver is specified through a storage class, and
   * d) the storage driver supports dynamic volume provisioning through
   *    a PersistentVolumeClaim (see EphemeralVolumeSource for more
   *    information on the connection between this volume type
   *    and PersistentVolumeClaim).
   *
   * Use PersistentVolumeClaim or one of the vendor-specific
   * APIs for volumes that persist for longer than the lifecycle
   * of an individual pod.
   *
   * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
   * be used that way - see the documentation of the driver for
   * more information.
   *
   * A pod can use both types of ephemeral volumes and
   * persistent volumes at the same time.
   *
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.EphemeralVolumeSource ephemeral = 29;
   */
  ephemeral?: EphemeralVolumeSource;
};

/**
 * Represents the source of a volume to mount.
 * Only one of its members may be specified.
 *
 * @generated from message k8s.io.api.core.v1.VolumeSource
 */
export declare type VolumeSourceValid = Message<"k8s.io.api.core.v1.VolumeSource"> & {
  /**
   * hostPath represents a pre-existing file or directory on the host
   * machine that is directly exposed to the container. This is generally
   * used for system agents or other privileged things that are allowed
   * to see the host machine. Most containers will NOT need this.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * ---
   * TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not
   * mount host directories as read/write.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.HostPathVolumeSource hostPath = 1;
   */
  hostPath?: HostPathVolumeSourceValid;

  /**
   * emptyDir represents a temporary directory that shares a pod's lifetime.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.EmptyDirVolumeSource emptyDir = 2;
   */
  emptyDir?: EmptyDirVolumeSourceValid;

  /**
   * gcePersistentDisk represents a GCE Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.GCEPersistentDiskVolumeSource gcePersistentDisk = 3;
   */
  gcePersistentDisk?: GCEPersistentDiskVolumeSourceValid;

  /**
   * awsElasticBlockStore represents an AWS Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.AWSElasticBlockStoreVolumeSource awsElasticBlockStore = 4;
   */
  awsElasticBlockStore?: AWSElasticBlockStoreVolumeSourceValid;

  /**
   * gitRepo represents a git repository at a particular revision.
   * DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
   * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
   * into the Pod's container.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.GitRepoVolumeSource gitRepo = 5;
   */
  gitRepo?: GitRepoVolumeSourceValid;

  /**
   * secret represents a secret that should populate this volume.
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.SecretVolumeSource secret = 6;
   */
  secret?: SecretVolumeSourceValid;

  /**
   * nfs represents an NFS mount on the host that shares a pod's lifetime
   * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.NFSVolumeSource nfs = 7;
   */
  nfs?: NFSVolumeSourceValid;

  /**
   * iscsi represents an ISCSI Disk resource that is attached to a
   * kubelet's host machine and then exposed to the pod.
   * More info: https://examples.k8s.io/volumes/iscsi/README.md
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ISCSIVolumeSource iscsi = 8;
   */
  iscsi?: ISCSIVolumeSourceValid;

  /**
   * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
   * More info: https://examples.k8s.io/volumes/glusterfs/README.md
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.GlusterfsVolumeSource glusterfs = 9;
   */
  glusterfs?: GlusterfsVolumeSourceValid;

  /**
   * persistentVolumeClaimVolumeSource represents a reference to a
   * PersistentVolumeClaim in the same namespace.
   * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.PersistentVolumeClaimVolumeSource persistentVolumeClaim = 10;
   */
  persistentVolumeClaim?: PersistentVolumeClaimVolumeSourceValid;

  /**
   * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
   * More info: https://examples.k8s.io/volumes/rbd/README.md
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.RBDVolumeSource rbd = 11;
   */
  rbd?: RBDVolumeSourceValid;

  /**
   * flexVolume represents a generic volume resource that is
   * provisioned/attached using an exec based plugin.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.FlexVolumeSource flexVolume = 12;
   */
  flexVolume?: FlexVolumeSourceValid;

  /**
   * cinder represents a cinder volume attached and mounted on kubelets host machine.
   * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.CinderVolumeSource cinder = 13;
   */
  cinder?: CinderVolumeSourceValid;

  /**
   * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.CephFSVolumeSource cephfs = 14;
   */
  cephfs?: CephFSVolumeSourceValid;

  /**
   * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.FlockerVolumeSource flocker = 15;
   */
  flocker?: FlockerVolumeSourceValid;

  /**
   * downwardAPI represents downward API about the pod that should populate this volume
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.DownwardAPIVolumeSource downwardAPI = 16;
   */
  downwardAPI?: DownwardAPIVolumeSourceValid;

  /**
   * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.FCVolumeSource fc = 17;
   */
  fc?: FCVolumeSourceValid;

  /**
   * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.AzureFileVolumeSource azureFile = 18;
   */
  azureFile?: AzureFileVolumeSourceValid;

  /**
   * configMap represents a configMap that should populate this volume
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ConfigMapVolumeSource configMap = 19;
   */
  configMap?: ConfigMapVolumeSourceValid;

  /**
   * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.VsphereVirtualDiskVolumeSource vsphereVolume = 20;
   */
  vsphereVolume?: VsphereVirtualDiskVolumeSourceValid;

  /**
   * quobyte represents a Quobyte mount on the host that shares a pod's lifetime
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.QuobyteVolumeSource quobyte = 21;
   */
  quobyte?: QuobyteVolumeSourceValid;

  /**
   * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.AzureDiskVolumeSource azureDisk = 22;
   */
  azureDisk?: AzureDiskVolumeSourceValid;

  /**
   * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
   *
   * @generated from field: optional k8s.io.api.core.v1.PhotonPersistentDiskVolumeSource photonPersistentDisk = 23;
   */
  photonPersistentDisk?: PhotonPersistentDiskVolumeSourceValid;

  /**
   * projected items for all in one resources secrets, configmaps, and downward API
   *
   * @generated from field: optional k8s.io.api.core.v1.ProjectedVolumeSource projected = 26;
   */
  projected?: ProjectedVolumeSourceValid;

  /**
   * portworxVolume represents a portworx volume attached and mounted on kubelets host machine
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.PortworxVolumeSource portworxVolume = 24;
   */
  portworxVolume?: PortworxVolumeSourceValid;

  /**
   * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.ScaleIOVolumeSource scaleIO = 25;
   */
  scaleIO?: ScaleIOVolumeSourceValid;

  /**
   * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.StorageOSVolumeSource storageos = 27;
   */
  storageos?: StorageOSVolumeSourceValid;

  /**
   * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.CSIVolumeSource csi = 28;
   */
  csi?: CSIVolumeSourceValid;

  /**
   * ephemeral represents a volume that is handled by a cluster storage driver.
   * The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
   * and deleted when the pod is removed.
   *
   * Use this if:
   * a) the volume is only needed while the pod runs,
   * b) features of normal volumes like restoring from snapshot or capacity
   *    tracking are needed,
   * c) the storage driver is specified through a storage class, and
   * d) the storage driver supports dynamic volume provisioning through
   *    a PersistentVolumeClaim (see EphemeralVolumeSource for more
   *    information on the connection between this volume type
   *    and PersistentVolumeClaim).
   *
   * Use PersistentVolumeClaim or one of the vendor-specific
   * APIs for volumes that persist for longer than the lifecycle
   * of an individual pod.
   *
   * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
   * be used that way - see the documentation of the driver for
   * more information.
   *
   * A pod can use both types of ephemeral volumes and
   * persistent volumes at the same time.
   *
   * +optional
   *
   * @generated from field: optional k8s.io.api.core.v1.EphemeralVolumeSource ephemeral = 29;
   */
  ephemeral?: EphemeralVolumeSourceValid;
};

/**
 * Describes the message k8s.io.api.core.v1.VolumeSource.
 * Use `create(VolumeSourceSchema)` to create a new message.
 */
export declare const VolumeSourceSchema: GenMessage<VolumeSource, {validType: VolumeSourceValid}>;

/**
 * Represents a vSphere volume resource.
 *
 * @generated from message k8s.io.api.core.v1.VsphereVirtualDiskVolumeSource
 */
export declare type VsphereVirtualDiskVolumeSource = Message<"k8s.io.api.core.v1.VsphereVirtualDiskVolumeSource"> & {
  /**
   * volumePath is the path that identifies vSphere volume vmdk
   *
   * @generated from field: optional string volumePath = 1;
   */
  volumePath: string;

  /**
   * fsType is filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * +optional
   *
   * @generated from field: optional string fsType = 2;
   */
  fsType: string;

  /**
   * storagePolicyName is the storage Policy Based Management (SPBM) profile name.
   * +optional
   *
   * @generated from field: optional string storagePolicyName = 3;
   */
  storagePolicyName: string;

  /**
   * storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
   * +optional
   *
   * @generated from field: optional string storagePolicyID = 4;
   */
  storagePolicyID: string;
};

/**
 * Represents a vSphere volume resource.
 *
 * @generated from message k8s.io.api.core.v1.VsphereVirtualDiskVolumeSource
 */
export declare type VsphereVirtualDiskVolumeSourceValid = Message<"k8s.io.api.core.v1.VsphereVirtualDiskVolumeSource"> & {
  /**
   * volumePath is the path that identifies vSphere volume vmdk
   *
   * @generated from field: optional string volumePath = 1;
   */
  volumePath: string;

  /**
   * fsType is filesystem type to mount.
   * Must be a filesystem type supported by the host operating system.
   * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   * +optional
   *
   * @generated from field: optional string fsType = 2;
   */
  fsType: string;

  /**
   * storagePolicyName is the storage Policy Based Management (SPBM) profile name.
   * +optional
   *
   * @generated from field: optional string storagePolicyName = 3;
   */
  storagePolicyName: string;

  /**
   * storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
   * +optional
   *
   * @generated from field: optional string storagePolicyID = 4;
   */
  storagePolicyID: string;
};

/**
 * Describes the message k8s.io.api.core.v1.VsphereVirtualDiskVolumeSource.
 * Use `create(VsphereVirtualDiskVolumeSourceSchema)` to create a new message.
 */
export declare const VsphereVirtualDiskVolumeSourceSchema: GenMessage<VsphereVirtualDiskVolumeSource, {validType: VsphereVirtualDiskVolumeSourceValid}>;

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @generated from message k8s.io.api.core.v1.WeightedPodAffinityTerm
 */
export declare type WeightedPodAffinityTerm = Message<"k8s.io.api.core.v1.WeightedPodAffinityTerm"> & {
  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @generated from field: optional int32 weight = 1;
   */
  weight: number;

  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @generated from field: optional k8s.io.api.core.v1.PodAffinityTerm podAffinityTerm = 2;
   */
  podAffinityTerm?: PodAffinityTerm;
};

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @generated from message k8s.io.api.core.v1.WeightedPodAffinityTerm
 */
export declare type WeightedPodAffinityTermValid = Message<"k8s.io.api.core.v1.WeightedPodAffinityTerm"> & {
  /**
   * weight associated with matching the corresponding podAffinityTerm,
   * in the range 1-100.
   *
   * @generated from field: optional int32 weight = 1;
   */
  weight: number;

  /**
   * Required. A pod affinity term, associated with the corresponding weight.
   *
   * @generated from field: optional k8s.io.api.core.v1.PodAffinityTerm podAffinityTerm = 2;
   */
  podAffinityTerm?: PodAffinityTermValid;
};

/**
 * Describes the message k8s.io.api.core.v1.WeightedPodAffinityTerm.
 * Use `create(WeightedPodAffinityTermSchema)` to create a new message.
 */
export declare const WeightedPodAffinityTermSchema: GenMessage<WeightedPodAffinityTerm, {validType: WeightedPodAffinityTermValid}>;

/**
 * WindowsSecurityContextOptions contain Windows-specific options and credentials.
 *
 * @generated from message k8s.io.api.core.v1.WindowsSecurityContextOptions
 */
export declare type WindowsSecurityContextOptions = Message<"k8s.io.api.core.v1.WindowsSecurityContextOptions"> & {
  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   * +optional
   *
   * @generated from field: optional string gmsaCredentialSpecName = 1;
   */
  gmsaCredentialSpecName: string;

  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   * +optional
   *
   * @generated from field: optional string gmsaCredentialSpec = 2;
   */
  gmsaCredentialSpec: string;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * +optional
   *
   * @generated from field: optional string runAsUserName = 3;
   */
  runAsUserName: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * This field is alpha-level and will only be honored by components that enable the
   * WindowsHostProcessContainers feature flag. Setting this field without the feature
   * flag will result in errors when validating the Pod. All of a Pod's containers must
   * have the same effective HostProcess value (it is not allowed to have a mix of HostProcess
   * containers and non-HostProcess containers).  In addition, if HostProcess is true
   * then HostNetwork must also be set to true.
   * +optional
   *
   * @generated from field: optional bool hostProcess = 4;
   */
  hostProcess: boolean;
};

/**
 * WindowsSecurityContextOptions contain Windows-specific options and credentials.
 *
 * @generated from message k8s.io.api.core.v1.WindowsSecurityContextOptions
 */
export declare type WindowsSecurityContextOptionsValid = Message<"k8s.io.api.core.v1.WindowsSecurityContextOptions"> & {
  /**
   * GMSACredentialSpecName is the name of the GMSA credential spec to use.
   * +optional
   *
   * @generated from field: optional string gmsaCredentialSpecName = 1;
   */
  gmsaCredentialSpecName: string;

  /**
   * GMSACredentialSpec is where the GMSA admission webhook
   * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
   * GMSA credential spec named by the GMSACredentialSpecName field.
   * +optional
   *
   * @generated from field: optional string gmsaCredentialSpec = 2;
   */
  gmsaCredentialSpec: string;

  /**
   * The UserName in Windows to run the entrypoint of the container process.
   * Defaults to the user specified in image metadata if unspecified.
   * May also be set in PodSecurityContext. If set in both SecurityContext and
   * PodSecurityContext, the value specified in SecurityContext takes precedence.
   * +optional
   *
   * @generated from field: optional string runAsUserName = 3;
   */
  runAsUserName: string;

  /**
   * HostProcess determines if a container should be run as a 'Host Process' container.
   * This field is alpha-level and will only be honored by components that enable the
   * WindowsHostProcessContainers feature flag. Setting this field without the feature
   * flag will result in errors when validating the Pod. All of a Pod's containers must
   * have the same effective HostProcess value (it is not allowed to have a mix of HostProcess
   * containers and non-HostProcess containers).  In addition, if HostProcess is true
   * then HostNetwork must also be set to true.
   * +optional
   *
   * @generated from field: optional bool hostProcess = 4;
   */
  hostProcess: boolean;
};

/**
 * Describes the message k8s.io.api.core.v1.WindowsSecurityContextOptions.
 * Use `create(WindowsSecurityContextOptionsSchema)` to create a new message.
 */
export declare const WindowsSecurityContextOptionsSchema: GenMessage<WindowsSecurityContextOptions, {validType: WindowsSecurityContextOptionsValid}>;

